/*
 *	server/zone/objects/tangible/weapon/WeaponObject.cpp generated by engine3 IDL compiler 0.60
 */

#include "WeaponObject.h"

#include "server/zone/objects/scene/SceneObject.h"

#include "server/zone/objects/player/PlayerCreature.h"

#include "server/zone/packets/scene/AttributeListMessage.h"

#include "server/zone/Zone.h"

#include "server/zone/objects/manufactureschematic/ManufactureSchematic.h"

#include "server/zone/templates/SharedObjectTemplate.h"

#include "server/zone/packets/object/ObjectMenuResponse.h"

/*
 *	WeaponObjectStub
 */

enum {RPC_INITIALIZETRANSIENTMEMBERS__,RPC_SENDBASELINESTO__SCENEOBJECT_,RPC_HANDLEOBJECTMENUSELECT__PLAYERCREATURE_BYTE_,RPC_UPDATECRAFTINGVALUES__MANUFACTURESCHEMATIC_,RPC_ISCERTIFIEDFOR__PLAYERCREATURE_,RPC_SETCERTIFIED__BOOL_,RPC_GETATTACKTYPE__,RPC_ISCERTIFIED__,RPC_GETPOINTBLANKACCURACY__,RPC_SETPOINTBLANKACCURACY__INT_,RPC_GETPOINTBLANKRANGE__,RPC_GETIDEALRANGE__,RPC_SETIDEALRANGE__INT_,RPC_GETMAXRANGE__,RPC_SETMAXRANGE__INT_,RPC_GETIDEALACCURACY__,RPC_SETIDEALACCURACY__INT_,RPC_GETARMORPIERCING__,RPC_GETMAXRANGEACCURACY__,RPC_SETMAXRANGEACCURACY__INT_,RPC_GETATTACKSPEED__,RPC_SETATTACKSPEED__FLOAT_,RPC_GETMAXDAMAGE__,RPC_SETMAXDAMAGE__FLOAT_,RPC_GETMINDAMAGE__,RPC_SETMINDAMAGE__FLOAT_,RPC_GETWOUNDSRATIO__,RPC_SETWOUNDSRATIO__FLOAT_,RPC_GETHEALTHATTACKCOST__,RPC_SETHEALTHATTACKCOST__INT_,RPC_GETACTIONATTACKCOST__,RPC_SETACTIONATTACKCOST__INT_,RPC_GETMINDATTACKCOST__,RPC_SETMINDATTACKCOST__INT_,RPC_GETFORCECOST__,RPC_GETDAMAGETYPE__,RPC_GETXPTYPE__,RPC_ISUNARMEDWEAPON__,RPC_ISMELEEWEAPON__,RPC_ISRANGEDWEAPON__,RPC_ISRIFLEWEAPON__,RPC_ISTHROWNWEAPON__,RPC_ISHEAVYWEAPON__,RPC_ISSPECIALHEAVYWEAPON__,RPC_ISLIGHTNINGRIFLE__,RPC_ISCARBINEWEAPON__,RPC_ISPISTOLWEAPON__,RPC_ISONEHANDMELEEWEAPON__,RPC_ISPOLEARMWEAPONOBJECT__,RPC_ISTWOHANDMELEEWEAPON__,RPC_ISWEAPONOBJECT__};

WeaponObject::WeaponObject() : TangibleObject(DummyConstructorParameter::instance()) {
	WeaponObjectImplementation* _implementation = new WeaponObjectImplementation();
	_impl = _implementation;
	_impl->_setStub(this);
}

WeaponObject::WeaponObject(DummyConstructorParameter* param) : TangibleObject(param) {
}

WeaponObject::~WeaponObject() {
}


void WeaponObject::loadTemplateData(SharedObjectTemplate* templateData) {
	WeaponObjectImplementation* _implementation = (WeaponObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		_implementation->loadTemplateData(templateData);
}

void WeaponObject::initializeTransientMembers() {
	WeaponObjectImplementation* _implementation = (WeaponObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INITIALIZETRANSIENTMEMBERS__);

		method.executeWithVoidReturn();
	} else
		_implementation->initializeTransientMembers();
}

void WeaponObject::sendBaselinesTo(SceneObject* player) {
	WeaponObjectImplementation* _implementation = (WeaponObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDBASELINESTO__SCENEOBJECT_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else
		_implementation->sendBaselinesTo(player);
}

void WeaponObject::fillAttributeList(AttributeListMessage* msg, PlayerCreature* object) {
	WeaponObjectImplementation* _implementation = (WeaponObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		_implementation->fillAttributeList(msg, object);
}

int WeaponObject::handleObjectMenuSelect(PlayerCreature* player, byte selectedID) {
	WeaponObjectImplementation* _implementation = (WeaponObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HANDLEOBJECTMENUSELECT__PLAYERCREATURE_BYTE_);
		method.addObjectParameter(player);
		method.addByteParameter(selectedID);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->handleObjectMenuSelect(player, selectedID);
}

void WeaponObject::updateCraftingValues(ManufactureSchematic* schematic) {
	WeaponObjectImplementation* _implementation = (WeaponObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATECRAFTINGVALUES__MANUFACTURESCHEMATIC_);
		method.addObjectParameter(schematic);

		method.executeWithVoidReturn();
	} else
		_implementation->updateCraftingValues(schematic);
}

bool WeaponObject::isCertifiedFor(PlayerCreature* object) {
	WeaponObjectImplementation* _implementation = (WeaponObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISCERTIFIEDFOR__PLAYERCREATURE_);
		method.addObjectParameter(object);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isCertifiedFor(object);
}

Vector<String>* WeaponObject::getDamageModifiers() {
	WeaponObjectImplementation* _implementation = (WeaponObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		return _implementation->getDamageModifiers();
}

Vector<String>* WeaponObject::getSpeedModifiers() {
	WeaponObjectImplementation* _implementation = (WeaponObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		return _implementation->getSpeedModifiers();
}

Vector<String>* WeaponObject::getCreatureAccuracyModifiers() {
	WeaponObjectImplementation* _implementation = (WeaponObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		return _implementation->getCreatureAccuracyModifiers();
}

Vector<String>* WeaponObject::getDefenderDefenseModifiers() {
	WeaponObjectImplementation* _implementation = (WeaponObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		return _implementation->getDefenderDefenseModifiers();
}

Vector<String>* WeaponObject::getDefenderSecondaryDefenseModifiers() {
	WeaponObjectImplementation* _implementation = (WeaponObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		return _implementation->getDefenderSecondaryDefenseModifiers();
}

void WeaponObject::setCertified(bool cert) {
	WeaponObjectImplementation* _implementation = (WeaponObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCERTIFIED__BOOL_);
		method.addBooleanParameter(cert);

		method.executeWithVoidReturn();
	} else
		_implementation->setCertified(cert);
}

int WeaponObject::getAttackType() {
	WeaponObjectImplementation* _implementation = (WeaponObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETATTACKTYPE__);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getAttackType();
}

bool WeaponObject::isCertified() {
	WeaponObjectImplementation* _implementation = (WeaponObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISCERTIFIED__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isCertified();
}

int WeaponObject::getPointBlankAccuracy() {
	WeaponObjectImplementation* _implementation = (WeaponObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETPOINTBLANKACCURACY__);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getPointBlankAccuracy();
}

void WeaponObject::setPointBlankAccuracy(int value) {
	WeaponObjectImplementation* _implementation = (WeaponObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETPOINTBLANKACCURACY__INT_);
		method.addSignedIntParameter(value);

		method.executeWithVoidReturn();
	} else
		_implementation->setPointBlankAccuracy(value);
}

int WeaponObject::getPointBlankRange() {
	WeaponObjectImplementation* _implementation = (WeaponObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETPOINTBLANKRANGE__);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getPointBlankRange();
}

int WeaponObject::getIdealRange() {
	WeaponObjectImplementation* _implementation = (WeaponObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETIDEALRANGE__);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getIdealRange();
}

void WeaponObject::setIdealRange(int value) {
	WeaponObjectImplementation* _implementation = (WeaponObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETIDEALRANGE__INT_);
		method.addSignedIntParameter(value);

		method.executeWithVoidReturn();
	} else
		_implementation->setIdealRange(value);
}

int WeaponObject::getMaxRange() {
	WeaponObjectImplementation* _implementation = (WeaponObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETMAXRANGE__);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getMaxRange();
}

void WeaponObject::setMaxRange(int value) {
	WeaponObjectImplementation* _implementation = (WeaponObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETMAXRANGE__INT_);
		method.addSignedIntParameter(value);

		method.executeWithVoidReturn();
	} else
		_implementation->setMaxRange(value);
}

int WeaponObject::getIdealAccuracy() {
	WeaponObjectImplementation* _implementation = (WeaponObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETIDEALACCURACY__);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getIdealAccuracy();
}

void WeaponObject::setIdealAccuracy(int value) {
	WeaponObjectImplementation* _implementation = (WeaponObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETIDEALACCURACY__INT_);
		method.addSignedIntParameter(value);

		method.executeWithVoidReturn();
	} else
		_implementation->setIdealAccuracy(value);
}

int WeaponObject::getArmorPiercing() {
	WeaponObjectImplementation* _implementation = (WeaponObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETARMORPIERCING__);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getArmorPiercing();
}

int WeaponObject::getMaxRangeAccuracy() {
	WeaponObjectImplementation* _implementation = (WeaponObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETMAXRANGEACCURACY__);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getMaxRangeAccuracy();
}

void WeaponObject::setMaxRangeAccuracy(int value) {
	WeaponObjectImplementation* _implementation = (WeaponObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETMAXRANGEACCURACY__INT_);
		method.addSignedIntParameter(value);

		method.executeWithVoidReturn();
	} else
		_implementation->setMaxRangeAccuracy(value);
}

float WeaponObject::getAttackSpeed() {
	WeaponObjectImplementation* _implementation = (WeaponObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETATTACKSPEED__);

		return method.executeWithFloatReturn();
	} else
		return _implementation->getAttackSpeed();
}

void WeaponObject::setAttackSpeed(float value) {
	WeaponObjectImplementation* _implementation = (WeaponObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETATTACKSPEED__FLOAT_);
		method.addFloatParameter(value);

		method.executeWithVoidReturn();
	} else
		_implementation->setAttackSpeed(value);
}

float WeaponObject::getMaxDamage() {
	WeaponObjectImplementation* _implementation = (WeaponObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETMAXDAMAGE__);

		return method.executeWithFloatReturn();
	} else
		return _implementation->getMaxDamage();
}

void WeaponObject::setMaxDamage(float value) {
	WeaponObjectImplementation* _implementation = (WeaponObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETMAXDAMAGE__FLOAT_);
		method.addFloatParameter(value);

		method.executeWithVoidReturn();
	} else
		_implementation->setMaxDamage(value);
}

float WeaponObject::getMinDamage() {
	WeaponObjectImplementation* _implementation = (WeaponObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETMINDAMAGE__);

		return method.executeWithFloatReturn();
	} else
		return _implementation->getMinDamage();
}

void WeaponObject::setMinDamage(float value) {
	WeaponObjectImplementation* _implementation = (WeaponObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETMINDAMAGE__FLOAT_);
		method.addFloatParameter(value);

		method.executeWithVoidReturn();
	} else
		_implementation->setMinDamage(value);
}

float WeaponObject::getWoundsRatio() {
	WeaponObjectImplementation* _implementation = (WeaponObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETWOUNDSRATIO__);

		return method.executeWithFloatReturn();
	} else
		return _implementation->getWoundsRatio();
}

void WeaponObject::setWoundsRatio(float value) {
	WeaponObjectImplementation* _implementation = (WeaponObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETWOUNDSRATIO__FLOAT_);
		method.addFloatParameter(value);

		method.executeWithVoidReturn();
	} else
		_implementation->setWoundsRatio(value);
}

int WeaponObject::getHealthAttackCost() {
	WeaponObjectImplementation* _implementation = (WeaponObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETHEALTHATTACKCOST__);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getHealthAttackCost();
}

void WeaponObject::setHealthAttackCost(int value) {
	WeaponObjectImplementation* _implementation = (WeaponObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETHEALTHATTACKCOST__INT_);
		method.addSignedIntParameter(value);

		method.executeWithVoidReturn();
	} else
		_implementation->setHealthAttackCost(value);
}

int WeaponObject::getActionAttackCost() {
	WeaponObjectImplementation* _implementation = (WeaponObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETACTIONATTACKCOST__);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getActionAttackCost();
}

void WeaponObject::setActionAttackCost(int value) {
	WeaponObjectImplementation* _implementation = (WeaponObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETACTIONATTACKCOST__INT_);
		method.addSignedIntParameter(value);

		method.executeWithVoidReturn();
	} else
		_implementation->setActionAttackCost(value);
}

int WeaponObject::getMindAttackCost() {
	WeaponObjectImplementation* _implementation = (WeaponObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETMINDATTACKCOST__);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getMindAttackCost();
}

void WeaponObject::setMindAttackCost(int value) {
	WeaponObjectImplementation* _implementation = (WeaponObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETMINDATTACKCOST__INT_);
		method.addSignedIntParameter(value);

		method.executeWithVoidReturn();
	} else
		_implementation->setMindAttackCost(value);
}

int WeaponObject::getForceCost() {
	WeaponObjectImplementation* _implementation = (WeaponObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETFORCECOST__);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getForceCost();
}

int WeaponObject::getDamageType() {
	WeaponObjectImplementation* _implementation = (WeaponObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETDAMAGETYPE__);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getDamageType();
}

String WeaponObject::getXpType() {
	WeaponObjectImplementation* _implementation = (WeaponObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETXPTYPE__);

		method.executeWithAsciiReturn(_return_getXpType);
		return _return_getXpType;
	} else
		return _implementation->getXpType();
}

bool WeaponObject::isUnarmedWeapon() {
	WeaponObjectImplementation* _implementation = (WeaponObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISUNARMEDWEAPON__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isUnarmedWeapon();
}

bool WeaponObject::isMeleeWeapon() {
	WeaponObjectImplementation* _implementation = (WeaponObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISMELEEWEAPON__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isMeleeWeapon();
}

bool WeaponObject::isRangedWeapon() {
	WeaponObjectImplementation* _implementation = (WeaponObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISRANGEDWEAPON__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isRangedWeapon();
}

bool WeaponObject::isRifleWeapon() {
	WeaponObjectImplementation* _implementation = (WeaponObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISRIFLEWEAPON__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isRifleWeapon();
}

bool WeaponObject::isThrownWeapon() {
	WeaponObjectImplementation* _implementation = (WeaponObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISTHROWNWEAPON__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isThrownWeapon();
}

bool WeaponObject::isHeavyWeapon() {
	WeaponObjectImplementation* _implementation = (WeaponObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISHEAVYWEAPON__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isHeavyWeapon();
}

bool WeaponObject::isSpecialHeavyWeapon() {
	WeaponObjectImplementation* _implementation = (WeaponObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISSPECIALHEAVYWEAPON__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isSpecialHeavyWeapon();
}

bool WeaponObject::isLightningRifle() {
	WeaponObjectImplementation* _implementation = (WeaponObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISLIGHTNINGRIFLE__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isLightningRifle();
}

bool WeaponObject::isCarbineWeapon() {
	WeaponObjectImplementation* _implementation = (WeaponObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISCARBINEWEAPON__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isCarbineWeapon();
}

bool WeaponObject::isPistolWeapon() {
	WeaponObjectImplementation* _implementation = (WeaponObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISPISTOLWEAPON__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isPistolWeapon();
}

bool WeaponObject::isOneHandMeleeWeapon() {
	WeaponObjectImplementation* _implementation = (WeaponObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISONEHANDMELEEWEAPON__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isOneHandMeleeWeapon();
}

bool WeaponObject::isPolearmWeaponObject() {
	WeaponObjectImplementation* _implementation = (WeaponObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISPOLEARMWEAPONOBJECT__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isPolearmWeaponObject();
}

bool WeaponObject::isTwoHandMeleeWeapon() {
	WeaponObjectImplementation* _implementation = (WeaponObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISTWOHANDMELEEWEAPON__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isTwoHandMeleeWeapon();
}

bool WeaponObject::isWeaponObject() {
	WeaponObjectImplementation* _implementation = (WeaponObjectImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISWEAPONOBJECT__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isWeaponObject();
}

DistributedObjectServant* WeaponObject::_getImplementation() {

	_updated = true;
	return _impl;
}

void WeaponObject::_setImplementation(DistributedObjectServant* servant) {
	_impl = servant;
}

/*
 *	WeaponObjectImplementation
 */

WeaponObjectImplementation::WeaponObjectImplementation(DummyConstructorParameter* param) : TangibleObjectImplementation(param) {
	_initializeImplementation();
}


WeaponObjectImplementation::~WeaponObjectImplementation() {
}


void WeaponObjectImplementation::finalize() {
}

void WeaponObjectImplementation::_initializeImplementation() {
	_setClassHelper(WeaponObjectHelper::instance());

	_serializationHelperMethod();
	_serializationHelperMethod();
}

void WeaponObjectImplementation::_setStub(DistributedObjectStub* stub) {
	_this = (WeaponObject*) stub;
	TangibleObjectImplementation::_setStub(stub);
}

DistributedObjectStub* WeaponObjectImplementation::_getStub() {
	return _this;
}

WeaponObjectImplementation::operator const WeaponObject*() {
	return _this;
}

void WeaponObjectImplementation::lock(bool doLock) {
	_this->lock(doLock);
}

void WeaponObjectImplementation::lock(ManagedObject* obj) {
	_this->lock(obj);
}

void WeaponObjectImplementation::rlock(bool doLock) {
	_this->rlock(doLock);
}

void WeaponObjectImplementation::wlock(bool doLock) {
	_this->wlock(doLock);
}

void WeaponObjectImplementation::wlock(ManagedObject* obj) {
	_this->wlock(obj);
}

void WeaponObjectImplementation::unlock(bool doLock) {
	_this->unlock(doLock);
}

void WeaponObjectImplementation::runlock(bool doLock) {
	_this->runlock(doLock);
}

void WeaponObjectImplementation::_serializationHelperMethod() {
	TangibleObjectImplementation::_serializationHelperMethod();

	_setClassName("WeaponObject");

}

void WeaponObjectImplementation::readObject(ObjectInputStream* stream) {
	uint16 _varCount = stream->readShort();
	for (int i = 0; i < _varCount; ++i) {
		String _name;
		_name.parseFromBinaryStream(stream);

		uint16 _varSize = stream->readShort();

		int _currentOffset = stream->getOffset();

		if(WeaponObjectImplementation::readObjectMember(stream, _name)) {
		}

		stream->setOffset(_currentOffset + _varSize);
	}

	initializeTransientMembers();
}

bool WeaponObjectImplementation::readObjectMember(ObjectInputStream* stream, const String& _name) {
	if (TangibleObjectImplementation::readObjectMember(stream, _name))
		return true;

	if (_name == "attackType") {
		TypeInfo<int >::parseFromBinaryStream(&attackType, stream);
		return true;
	}

	if (_name == "weaponEffect") {
		TypeInfo<String >::parseFromBinaryStream(&weaponEffect, stream);
		return true;
	}

	if (_name == "weaponEffectIndex") {
		TypeInfo<int >::parseFromBinaryStream(&weaponEffectIndex, stream);
		return true;
	}

	if (_name == "certified") {
		TypeInfo<bool >::parseFromBinaryStream(&certified, stream);
		return true;
	}

	if (_name == "armorPiercing") {
		TypeInfo<int >::parseFromBinaryStream(&armorPiercing, stream);
		return true;
	}

	if (_name == "pointBlankAccuracy") {
		TypeInfo<int >::parseFromBinaryStream(&pointBlankAccuracy, stream);
		return true;
	}

	if (_name == "pointBlankRange") {
		TypeInfo<int >::parseFromBinaryStream(&pointBlankRange, stream);
		return true;
	}

	if (_name == "idealRange") {
		TypeInfo<int >::parseFromBinaryStream(&idealRange, stream);
		return true;
	}

	if (_name == "idealAccuracy") {
		TypeInfo<int >::parseFromBinaryStream(&idealAccuracy, stream);
		return true;
	}

	if (_name == "maxRange") {
		TypeInfo<int >::parseFromBinaryStream(&maxRange, stream);
		return true;
	}

	if (_name == "maxRangeAccuracy") {
		TypeInfo<int >::parseFromBinaryStream(&maxRangeAccuracy, stream);
		return true;
	}

	if (_name == "damageType") {
		TypeInfo<int >::parseFromBinaryStream(&damageType, stream);
		return true;
	}

	if (_name == "attackSpeed") {
		TypeInfo<float >::parseFromBinaryStream(&attackSpeed, stream);
		return true;
	}

	if (_name == "minDamage") {
		TypeInfo<float >::parseFromBinaryStream(&minDamage, stream);
		return true;
	}

	if (_name == "maxDamage") {
		TypeInfo<float >::parseFromBinaryStream(&maxDamage, stream);
		return true;
	}

	if (_name == "area") {
		TypeInfo<float >::parseFromBinaryStream(&area, stream);
		return true;
	}

	if (_name == "woundsRatio") {
		TypeInfo<float >::parseFromBinaryStream(&woundsRatio, stream);
		return true;
	}

	if (_name == "healthAttackCost") {
		TypeInfo<int >::parseFromBinaryStream(&healthAttackCost, stream);
		return true;
	}

	if (_name == "actionAttackCost") {
		TypeInfo<int >::parseFromBinaryStream(&actionAttackCost, stream);
		return true;
	}

	if (_name == "mindAttackCost") {
		TypeInfo<int >::parseFromBinaryStream(&mindAttackCost, stream);
		return true;
	}

	if (_name == "forceCost") {
		TypeInfo<int >::parseFromBinaryStream(&forceCost, stream);
		return true;
	}


	return false;
}

void WeaponObjectImplementation::writeObject(ObjectOutputStream* stream) {
	int _currentOffset = stream->getOffset();
	stream->writeShort(0);
	int _varCount = WeaponObjectImplementation::writeObjectMembers(stream);
	stream->writeShort(_currentOffset, _varCount);
}

int WeaponObjectImplementation::writeObjectMembers(ObjectOutputStream* stream) {
	String _name;
	int _offset;
	uint16 _totalSize;
	_name = "attackType";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<int >::toBinaryStream(&attackType, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "weaponEffect";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<String >::toBinaryStream(&weaponEffect, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "weaponEffectIndex";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<int >::toBinaryStream(&weaponEffectIndex, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "certified";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<bool >::toBinaryStream(&certified, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "armorPiercing";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<int >::toBinaryStream(&armorPiercing, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "pointBlankAccuracy";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<int >::toBinaryStream(&pointBlankAccuracy, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "pointBlankRange";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<int >::toBinaryStream(&pointBlankRange, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "idealRange";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<int >::toBinaryStream(&idealRange, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "idealAccuracy";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<int >::toBinaryStream(&idealAccuracy, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "maxRange";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<int >::toBinaryStream(&maxRange, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "maxRangeAccuracy";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<int >::toBinaryStream(&maxRangeAccuracy, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "damageType";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<int >::toBinaryStream(&damageType, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "attackSpeed";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<float >::toBinaryStream(&attackSpeed, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "minDamage";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<float >::toBinaryStream(&minDamage, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "maxDamage";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<float >::toBinaryStream(&maxDamage, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "area";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<float >::toBinaryStream(&area, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "woundsRatio";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<float >::toBinaryStream(&woundsRatio, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "healthAttackCost";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<int >::toBinaryStream(&healthAttackCost, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "actionAttackCost";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<int >::toBinaryStream(&actionAttackCost, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "mindAttackCost";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<int >::toBinaryStream(&mindAttackCost, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "forceCost";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<int >::toBinaryStream(&forceCost, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);


	return 21 + TangibleObjectImplementation::writeObjectMembers(stream);
}

WeaponObjectImplementation::WeaponObjectImplementation() {
	_initializeImplementation();
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		certified = false;
	certified = false;
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		armorPiercing = 0;
	armorPiercing = 0;
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		healthAttackCost = 0;
	healthAttackCost = 0;
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		actionAttackCost = 0;
	actionAttackCost = 0;
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		mindAttackCost = 0;
	mindAttackCost = 0;
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		forceCost = 0;
	forceCost = 0;
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		pointBlankAccuracy = 0;
	pointBlankAccuracy = 0;
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		pointBlankRange = 0;
	pointBlankRange = 0;
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		idealRange = 0;
	idealRange = 0;
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		idealAccuracy = 0;
	idealAccuracy = 0;
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		maxRange = 5;
	maxRange = 5;
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		maxRangeAccuracy = 0;
	maxRangeAccuracy = 0;
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		damageType = 0;
	damageType = 0;
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		minDamage = 1;
	minDamage = 1;
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		maxDamage = 10;
	maxDamage = 10;
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		woundsRatio = 0;
	woundsRatio = 0;
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		area = 0;
	area = 0;
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		attackSpeed = 1;
	attackSpeed = 1;
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		weaponTemplate = null;
	weaponTemplate = NULL;
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		Logger.setLoggingName("WeaponObject");
	Logger::setLoggingName("WeaponObject");
}

Vector<String>* WeaponObjectImplementation::getDamageModifiers() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return weaponTemplate.getDamageModifiers();
	return weaponTemplate->getDamageModifiers();
}

Vector<String>* WeaponObjectImplementation::getSpeedModifiers() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return weaponTemplate.getSpeedModifiers();
	return weaponTemplate->getSpeedModifiers();
}

Vector<String>* WeaponObjectImplementation::getCreatureAccuracyModifiers() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return weaponTemplate.getCreatureAccuracyModifiers();
	return weaponTemplate->getCreatureAccuracyModifiers();
}

Vector<String>* WeaponObjectImplementation::getDefenderDefenseModifiers() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return weaponTemplate.getDefenderDefenseModifiers();
	return weaponTemplate->getDefenderDefenseModifiers();
}

Vector<String>* WeaponObjectImplementation::getDefenderSecondaryDefenseModifiers() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return weaponTemplate.getDefenderSecondaryDefenseModifiers();
	return weaponTemplate->getDefenderSecondaryDefenseModifiers();
}

void WeaponObjectImplementation::setCertified(bool cert) {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		certified = cert;
	certified = cert;
}

int WeaponObjectImplementation::getAttackType() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return attackType;
	return attackType;
}

bool WeaponObjectImplementation::isCertified() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return certified;
	return certified;
}

int WeaponObjectImplementation::getPointBlankAccuracy() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return pointBlankAccuracy;
	return pointBlankAccuracy;
}

void WeaponObjectImplementation::setPointBlankAccuracy(int value) {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		pointBlankAccuracy = value;
	pointBlankAccuracy = value;
}

int WeaponObjectImplementation::getPointBlankRange() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return pointBlankRange;
	return pointBlankRange;
}

int WeaponObjectImplementation::getIdealRange() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return idealRange;
	return idealRange;
}

void WeaponObjectImplementation::setIdealRange(int value) {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		idealRange = value;
	idealRange = value;
}

int WeaponObjectImplementation::getMaxRange() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return maxRange;
	return maxRange;
}

void WeaponObjectImplementation::setMaxRange(int value) {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		maxRange = value;
	maxRange = value;
}

int WeaponObjectImplementation::getIdealAccuracy() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return idealAccuracy;
	return idealAccuracy;
}

void WeaponObjectImplementation::setIdealAccuracy(int value) {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		idealAccuracy = value;
	idealAccuracy = value;
}

int WeaponObjectImplementation::getArmorPiercing() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return armorPiercing;
	return armorPiercing;
}

int WeaponObjectImplementation::getMaxRangeAccuracy() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return maxRangeAccuracy;
	return maxRangeAccuracy;
}

void WeaponObjectImplementation::setMaxRangeAccuracy(int value) {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		maxRangeAccuracy = value;
	maxRangeAccuracy = value;
}

float WeaponObjectImplementation::getAttackSpeed() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return attackSpeed;
	return attackSpeed;
}

void WeaponObjectImplementation::setAttackSpeed(float value) {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		attackSpeed = value;
	attackSpeed = value;
}

float WeaponObjectImplementation::getMaxDamage() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return maxDamage;
	return maxDamage;
}

void WeaponObjectImplementation::setMaxDamage(float value) {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		maxDamage = value;
	maxDamage = value;
}

float WeaponObjectImplementation::getMinDamage() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return minDamage;
	return minDamage;
}

void WeaponObjectImplementation::setMinDamage(float value) {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		minDamage = value;
	minDamage = value;
}

float WeaponObjectImplementation::getWoundsRatio() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return woundsRatio;
	return woundsRatio;
}

void WeaponObjectImplementation::setWoundsRatio(float value) {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		woundsRatio = value;
	woundsRatio = value;
}

int WeaponObjectImplementation::getHealthAttackCost() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return healthAttackCost;
	return healthAttackCost;
}

void WeaponObjectImplementation::setHealthAttackCost(int value) {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		healthAttackCost = value;
	healthAttackCost = value;
}

int WeaponObjectImplementation::getActionAttackCost() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return actionAttackCost;
	return actionAttackCost;
}

void WeaponObjectImplementation::setActionAttackCost(int value) {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		actionAttackCost = value;
	actionAttackCost = value;
}

int WeaponObjectImplementation::getMindAttackCost() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return mindAttackCost;
	return mindAttackCost;
}

void WeaponObjectImplementation::setMindAttackCost(int value) {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		mindAttackCost = value;
	mindAttackCost = value;
}

int WeaponObjectImplementation::getForceCost() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return forceCost;
	return forceCost;
}

int WeaponObjectImplementation::getDamageType() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return damageType;
	return damageType;
}

String WeaponObjectImplementation::getXpType() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return weaponTemplate.getXpType();
	return weaponTemplate->getXpType();
}

bool WeaponObjectImplementation::isUnarmedWeapon() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return super.gameObjectType == SceneObject.WEAPON || super.gameObjectType == SceneObject.MELEEWEAPON;
	return TangibleObjectImplementation::gameObjectType == SceneObject::WEAPON || TangibleObjectImplementation::gameObjectType == SceneObject::MELEEWEAPON;
}

bool WeaponObjectImplementation::isMeleeWeapon() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return attackType == MELEEATTACK;
	return attackType == MELEEATTACK;
}

bool WeaponObjectImplementation::isRangedWeapon() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return attackType == RANGEDATTACK;
	return attackType == RANGEDATTACK;
}

bool WeaponObjectImplementation::isRifleWeapon() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return super.gameObjectType == SceneObject.RIFLE;
	return TangibleObjectImplementation::gameObjectType == SceneObject::RIFLE;
}

bool WeaponObjectImplementation::isThrownWeapon() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return super.gameObjectType == SceneObject.THROWNWEAPON;
	return TangibleObjectImplementation::gameObjectType == SceneObject::THROWNWEAPON;
}

bool WeaponObjectImplementation::isHeavyWeapon() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return super.gameObjectType == SceneObject.HEAVYWEAPON;
	return TangibleObjectImplementation::gameObjectType == SceneObject::HEAVYWEAPON;
}

bool WeaponObjectImplementation::isSpecialHeavyWeapon() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return super.gameObjectType == SceneObject.SPECIALHEAVYWEAPON;
	return TangibleObjectImplementation::gameObjectType == SceneObject::SPECIALHEAVYWEAPON;
}

bool WeaponObjectImplementation::isLightningRifle() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return super.gameObjectType == SceneObject.LIGHTNINGRIFLE;
	return TangibleObjectImplementation::gameObjectType == SceneObject::LIGHTNINGRIFLE;
}

bool WeaponObjectImplementation::isCarbineWeapon() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return super.gameObjectType == SceneObject.CARBINE;
	return TangibleObjectImplementation::gameObjectType == SceneObject::CARBINE;
}

bool WeaponObjectImplementation::isPistolWeapon() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return super.gameObjectType == SceneObject.PISTOL;
	return TangibleObjectImplementation::gameObjectType == SceneObject::PISTOL;
}

bool WeaponObjectImplementation::isOneHandMeleeWeapon() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return super.gameObjectType == SceneObject.ONEHANDMELEEWEAPON;
	return TangibleObjectImplementation::gameObjectType == SceneObject::ONEHANDMELEEWEAPON;
}

bool WeaponObjectImplementation::isPolearmWeaponObject() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return super.gameObjectType == SceneObject.POLEARM;
	return TangibleObjectImplementation::gameObjectType == SceneObject::POLEARM;
}

bool WeaponObjectImplementation::isTwoHandMeleeWeapon() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return super.gameObjectType == SceneObject.TWOHANDMELEEWEAPON;
	return TangibleObjectImplementation::gameObjectType == SceneObject::TWOHANDMELEEWEAPON;
}

bool WeaponObjectImplementation::isWeaponObject() {
	// server/zone/objects/tangible/weapon/WeaponObject.idl():  		return true;
	return true;
}

/*
 *	WeaponObjectAdapter
 */

WeaponObjectAdapter::WeaponObjectAdapter(WeaponObjectImplementation* obj) : TangibleObjectAdapter(obj) {
}

Packet* WeaponObjectAdapter::invokeMethod(uint32 methid, DistributedMethod* inv) {
	Packet* resp = new MethodReturnMessage(0);

	switch (methid) {
	case RPC_INITIALIZETRANSIENTMEMBERS__:
		initializeTransientMembers();
		break;
	case RPC_SENDBASELINESTO__SCENEOBJECT_:
		sendBaselinesTo((SceneObject*) inv->getObjectParameter());
		break;
	case RPC_HANDLEOBJECTMENUSELECT__PLAYERCREATURE_BYTE_:
		resp->insertSignedInt(handleObjectMenuSelect((PlayerCreature*) inv->getObjectParameter(), inv->getByteParameter()));
		break;
	case RPC_UPDATECRAFTINGVALUES__MANUFACTURESCHEMATIC_:
		updateCraftingValues((ManufactureSchematic*) inv->getObjectParameter());
		break;
	case RPC_ISCERTIFIEDFOR__PLAYERCREATURE_:
		resp->insertBoolean(isCertifiedFor((PlayerCreature*) inv->getObjectParameter()));
		break;
	case RPC_SETCERTIFIED__BOOL_:
		setCertified(inv->getBooleanParameter());
		break;
	case RPC_GETATTACKTYPE__:
		resp->insertSignedInt(getAttackType());
		break;
	case RPC_ISCERTIFIED__:
		resp->insertBoolean(isCertified());
		break;
	case RPC_GETPOINTBLANKACCURACY__:
		resp->insertSignedInt(getPointBlankAccuracy());
		break;
	case RPC_SETPOINTBLANKACCURACY__INT_:
		setPointBlankAccuracy(inv->getSignedIntParameter());
		break;
	case RPC_GETPOINTBLANKRANGE__:
		resp->insertSignedInt(getPointBlankRange());
		break;
	case RPC_GETIDEALRANGE__:
		resp->insertSignedInt(getIdealRange());
		break;
	case RPC_SETIDEALRANGE__INT_:
		setIdealRange(inv->getSignedIntParameter());
		break;
	case RPC_GETMAXRANGE__:
		resp->insertSignedInt(getMaxRange());
		break;
	case RPC_SETMAXRANGE__INT_:
		setMaxRange(inv->getSignedIntParameter());
		break;
	case RPC_GETIDEALACCURACY__:
		resp->insertSignedInt(getIdealAccuracy());
		break;
	case RPC_SETIDEALACCURACY__INT_:
		setIdealAccuracy(inv->getSignedIntParameter());
		break;
	case RPC_GETARMORPIERCING__:
		resp->insertSignedInt(getArmorPiercing());
		break;
	case RPC_GETMAXRANGEACCURACY__:
		resp->insertSignedInt(getMaxRangeAccuracy());
		break;
	case RPC_SETMAXRANGEACCURACY__INT_:
		setMaxRangeAccuracy(inv->getSignedIntParameter());
		break;
	case RPC_GETATTACKSPEED__:
		resp->insertFloat(getAttackSpeed());
		break;
	case RPC_SETATTACKSPEED__FLOAT_:
		setAttackSpeed(inv->getFloatParameter());
		break;
	case RPC_GETMAXDAMAGE__:
		resp->insertFloat(getMaxDamage());
		break;
	case RPC_SETMAXDAMAGE__FLOAT_:
		setMaxDamage(inv->getFloatParameter());
		break;
	case RPC_GETMINDAMAGE__:
		resp->insertFloat(getMinDamage());
		break;
	case RPC_SETMINDAMAGE__FLOAT_:
		setMinDamage(inv->getFloatParameter());
		break;
	case RPC_GETWOUNDSRATIO__:
		resp->insertFloat(getWoundsRatio());
		break;
	case RPC_SETWOUNDSRATIO__FLOAT_:
		setWoundsRatio(inv->getFloatParameter());
		break;
	case RPC_GETHEALTHATTACKCOST__:
		resp->insertSignedInt(getHealthAttackCost());
		break;
	case RPC_SETHEALTHATTACKCOST__INT_:
		setHealthAttackCost(inv->getSignedIntParameter());
		break;
	case RPC_GETACTIONATTACKCOST__:
		resp->insertSignedInt(getActionAttackCost());
		break;
	case RPC_SETACTIONATTACKCOST__INT_:
		setActionAttackCost(inv->getSignedIntParameter());
		break;
	case RPC_GETMINDATTACKCOST__:
		resp->insertSignedInt(getMindAttackCost());
		break;
	case RPC_SETMINDATTACKCOST__INT_:
		setMindAttackCost(inv->getSignedIntParameter());
		break;
	case RPC_GETFORCECOST__:
		resp->insertSignedInt(getForceCost());
		break;
	case RPC_GETDAMAGETYPE__:
		resp->insertSignedInt(getDamageType());
		break;
	case RPC_GETXPTYPE__:
		resp->insertAscii(getXpType());
		break;
	case RPC_ISUNARMEDWEAPON__:
		resp->insertBoolean(isUnarmedWeapon());
		break;
	case RPC_ISMELEEWEAPON__:
		resp->insertBoolean(isMeleeWeapon());
		break;
	case RPC_ISRANGEDWEAPON__:
		resp->insertBoolean(isRangedWeapon());
		break;
	case RPC_ISRIFLEWEAPON__:
		resp->insertBoolean(isRifleWeapon());
		break;
	case RPC_ISTHROWNWEAPON__:
		resp->insertBoolean(isThrownWeapon());
		break;
	case RPC_ISHEAVYWEAPON__:
		resp->insertBoolean(isHeavyWeapon());
		break;
	case RPC_ISSPECIALHEAVYWEAPON__:
		resp->insertBoolean(isSpecialHeavyWeapon());
		break;
	case RPC_ISLIGHTNINGRIFLE__:
		resp->insertBoolean(isLightningRifle());
		break;
	case RPC_ISCARBINEWEAPON__:
		resp->insertBoolean(isCarbineWeapon());
		break;
	case RPC_ISPISTOLWEAPON__:
		resp->insertBoolean(isPistolWeapon());
		break;
	case RPC_ISONEHANDMELEEWEAPON__:
		resp->insertBoolean(isOneHandMeleeWeapon());
		break;
	case RPC_ISPOLEARMWEAPONOBJECT__:
		resp->insertBoolean(isPolearmWeaponObject());
		break;
	case RPC_ISTWOHANDMELEEWEAPON__:
		resp->insertBoolean(isTwoHandMeleeWeapon());
		break;
	case RPC_ISWEAPONOBJECT__:
		resp->insertBoolean(isWeaponObject());
		break;
	default:
		return NULL;
	}

	return resp;
}

void WeaponObjectAdapter::initializeTransientMembers() {
	((WeaponObjectImplementation*) impl)->initializeTransientMembers();
}

void WeaponObjectAdapter::sendBaselinesTo(SceneObject* player) {
	((WeaponObjectImplementation*) impl)->sendBaselinesTo(player);
}

int WeaponObjectAdapter::handleObjectMenuSelect(PlayerCreature* player, byte selectedID) {
	return ((WeaponObjectImplementation*) impl)->handleObjectMenuSelect(player, selectedID);
}

void WeaponObjectAdapter::updateCraftingValues(ManufactureSchematic* schematic) {
	((WeaponObjectImplementation*) impl)->updateCraftingValues(schematic);
}

bool WeaponObjectAdapter::isCertifiedFor(PlayerCreature* object) {
	return ((WeaponObjectImplementation*) impl)->isCertifiedFor(object);
}

void WeaponObjectAdapter::setCertified(bool cert) {
	((WeaponObjectImplementation*) impl)->setCertified(cert);
}

int WeaponObjectAdapter::getAttackType() {
	return ((WeaponObjectImplementation*) impl)->getAttackType();
}

bool WeaponObjectAdapter::isCertified() {
	return ((WeaponObjectImplementation*) impl)->isCertified();
}

int WeaponObjectAdapter::getPointBlankAccuracy() {
	return ((WeaponObjectImplementation*) impl)->getPointBlankAccuracy();
}

void WeaponObjectAdapter::setPointBlankAccuracy(int value) {
	((WeaponObjectImplementation*) impl)->setPointBlankAccuracy(value);
}

int WeaponObjectAdapter::getPointBlankRange() {
	return ((WeaponObjectImplementation*) impl)->getPointBlankRange();
}

int WeaponObjectAdapter::getIdealRange() {
	return ((WeaponObjectImplementation*) impl)->getIdealRange();
}

void WeaponObjectAdapter::setIdealRange(int value) {
	((WeaponObjectImplementation*) impl)->setIdealRange(value);
}

int WeaponObjectAdapter::getMaxRange() {
	return ((WeaponObjectImplementation*) impl)->getMaxRange();
}

void WeaponObjectAdapter::setMaxRange(int value) {
	((WeaponObjectImplementation*) impl)->setMaxRange(value);
}

int WeaponObjectAdapter::getIdealAccuracy() {
	return ((WeaponObjectImplementation*) impl)->getIdealAccuracy();
}

void WeaponObjectAdapter::setIdealAccuracy(int value) {
	((WeaponObjectImplementation*) impl)->setIdealAccuracy(value);
}

int WeaponObjectAdapter::getArmorPiercing() {
	return ((WeaponObjectImplementation*) impl)->getArmorPiercing();
}

int WeaponObjectAdapter::getMaxRangeAccuracy() {
	return ((WeaponObjectImplementation*) impl)->getMaxRangeAccuracy();
}

void WeaponObjectAdapter::setMaxRangeAccuracy(int value) {
	((WeaponObjectImplementation*) impl)->setMaxRangeAccuracy(value);
}

float WeaponObjectAdapter::getAttackSpeed() {
	return ((WeaponObjectImplementation*) impl)->getAttackSpeed();
}

void WeaponObjectAdapter::setAttackSpeed(float value) {
	((WeaponObjectImplementation*) impl)->setAttackSpeed(value);
}

float WeaponObjectAdapter::getMaxDamage() {
	return ((WeaponObjectImplementation*) impl)->getMaxDamage();
}

void WeaponObjectAdapter::setMaxDamage(float value) {
	((WeaponObjectImplementation*) impl)->setMaxDamage(value);
}

float WeaponObjectAdapter::getMinDamage() {
	return ((WeaponObjectImplementation*) impl)->getMinDamage();
}

void WeaponObjectAdapter::setMinDamage(float value) {
	((WeaponObjectImplementation*) impl)->setMinDamage(value);
}

float WeaponObjectAdapter::getWoundsRatio() {
	return ((WeaponObjectImplementation*) impl)->getWoundsRatio();
}

void WeaponObjectAdapter::setWoundsRatio(float value) {
	((WeaponObjectImplementation*) impl)->setWoundsRatio(value);
}

int WeaponObjectAdapter::getHealthAttackCost() {
	return ((WeaponObjectImplementation*) impl)->getHealthAttackCost();
}

void WeaponObjectAdapter::setHealthAttackCost(int value) {
	((WeaponObjectImplementation*) impl)->setHealthAttackCost(value);
}

int WeaponObjectAdapter::getActionAttackCost() {
	return ((WeaponObjectImplementation*) impl)->getActionAttackCost();
}

void WeaponObjectAdapter::setActionAttackCost(int value) {
	((WeaponObjectImplementation*) impl)->setActionAttackCost(value);
}

int WeaponObjectAdapter::getMindAttackCost() {
	return ((WeaponObjectImplementation*) impl)->getMindAttackCost();
}

void WeaponObjectAdapter::setMindAttackCost(int value) {
	((WeaponObjectImplementation*) impl)->setMindAttackCost(value);
}

int WeaponObjectAdapter::getForceCost() {
	return ((WeaponObjectImplementation*) impl)->getForceCost();
}

int WeaponObjectAdapter::getDamageType() {
	return ((WeaponObjectImplementation*) impl)->getDamageType();
}

String WeaponObjectAdapter::getXpType() {
	return ((WeaponObjectImplementation*) impl)->getXpType();
}

bool WeaponObjectAdapter::isUnarmedWeapon() {
	return ((WeaponObjectImplementation*) impl)->isUnarmedWeapon();
}

bool WeaponObjectAdapter::isMeleeWeapon() {
	return ((WeaponObjectImplementation*) impl)->isMeleeWeapon();
}

bool WeaponObjectAdapter::isRangedWeapon() {
	return ((WeaponObjectImplementation*) impl)->isRangedWeapon();
}

bool WeaponObjectAdapter::isRifleWeapon() {
	return ((WeaponObjectImplementation*) impl)->isRifleWeapon();
}

bool WeaponObjectAdapter::isThrownWeapon() {
	return ((WeaponObjectImplementation*) impl)->isThrownWeapon();
}

bool WeaponObjectAdapter::isHeavyWeapon() {
	return ((WeaponObjectImplementation*) impl)->isHeavyWeapon();
}

bool WeaponObjectAdapter::isSpecialHeavyWeapon() {
	return ((WeaponObjectImplementation*) impl)->isSpecialHeavyWeapon();
}

bool WeaponObjectAdapter::isLightningRifle() {
	return ((WeaponObjectImplementation*) impl)->isLightningRifle();
}

bool WeaponObjectAdapter::isCarbineWeapon() {
	return ((WeaponObjectImplementation*) impl)->isCarbineWeapon();
}

bool WeaponObjectAdapter::isPistolWeapon() {
	return ((WeaponObjectImplementation*) impl)->isPistolWeapon();
}

bool WeaponObjectAdapter::isOneHandMeleeWeapon() {
	return ((WeaponObjectImplementation*) impl)->isOneHandMeleeWeapon();
}

bool WeaponObjectAdapter::isPolearmWeaponObject() {
	return ((WeaponObjectImplementation*) impl)->isPolearmWeaponObject();
}

bool WeaponObjectAdapter::isTwoHandMeleeWeapon() {
	return ((WeaponObjectImplementation*) impl)->isTwoHandMeleeWeapon();
}

bool WeaponObjectAdapter::isWeaponObject() {
	return ((WeaponObjectImplementation*) impl)->isWeaponObject();
}

/*
 *	WeaponObjectHelper
 */

WeaponObjectHelper* WeaponObjectHelper::staticInitializer = WeaponObjectHelper::instance();

WeaponObjectHelper::WeaponObjectHelper() {
	className = "WeaponObject";

	Core::getObjectBroker()->registerClass(className, this);
}

void WeaponObjectHelper::finalizeHelper() {
	WeaponObjectHelper::finalize();
}

DistributedObject* WeaponObjectHelper::instantiateObject() {
	return new WeaponObject(DummyConstructorParameter::instance());
}

DistributedObjectServant* WeaponObjectHelper::instantiateServant() {
	return new WeaponObjectImplementation(DummyConstructorParameter::instance());
}

DistributedObjectAdapter* WeaponObjectHelper::createAdapter(DistributedObjectStub* obj) {
	DistributedObjectAdapter* adapter = new WeaponObjectAdapter((WeaponObjectImplementation*) obj->_getImplementation());

	obj->_setClassName(className);
	obj->_setClassHelper(this);

	adapter->setStub(obj);

	return adapter;
}

