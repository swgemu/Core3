/*
 *	server/zone/managers/minigames/GamblingManager.cpp generated by engine3 IDL compiler 0.60
 */

#include "GamblingManager.h"

#include "server/zone/objects/player/PlayerCreature.h"

#include "server/zone/ZoneServer.h"

#include "server/zone/Zone.h"

#include "server/zone/objects/scene/SceneObject.h"

#include "server/zone/objects/tangible/terminal/gambling/GamblingTerminal.h"

#include "server/zone/managers/minigames/events/GamblingEvent.h"


// Imported class dependencies

#include "engine/core/ManagedObject.h"

#include "engine/core/ObjectUpdateToDatabaseTask.h"

#include "engine/core/Task.h"

#include "engine/service/DatagramServiceThread.h"

#include "engine/service/Message.h"

#include "engine/service/proto/BaseClientProxy.h"

#include "engine/service/proto/BasePacket.h"

#include "engine/service/proto/BasePacketHandler.h"

#include "engine/stm/TransactionalReference.h"

#include "engine/util/Facade.h"

#include "engine/util/Observable.h"

#include "engine/util/Observer.h"

#include "engine/util/u3d/Coordinate.h"

#include "engine/util/u3d/QuadTree.h"

#include "engine/util/u3d/QuadTreeEntry.h"

#include "engine/util/u3d/Quaternion.h"

#include "server/chat/ChatManager.h"

#include "server/chat/StringIdChatParameter.h"

#include "server/chat/room/ChatRoom.h"

#include "server/login/account/Account.h"

#include "server/login/account/AccountManager.h"

#include "server/zone/Zone.h"

#include "server/zone/ZoneClientSession.h"

#include "server/zone/ZoneHandler.h"

#include "server/zone/ZonePacketHandler.h"

#include "server/zone/ZoneProcessServer.h"

#include "server/zone/ZoneServer.h"

#include "server/zone/managers/auction/AuctionManager.h"

#include "server/zone/managers/city/CityManager.h"

#include "server/zone/managers/crafting/CraftingManager.h"

#include "server/zone/managers/creature/CreatureManager.h"

#include "server/zone/managers/creature/CreatureTemplateManager.h"

#include "server/zone/managers/guild/GuildManager.h"

#include "server/zone/managers/holocron/HolocronManager.h"

#include "server/zone/managers/loot/LootManager.h"

#include "server/zone/managers/minigames/FishingManager.h"

#include "server/zone/managers/minigames/ForageManager.h"

#include "server/zone/managers/minigames/GamblingBet.h"

#include "server/zone/managers/minigames/GamblingManager.h"

#include "server/zone/managers/minigames/events/GamblingEvent.h"

#include "server/zone/managers/mission/MissionManager.h"

#include "server/zone/managers/name/NameManager.h"

#include "server/zone/managers/object/ObjectManager.h"

#include "server/zone/managers/object/ObjectMap.h"

#include "server/zone/managers/objectcontroller/ObjectController.h"

#include "server/zone/managers/planet/HeightMap.h"

#include "server/zone/managers/planet/MapLocationTable.h"

#include "server/zone/managers/planet/PlanetManager.h"

#include "server/zone/managers/player/PlayerManager.h"

#include "server/zone/managers/professions/ProfessionManager.h"

#include "server/zone/managers/radial/RadialManager.h"

#include "server/zone/managers/resource/ResourceManager.h"

#include "server/zone/managers/stringid/StringIdManager.h"

#include "server/zone/managers/sui/SuiManager.h"

#include "server/zone/managers/vendor/VendorManager.h"

#include "server/zone/objects/area/ActiveArea.h"

#include "server/zone/objects/building/BuildingObject.h"

#include "server/zone/objects/cell/CellObject.h"

#include "server/zone/objects/creature/CreatureObject.h"

#include "server/zone/objects/player/PlayerCreature.h"

#include "server/zone/objects/player/TradeContainer.h"

#include "server/zone/objects/player/ValidatedPosition.h"

#include "server/zone/objects/player/badges/Badges.h"

#include "server/zone/objects/player/events/PlayerDisconnectEvent.h"

#include "server/zone/objects/player/events/PlayerRecoveryEvent.h"

#include "server/zone/objects/player/sui/SuiBox.h"

#include "server/zone/objects/scene/SceneObject.h"

#include "server/zone/objects/scene/variables/PendingTasksMap.h"

#include "server/zone/objects/scene/variables/StringId.h"

#include "server/zone/objects/tangible/TangibleObject.h"

#include "server/zone/objects/tangible/sign/SignObject.h"

#include "server/zone/objects/tangible/tool/CraftingTool.h"

#include "server/zone/objects/tangible/tool/SurveyTool.h"

#include "server/zone/packets/object/ObjectMenuResponse.h"

#include "server/zone/packets/scene/AttributeListMessage.h"

#include "server/zone/templates/SharedObjectTemplate.h"

#include "system/io/ObjectInputStream.h"

#include "system/io/ObjectOutputStream.h"

#include "system/lang/Exception.h"

#include "system/lang/Time.h"

#include "system/net/Packet.h"

#include "system/net/Socket.h"

#include "system/net/SocketAddress.h"

#include "system/thread/atomic/AtomicInteger.h"

#include "system/util/SortedVector.h"

#include "system/util/Vector.h"

#include "system/util/VectorMap.h"

/*
 *	GamblingManagerStub
 */

enum {RPC_INITIALIZESLOTTIMER__,RPC_INITIALIZEROULETTETIMER__,RPC_INITIALIZESLOTS__,RPC_INITIALIZEROULETTERED__,RPC_INITIALIZEROULETTE__,RPC_NOTIFY__SCENEOBJECT_,RPC_ISHIGH__INT_,RPC_ISLOW__INT_,RPC_ISEVEN__INT_,RPC_ISODD__INT_,RPC_ISBLACK__INT_,RPC_ISRED__INT_,RPC_HANDLESLOT__PLAYERCREATURE_BOOL_BOOL_,RPC_BET__PLAYERCREATURE_INT_INT_INT_,RPC_BET__GAMBLINGTERMINAL_PLAYERCREATURE_INT_INT_,RPC_STARTGAME__PLAYERCREATURE_INT_,RPC_STARTGAME__GAMBLINGTERMINAL_,RPC_LEAVETERMINAL__PLAYERCREATURE_INT_,RPC_REGISTERPLAYER__GAMBLINGTERMINAL_PLAYERCREATURE_,RPC_REFRESHROULETTEMENU__PLAYERCREATURE_,RPC_CONTINUEGAME__GAMBLINGTERMINAL_,RPC_STOPGAME__GAMBLINGTERMINAL_BOOL_,RPC_CALCULATEOUTCOME__GAMBLINGTERMINAL_,RPC_CREATEWINDOW__GAMBLINGTERMINAL_PLAYERCREATURE_,RPC_CREATEPAYOUTWINDOW__PLAYERCREATURE_,RPC_CREATESLOTWINDOW__PLAYERCREATURE_INT_,RPC_CREATEROULETTEWINDOW__PLAYERCREATURE_,RPC_CREATEEVENT__GAMBLINGTERMINAL_INT_,RPC_ISPLAYING__PLAYERCREATURE_};

GamblingManager::GamblingManager(ZoneServer* server) : Observer(DummyConstructorParameter::instance()) {
	GamblingManagerImplementation* _implementation = new GamblingManagerImplementation(server);
	_impl = _implementation;
	_impl->_setStub(this);
}

GamblingManager::GamblingManager(DummyConstructorParameter* param) : Observer(param) {
}

GamblingManager::~GamblingManager() {
}


Vector<String>* GamblingManager::getRoulette() {
	GamblingManagerImplementation* _implementation = (GamblingManagerImplementation*) _getImplementation();
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		return _implementation->getRoulette();
}

void GamblingManager::initializeSlotTimer() {
	GamblingManagerImplementation* _implementation = (GamblingManagerImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INITIALIZESLOTTIMER__);

		method.executeWithVoidReturn();
	} else
		_implementation->initializeSlotTimer();
}

void GamblingManager::initializeRouletteTimer() {
	GamblingManagerImplementation* _implementation = (GamblingManagerImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INITIALIZEROULETTETIMER__);

		method.executeWithVoidReturn();
	} else
		_implementation->initializeRouletteTimer();
}

void GamblingManager::initializeSlots() {
	GamblingManagerImplementation* _implementation = (GamblingManagerImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INITIALIZESLOTS__);

		method.executeWithVoidReturn();
	} else
		_implementation->initializeSlots();
}

void GamblingManager::initializeRouletteRed() {
	GamblingManagerImplementation* _implementation = (GamblingManagerImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INITIALIZEROULETTERED__);

		method.executeWithVoidReturn();
	} else
		_implementation->initializeRouletteRed();
}

void GamblingManager::initializeRoulette() {
	GamblingManagerImplementation* _implementation = (GamblingManagerImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INITIALIZEROULETTE__);

		method.executeWithVoidReturn();
	} else
		_implementation->initializeRoulette();
}

int GamblingManager::notify(SceneObject* sceneObject) {
	GamblingManagerImplementation* _implementation = (GamblingManagerImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFY__SCENEOBJECT_);
		method.addObjectParameter(sceneObject);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->notify(sceneObject);
}

bool GamblingManager::isHigh(int value) {
	GamblingManagerImplementation* _implementation = (GamblingManagerImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISHIGH__INT_);
		method.addSignedIntParameter(value);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isHigh(value);
}

bool GamblingManager::isLow(int value) {
	GamblingManagerImplementation* _implementation = (GamblingManagerImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISLOW__INT_);
		method.addSignedIntParameter(value);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isLow(value);
}

bool GamblingManager::isEven(int value) {
	GamblingManagerImplementation* _implementation = (GamblingManagerImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISEVEN__INT_);
		method.addSignedIntParameter(value);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isEven(value);
}

bool GamblingManager::isOdd(int value) {
	GamblingManagerImplementation* _implementation = (GamblingManagerImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISODD__INT_);
		method.addSignedIntParameter(value);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isOdd(value);
}

bool GamblingManager::isBlack(int value) {
	GamblingManagerImplementation* _implementation = (GamblingManagerImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISBLACK__INT_);
		method.addSignedIntParameter(value);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isBlack(value);
}

bool GamblingManager::isRed(int value) {
	GamblingManagerImplementation* _implementation = (GamblingManagerImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISRED__INT_);
		method.addSignedIntParameter(value);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isRed(value);
}

void GamblingManager::handleSlot(PlayerCreature* player, bool cancel, bool other) {
	GamblingManagerImplementation* _implementation = (GamblingManagerImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HANDLESLOT__PLAYERCREATURE_BOOL_BOOL_);
		method.addObjectParameter(player);
		method.addBooleanParameter(cancel);
		method.addBooleanParameter(other);

		method.executeWithVoidReturn();
	} else
		_implementation->handleSlot(player, cancel, other);
}

void GamblingManager::bet(PlayerCreature* player, int amount, int target, int machineType) {
	GamblingManagerImplementation* _implementation = (GamblingManagerImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_BET__PLAYERCREATURE_INT_INT_INT_);
		method.addObjectParameter(player);
		method.addSignedIntParameter(amount);
		method.addSignedIntParameter(target);
		method.addSignedIntParameter(machineType);

		method.executeWithVoidReturn();
	} else
		_implementation->bet(player, amount, target, machineType);
}

void GamblingManager::bet(GamblingTerminal* terminal, PlayerCreature* player, int amount, int target) {
	GamblingManagerImplementation* _implementation = (GamblingManagerImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_BET__GAMBLINGTERMINAL_PLAYERCREATURE_INT_INT_);
		method.addObjectParameter(terminal);
		method.addObjectParameter(player);
		method.addSignedIntParameter(amount);
		method.addSignedIntParameter(target);

		method.executeWithVoidReturn();
	} else
		_implementation->bet(terminal, player, amount, target);
}

void GamblingManager::startGame(PlayerCreature* player, int machineType) {
	GamblingManagerImplementation* _implementation = (GamblingManagerImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_STARTGAME__PLAYERCREATURE_INT_);
		method.addObjectParameter(player);
		method.addSignedIntParameter(machineType);

		method.executeWithVoidReturn();
	} else
		_implementation->startGame(player, machineType);
}

void GamblingManager::startGame(GamblingTerminal* terminal) {
	GamblingManagerImplementation* _implementation = (GamblingManagerImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_STARTGAME__GAMBLINGTERMINAL_);
		method.addObjectParameter(terminal);

		method.executeWithVoidReturn();
	} else
		_implementation->startGame(terminal);
}

void GamblingManager::leaveTerminal(PlayerCreature* player, int machineType) {
	GamblingManagerImplementation* _implementation = (GamblingManagerImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_LEAVETERMINAL__PLAYERCREATURE_INT_);
		method.addObjectParameter(player);
		method.addSignedIntParameter(machineType);

		method.executeWithVoidReturn();
	} else
		_implementation->leaveTerminal(player, machineType);
}

void GamblingManager::registerPlayer(GamblingTerminal* terminal, PlayerCreature* player) {
	GamblingManagerImplementation* _implementation = (GamblingManagerImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REGISTERPLAYER__GAMBLINGTERMINAL_PLAYERCREATURE_);
		method.addObjectParameter(terminal);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else
		_implementation->registerPlayer(terminal, player);
}

void GamblingManager::refreshRouletteMenu(PlayerCreature* player) {
	GamblingManagerImplementation* _implementation = (GamblingManagerImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REFRESHROULETTEMENU__PLAYERCREATURE_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else
		_implementation->refreshRouletteMenu(player);
}

void GamblingManager::continueGame(GamblingTerminal* terminal) {
	GamblingManagerImplementation* _implementation = (GamblingManagerImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CONTINUEGAME__GAMBLINGTERMINAL_);
		method.addObjectParameter(terminal);

		method.executeWithVoidReturn();
	} else
		_implementation->continueGame(terminal);
}

void GamblingManager::stopGame(GamblingTerminal* terminal, bool cancel) {
	GamblingManagerImplementation* _implementation = (GamblingManagerImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_STOPGAME__GAMBLINGTERMINAL_BOOL_);
		method.addObjectParameter(terminal);
		method.addBooleanParameter(cancel);

		method.executeWithVoidReturn();
	} else
		_implementation->stopGame(terminal, cancel);
}

void GamblingManager::calculateOutcome(GamblingTerminal* terminal) {
	GamblingManagerImplementation* _implementation = (GamblingManagerImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CALCULATEOUTCOME__GAMBLINGTERMINAL_);
		method.addObjectParameter(terminal);

		method.executeWithVoidReturn();
	} else
		_implementation->calculateOutcome(terminal);
}

unsigned int GamblingManager::createWindow(GamblingTerminal* terminal, PlayerCreature* player) {
	GamblingManagerImplementation* _implementation = (GamblingManagerImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CREATEWINDOW__GAMBLINGTERMINAL_PLAYERCREATURE_);
		method.addObjectParameter(terminal);
		method.addObjectParameter(player);

		return method.executeWithUnsignedIntReturn();
	} else
		return _implementation->createWindow(terminal, player);
}

unsigned int GamblingManager::createPayoutWindow(PlayerCreature* player) {
	GamblingManagerImplementation* _implementation = (GamblingManagerImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CREATEPAYOUTWINDOW__PLAYERCREATURE_);
		method.addObjectParameter(player);

		return method.executeWithUnsignedIntReturn();
	} else
		return _implementation->createPayoutWindow(player);
}

unsigned int GamblingManager::createSlotWindow(PlayerCreature* player, unsigned int payoutBoxID) {
	GamblingManagerImplementation* _implementation = (GamblingManagerImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CREATESLOTWINDOW__PLAYERCREATURE_INT_);
		method.addObjectParameter(player);
		method.addUnsignedIntParameter(payoutBoxID);

		return method.executeWithUnsignedIntReturn();
	} else
		return _implementation->createSlotWindow(player, payoutBoxID);
}

unsigned int GamblingManager::createRouletteWindow(PlayerCreature* player) {
	GamblingManagerImplementation* _implementation = (GamblingManagerImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CREATEROULETTEWINDOW__PLAYERCREATURE_);
		method.addObjectParameter(player);

		return method.executeWithUnsignedIntReturn();
	} else
		return _implementation->createRouletteWindow(player);
}

void GamblingManager::createEvent(GamblingTerminal* terminal, int time) {
	GamblingManagerImplementation* _implementation = (GamblingManagerImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CREATEEVENT__GAMBLINGTERMINAL_INT_);
		method.addObjectParameter(terminal);
		method.addSignedIntParameter(time);

		method.executeWithVoidReturn();
	} else
		_implementation->createEvent(terminal, time);
}

bool GamblingManager::isPlaying(PlayerCreature* player) {
	GamblingManagerImplementation* _implementation = (GamblingManagerImplementation*) _getImplementation();
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISPLAYING__PLAYERCREATURE_);
		method.addObjectParameter(player);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isPlaying(player);
}

DistributedObjectServant* GamblingManager::_getImplementation() {

	_updated = true;
	return _impl;
}

void GamblingManager::_setImplementation(DistributedObjectServant* servant) {
	_impl = servant;
}

/*
 *	GamblingManagerImplementation
 */

GamblingManagerImplementation::GamblingManagerImplementation(DummyConstructorParameter* param) : ObserverImplementation(param) {
	_initializeImplementation();
}


GamblingManagerImplementation::~GamblingManagerImplementation() {
}


void GamblingManagerImplementation::finalize() {
}

void GamblingManagerImplementation::_initializeImplementation() {
	_setClassHelper(GamblingManagerHelper::instance());

	_serializationHelperMethod();
	_serializationHelperMethod();
}

void GamblingManagerImplementation::_setStub(DistributedObjectStub* stub) {
	_this = (GamblingManager*) stub;
	ObserverImplementation::_setStub(stub);
}

DistributedObjectStub* GamblingManagerImplementation::_getStub() {
	return _this;
}

GamblingManagerImplementation::operator const GamblingManager*() {
	return _this;
}

void GamblingManagerImplementation::lock(bool doLock) {
	_this->lock(doLock);
}

void GamblingManagerImplementation::lock(ManagedObject* obj) {
	_this->lock(obj);
}

void GamblingManagerImplementation::rlock(bool doLock) {
	_this->rlock(doLock);
}

void GamblingManagerImplementation::wlock(bool doLock) {
	_this->wlock(doLock);
}

void GamblingManagerImplementation::wlock(ManagedObject* obj) {
	_this->wlock(obj);
}

void GamblingManagerImplementation::unlock(bool doLock) {
	_this->unlock(doLock);
}

void GamblingManagerImplementation::runlock(bool doLock) {
	_this->runlock(doLock);
}

void GamblingManagerImplementation::_serializationHelperMethod() {
	ObserverImplementation::_serializationHelperMethod();

	_setClassName("GamblingManager");

}

void GamblingManagerImplementation::readObject(ObjectInputStream* stream) {
	uint16 _varCount = stream->readShort();
	for (int i = 0; i < _varCount; ++i) {
		String _name;
		_name.parseFromBinaryStream(stream);

		uint16 _varSize = stream->readShort();

		int _currentOffset = stream->getOffset();

		if(GamblingManagerImplementation::readObjectMember(stream, _name)) {
		}

		stream->setOffset(_currentOffset + _varSize);
	}

	initializeTransientMembers();
}

bool GamblingManagerImplementation::readObjectMember(ObjectInputStream* stream, const String& _name) {
	if (ObserverImplementation::readObjectMember(stream, _name))
		return true;

	if (_name == "zoneServer") {
		TypeInfo<ManagedReference<ZoneServer* > >::parseFromBinaryStream(&zoneServer, stream);
		return true;
	}

	if (_name == "slotGames") {
		TypeInfo<VectorMap<ManagedReference<PlayerCreature* >, ManagedReference<GamblingTerminal* > > >::parseFromBinaryStream(&slotGames, stream);
		return true;
	}

	if (_name == "rouletteGames") {
		TypeInfo<VectorMap<ManagedReference<PlayerCreature* >, ManagedReference<GamblingTerminal* > > >::parseFromBinaryStream(&rouletteGames, stream);
		return true;
	}

	if (_name == "roulette") {
		TypeInfo<Vector<String> >::parseFromBinaryStream(&roulette, stream);
		return true;
	}

	if (_name == "red") {
		TypeInfo<Vector<String> >::parseFromBinaryStream(&red, stream);
		return true;
	}

	if (_name == "slot") {
		TypeInfo<Vector<int> >::parseFromBinaryStream(&slot, stream);
		return true;
	}

	if (_name == "slotTimer") {
		TypeInfo<Vector<int> >::parseFromBinaryStream(&slotTimer, stream);
		return true;
	}

	if (_name == "rouletteTimer") {
		TypeInfo<Vector<int> >::parseFromBinaryStream(&rouletteTimer, stream);
		return true;
	}


	return false;
}

void GamblingManagerImplementation::writeObject(ObjectOutputStream* stream) {
	int _currentOffset = stream->getOffset();
	stream->writeShort(0);
	int _varCount = GamblingManagerImplementation::writeObjectMembers(stream);
	stream->writeShort(_currentOffset, _varCount);
}

int GamblingManagerImplementation::writeObjectMembers(ObjectOutputStream* stream) {
	String _name;
	int _offset;
	uint16 _totalSize;
	_name = "zoneServer";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<ManagedReference<ZoneServer* > >::toBinaryStream(&zoneServer, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "slotGames";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<VectorMap<ManagedReference<PlayerCreature* >, ManagedReference<GamblingTerminal* > > >::toBinaryStream(&slotGames, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "rouletteGames";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<VectorMap<ManagedReference<PlayerCreature* >, ManagedReference<GamblingTerminal* > > >::toBinaryStream(&rouletteGames, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "roulette";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<Vector<String> >::toBinaryStream(&roulette, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "red";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<Vector<String> >::toBinaryStream(&red, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "slot";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<Vector<int> >::toBinaryStream(&slot, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "slotTimer";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<Vector<int> >::toBinaryStream(&slotTimer, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "rouletteTimer";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<Vector<int> >::toBinaryStream(&rouletteTimer, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);


	return 8 + ObserverImplementation::writeObjectMembers(stream);
}

GamblingManagerImplementation::GamblingManagerImplementation(ZoneServer* server) {
	_initializeImplementation();
	// server/zone/managers/minigames/GamblingManager.idl():  		zoneServer = server;
	zoneServer = server;
	// server/zone/managers/minigames/GamblingManager.idl():  		initializeRoulette();
	initializeRoulette();
	// server/zone/managers/minigames/GamblingManager.idl():  		initializeRouletteRed();
	initializeRouletteRed();
	// server/zone/managers/minigames/GamblingManager.idl():  		initializeSlots();
	initializeSlots();
	// server/zone/managers/minigames/GamblingManager.idl():  		initializeSlotTimer();
	initializeSlotTimer();
	// server/zone/managers/minigames/GamblingManager.idl():  		initializeRouletteTimer();
	initializeRouletteTimer();
	// server/zone/managers/minigames/GamblingManager.idl():  		Logger.setLoggingName("GamblingManager");
	Logger::setLoggingName("GamblingManager");
	// server/zone/managers/minigames/GamblingManager.idl():  		Logger.setLogging(true);
	Logger::setLogging(true);
}

Vector<String>* GamblingManagerImplementation::getRoulette() {
	// server/zone/managers/minigames/GamblingManager.idl():  		return roulette;
	return (&roulette);
}

void GamblingManagerImplementation::initializeSlotTimer() {
	// server/zone/managers/minigames/GamblingManager.idl():  		slotTimer.add(6);
	(&slotTimer)->add(6);
	// server/zone/managers/minigames/GamblingManager.idl():  		slotTimer.add(4);
	(&slotTimer)->add(4);
	// server/zone/managers/minigames/GamblingManager.idl():  		slotTimer.add(4);
	(&slotTimer)->add(4);
	// server/zone/managers/minigames/GamblingManager.idl():  		slotTimer.add(4);
	(&slotTimer)->add(4);
	// server/zone/managers/minigames/GamblingManager.idl():  		slotTimer.add(1);
	(&slotTimer)->add(1);
	// server/zone/managers/minigames/GamblingManager.idl():  		slotTimer.add(1);
	(&slotTimer)->add(1);
}

void GamblingManagerImplementation::initializeRouletteTimer() {
	// server/zone/managers/minigames/GamblingManager.idl():  		rouletteTimer.add(30);
	(&rouletteTimer)->add(30);
	// server/zone/managers/minigames/GamblingManager.idl():  		rouletteTimer.add(30);
	(&rouletteTimer)->add(30);
	// server/zone/managers/minigames/GamblingManager.idl():  		rouletteTimer.add(30);
	(&rouletteTimer)->add(30);
	// server/zone/managers/minigames/GamblingManager.idl():  		rouletteTimer.add(10);
	(&rouletteTimer)->add(10);
	// server/zone/managers/minigames/GamblingManager.idl():  		rouletteTimer.add(5);
	(&rouletteTimer)->add(5);
	// server/zone/managers/minigames/GamblingManager.idl():  		rouletteTimer.add(5);
	(&rouletteTimer)->add(5);
	// server/zone/managers/minigames/GamblingManager.idl():  		rouletteTimer.add(5);
	(&rouletteTimer)->add(5);
	// server/zone/managers/minigames/GamblingManager.idl():  		rouletteTimer.add(5);
	(&rouletteTimer)->add(5);
	// server/zone/managers/minigames/GamblingManager.idl():  		rouletteTimer.add(10);
	(&rouletteTimer)->add(10);
	// server/zone/managers/minigames/GamblingManager.idl():  		rouletteTimer.add(5);
	(&rouletteTimer)->add(5);
	// server/zone/managers/minigames/GamblingManager.idl():  		rouletteTimer.add(5);
	(&rouletteTimer)->add(5);
	// server/zone/managers/minigames/GamblingManager.idl():  		rouletteTimer.add(2);
	(&rouletteTimer)->add(2);
}

void GamblingManagerImplementation::initializeSlots() {
	// server/zone/managers/minigames/GamblingManager.idl():  		slot.add(4);
	(&slot)->add(4);
	// server/zone/managers/minigames/GamblingManager.idl():  		slot.add(50);
	(&slot)->add(50);
	// server/zone/managers/minigames/GamblingManager.idl():  		slot.add(75);
	(&slot)->add(75);
	// server/zone/managers/minigames/GamblingManager.idl():  		slot.add(100);
	(&slot)->add(100);
	// server/zone/managers/minigames/GamblingManager.idl():  		slot.add(250);
	(&slot)->add(250);
	// server/zone/managers/minigames/GamblingManager.idl():  		slot.add(500);
	(&slot)->add(500);
	// server/zone/managers/minigames/GamblingManager.idl():  		slot.add(1000);
	(&slot)->add(1000);
	// server/zone/managers/minigames/GamblingManager.idl():  		slot.add(1500);
	(&slot)->add(1500);
}

void GamblingManagerImplementation::initializeRouletteRed() {
	// server/zone/managers/minigames/GamblingManager.idl():  		red.add("1");
	(&red)->add("1");
	// server/zone/managers/minigames/GamblingManager.idl():  		red.add("3");
	(&red)->add("3");
	// server/zone/managers/minigames/GamblingManager.idl():  		red.add("5");
	(&red)->add("5");
	// server/zone/managers/minigames/GamblingManager.idl():  		red.add("7");
	(&red)->add("7");
	// server/zone/managers/minigames/GamblingManager.idl():  		red.add("9");
	(&red)->add("9");
	// server/zone/managers/minigames/GamblingManager.idl():  		red.add("12");
	(&red)->add("12");
	// server/zone/managers/minigames/GamblingManager.idl():  		red.add("14");
	(&red)->add("14");
	// server/zone/managers/minigames/GamblingManager.idl():  		red.add("16");
	(&red)->add("16");
	// server/zone/managers/minigames/GamblingManager.idl():  		red.add("18");
	(&red)->add("18");
	// server/zone/managers/minigames/GamblingManager.idl():  		red.add("19");
	(&red)->add("19");
	// server/zone/managers/minigames/GamblingManager.idl():  		red.add("21");
	(&red)->add("21");
	// server/zone/managers/minigames/GamblingManager.idl():  		red.add("23");
	(&red)->add("23");
	// server/zone/managers/minigames/GamblingManager.idl():  		red.add("25");
	(&red)->add("25");
	// server/zone/managers/minigames/GamblingManager.idl():  		red.add("27");
	(&red)->add("27");
	// server/zone/managers/minigames/GamblingManager.idl():  		red.add("30");
	(&red)->add("30");
	// server/zone/managers/minigames/GamblingManager.idl():  		red.add("32");
	(&red)->add("32");
	// server/zone/managers/minigames/GamblingManager.idl():  		red.add("34");
	(&red)->add("34");
	// server/zone/managers/minigames/GamblingManager.idl():  		red.add("36");
	(&red)->add("36");
}

void GamblingManagerImplementation::initializeRoulette() {
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("0");
	(&roulette)->add("0");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("1");
	(&roulette)->add("1");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("2");
	(&roulette)->add("2");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("3");
	(&roulette)->add("3");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("4");
	(&roulette)->add("4");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("5");
	(&roulette)->add("5");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("6");
	(&roulette)->add("6");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("7");
	(&roulette)->add("7");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("8");
	(&roulette)->add("8");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("9");
	(&roulette)->add("9");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("10");
	(&roulette)->add("10");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("11");
	(&roulette)->add("11");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("12");
	(&roulette)->add("12");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("13");
	(&roulette)->add("13");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("14");
	(&roulette)->add("14");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("15");
	(&roulette)->add("15");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("16");
	(&roulette)->add("16");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("17");
	(&roulette)->add("17");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("18");
	(&roulette)->add("18");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("19");
	(&roulette)->add("19");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("20");
	(&roulette)->add("20");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("21");
	(&roulette)->add("21");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("22");
	(&roulette)->add("22");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("23");
	(&roulette)->add("23");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("24");
	(&roulette)->add("24");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("25");
	(&roulette)->add("25");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("26");
	(&roulette)->add("26");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("27");
	(&roulette)->add("27");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("28");
	(&roulette)->add("28");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("29");
	(&roulette)->add("29");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("30");
	(&roulette)->add("30");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("31");
	(&roulette)->add("31");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("32");
	(&roulette)->add("32");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("33");
	(&roulette)->add("33");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("34");
	(&roulette)->add("34");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("35");
	(&roulette)->add("35");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("36");
	(&roulette)->add("36");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("00");
	(&roulette)->add("00");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("odd");
	(&roulette)->add("odd");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("even");
	(&roulette)->add("even");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("high");
	(&roulette)->add("high");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("low");
	(&roulette)->add("low");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("red");
	(&roulette)->add("red");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("black");
	(&roulette)->add("black");
}

int GamblingManagerImplementation::notify(SceneObject* sceneObject) {
	// server/zone/managers/minigames/GamblingManager.idl():  		return 
	if (sceneObject->isPlayerCreature())	// server/zone/managers/minigames/GamblingManager.idl():  			return 1;
	return 1;
	// server/zone/managers/minigames/GamblingManager.idl():  		return 0;
	return 0;
}

bool GamblingManagerImplementation::isHigh(int value) {
	// server/zone/managers/minigames/GamblingManager.idl():  		return 
	if ((value > 18) && (value != 37))	// server/zone/managers/minigames/GamblingManager.idl():  			return true;
	return true;
	// server/zone/managers/minigames/GamblingManager.idl():  		return false;
	return false;
}

bool GamblingManagerImplementation::isLow(int value) {
	// server/zone/managers/minigames/GamblingManager.idl():  		return 
	if ((value > 0) && (value < 19))	// server/zone/managers/minigames/GamblingManager.idl():  			return true;
	return true;
	// server/zone/managers/minigames/GamblingManager.idl():  		return false;
	return false;
}

bool GamblingManagerImplementation::isEven(int value) {
	// server/zone/managers/minigames/GamblingManager.idl():  		if 
	if ((value == 0) || (value == 37))	// server/zone/managers/minigames/GamblingManager.idl():  			return false;
	return false;
	// server/zone/managers/minigames/GamblingManager.idl():  		return 
	if ((value % 2) == 0)	// server/zone/managers/minigames/GamblingManager.idl():  			return true;
	return true;
	// server/zone/managers/minigames/GamblingManager.idl():  		return false;
	return false;
}

bool GamblingManagerImplementation::isOdd(int value) {
	// server/zone/managers/minigames/GamblingManager.idl():  		if 
	if ((value == 0) || (value == 37))	// server/zone/managers/minigames/GamblingManager.idl():  			return false;
	return false;
	// server/zone/managers/minigames/GamblingManager.idl():  		return 
	if ((value % 2) == 1)	// server/zone/managers/minigames/GamblingManager.idl():  			return true;
	return true;
	// server/zone/managers/minigames/GamblingManager.idl():  		return false;
	return false;
}

bool GamblingManagerImplementation::isBlack(int value) {
	// server/zone/managers/minigames/GamblingManager.idl():  		if 
	if ((&roulette)->get(value) == "0" || (&roulette)->get(value) == "00")	// server/zone/managers/minigames/GamblingManager.idl():  			return false;
	return false;
	// server/zone/managers/minigames/GamblingManager.idl():  		return 
	if (isRed(value))	// server/zone/managers/minigames/GamblingManager.idl():  			return false;
	return false;
	// server/zone/managers/minigames/GamblingManager.idl():  		return true;
	return true;
}

bool GamblingManagerImplementation::isRed(int value) {
	// server/zone/managers/minigames/GamblingManager.idl():  		for 
	if ((&roulette)->get(value) == "0" || (&roulette)->get(value) == "00")	// server/zone/managers/minigames/GamblingManager.idl():  			return false;
	return false;
	// server/zone/managers/minigames/GamblingManager.idl():  		}
	for (	// server/zone/managers/minigames/GamblingManager.idl():  		for (int i = 0;
	int i = 0;
	i < (&red)->size();
 ++i) {
	// server/zone/managers/minigames/GamblingManager.idl():  		}
	if ((&red)->get(i) == (&roulette)->get(value)){
	// server/zone/managers/minigames/GamblingManager.idl():  				return true;
	return true;
}
}
	// server/zone/managers/minigames/GamblingManager.idl():  		return false;
	return false;
}

bool GamblingManagerImplementation::isPlaying(PlayerCreature* player) {
	// server/zone/managers/minigames/GamblingManager.idl():  		return (slotGames.contains(player) || rouletteGames.contains(player));
	return ((&slotGames)->contains(player) || (&rouletteGames)->contains(player));
}

/*
 *	GamblingManagerAdapter
 */

GamblingManagerAdapter::GamblingManagerAdapter(GamblingManagerImplementation* obj) : ObserverAdapter(obj) {
}

Packet* GamblingManagerAdapter::invokeMethod(uint32 methid, DistributedMethod* inv) {
	Packet* resp = new MethodReturnMessage(0);

	switch (methid) {
	case RPC_INITIALIZESLOTTIMER__:
		initializeSlotTimer();
		break;
	case RPC_INITIALIZEROULETTETIMER__:
		initializeRouletteTimer();
		break;
	case RPC_INITIALIZESLOTS__:
		initializeSlots();
		break;
	case RPC_INITIALIZEROULETTERED__:
		initializeRouletteRed();
		break;
	case RPC_INITIALIZEROULETTE__:
		initializeRoulette();
		break;
	case RPC_NOTIFY__SCENEOBJECT_:
		resp->insertSignedInt(notify((SceneObject*) inv->getObjectParameter()));
		break;
	case RPC_ISHIGH__INT_:
		resp->insertBoolean(isHigh(inv->getSignedIntParameter()));
		break;
	case RPC_ISLOW__INT_:
		resp->insertBoolean(isLow(inv->getSignedIntParameter()));
		break;
	case RPC_ISEVEN__INT_:
		resp->insertBoolean(isEven(inv->getSignedIntParameter()));
		break;
	case RPC_ISODD__INT_:
		resp->insertBoolean(isOdd(inv->getSignedIntParameter()));
		break;
	case RPC_ISBLACK__INT_:
		resp->insertBoolean(isBlack(inv->getSignedIntParameter()));
		break;
	case RPC_ISRED__INT_:
		resp->insertBoolean(isRed(inv->getSignedIntParameter()));
		break;
	case RPC_HANDLESLOT__PLAYERCREATURE_BOOL_BOOL_:
		handleSlot((PlayerCreature*) inv->getObjectParameter(), inv->getBooleanParameter(), inv->getBooleanParameter());
		break;
	case RPC_BET__PLAYERCREATURE_INT_INT_INT_:
		bet((PlayerCreature*) inv->getObjectParameter(), inv->getSignedIntParameter(), inv->getSignedIntParameter(), inv->getSignedIntParameter());
		break;
	case RPC_BET__GAMBLINGTERMINAL_PLAYERCREATURE_INT_INT_:
		bet((GamblingTerminal*) inv->getObjectParameter(), (PlayerCreature*) inv->getObjectParameter(), inv->getSignedIntParameter(), inv->getSignedIntParameter());
		break;
	case RPC_STARTGAME__PLAYERCREATURE_INT_:
		startGame((PlayerCreature*) inv->getObjectParameter(), inv->getSignedIntParameter());
		break;
	case RPC_STARTGAME__GAMBLINGTERMINAL_:
		startGame((GamblingTerminal*) inv->getObjectParameter());
		break;
	case RPC_LEAVETERMINAL__PLAYERCREATURE_INT_:
		leaveTerminal((PlayerCreature*) inv->getObjectParameter(), inv->getSignedIntParameter());
		break;
	case RPC_REGISTERPLAYER__GAMBLINGTERMINAL_PLAYERCREATURE_:
		registerPlayer((GamblingTerminal*) inv->getObjectParameter(), (PlayerCreature*) inv->getObjectParameter());
		break;
	case RPC_REFRESHROULETTEMENU__PLAYERCREATURE_:
		refreshRouletteMenu((PlayerCreature*) inv->getObjectParameter());
		break;
	case RPC_CONTINUEGAME__GAMBLINGTERMINAL_:
		continueGame((GamblingTerminal*) inv->getObjectParameter());
		break;
	case RPC_STOPGAME__GAMBLINGTERMINAL_BOOL_:
		stopGame((GamblingTerminal*) inv->getObjectParameter(), inv->getBooleanParameter());
		break;
	case RPC_CALCULATEOUTCOME__GAMBLINGTERMINAL_:
		calculateOutcome((GamblingTerminal*) inv->getObjectParameter());
		break;
	case RPC_CREATEWINDOW__GAMBLINGTERMINAL_PLAYERCREATURE_:
		resp->insertInt(createWindow((GamblingTerminal*) inv->getObjectParameter(), (PlayerCreature*) inv->getObjectParameter()));
		break;
	case RPC_CREATEPAYOUTWINDOW__PLAYERCREATURE_:
		resp->insertInt(createPayoutWindow((PlayerCreature*) inv->getObjectParameter()));
		break;
	case RPC_CREATESLOTWINDOW__PLAYERCREATURE_INT_:
		resp->insertInt(createSlotWindow((PlayerCreature*) inv->getObjectParameter(), inv->getUnsignedIntParameter()));
		break;
	case RPC_CREATEROULETTEWINDOW__PLAYERCREATURE_:
		resp->insertInt(createRouletteWindow((PlayerCreature*) inv->getObjectParameter()));
		break;
	case RPC_CREATEEVENT__GAMBLINGTERMINAL_INT_:
		createEvent((GamblingTerminal*) inv->getObjectParameter(), inv->getSignedIntParameter());
		break;
	case RPC_ISPLAYING__PLAYERCREATURE_:
		resp->insertBoolean(isPlaying((PlayerCreature*) inv->getObjectParameter()));
		break;
	default:
		return NULL;
	}

	return resp;
}

void GamblingManagerAdapter::initializeSlotTimer() {
	((GamblingManagerImplementation*) impl)->initializeSlotTimer();
}

void GamblingManagerAdapter::initializeRouletteTimer() {
	((GamblingManagerImplementation*) impl)->initializeRouletteTimer();
}

void GamblingManagerAdapter::initializeSlots() {
	((GamblingManagerImplementation*) impl)->initializeSlots();
}

void GamblingManagerAdapter::initializeRouletteRed() {
	((GamblingManagerImplementation*) impl)->initializeRouletteRed();
}

void GamblingManagerAdapter::initializeRoulette() {
	((GamblingManagerImplementation*) impl)->initializeRoulette();
}

int GamblingManagerAdapter::notify(SceneObject* sceneObject) {
	return ((GamblingManagerImplementation*) impl)->notify(sceneObject);
}

bool GamblingManagerAdapter::isHigh(int value) {
	return ((GamblingManagerImplementation*) impl)->isHigh(value);
}

bool GamblingManagerAdapter::isLow(int value) {
	return ((GamblingManagerImplementation*) impl)->isLow(value);
}

bool GamblingManagerAdapter::isEven(int value) {
	return ((GamblingManagerImplementation*) impl)->isEven(value);
}

bool GamblingManagerAdapter::isOdd(int value) {
	return ((GamblingManagerImplementation*) impl)->isOdd(value);
}

bool GamblingManagerAdapter::isBlack(int value) {
	return ((GamblingManagerImplementation*) impl)->isBlack(value);
}

bool GamblingManagerAdapter::isRed(int value) {
	return ((GamblingManagerImplementation*) impl)->isRed(value);
}

void GamblingManagerAdapter::handleSlot(PlayerCreature* player, bool cancel, bool other) {
	((GamblingManagerImplementation*) impl)->handleSlot(player, cancel, other);
}

void GamblingManagerAdapter::bet(PlayerCreature* player, int amount, int target, int machineType) {
	((GamblingManagerImplementation*) impl)->bet(player, amount, target, machineType);
}

void GamblingManagerAdapter::bet(GamblingTerminal* terminal, PlayerCreature* player, int amount, int target) {
	((GamblingManagerImplementation*) impl)->bet(terminal, player, amount, target);
}

void GamblingManagerAdapter::startGame(PlayerCreature* player, int machineType) {
	((GamblingManagerImplementation*) impl)->startGame(player, machineType);
}

void GamblingManagerAdapter::startGame(GamblingTerminal* terminal) {
	((GamblingManagerImplementation*) impl)->startGame(terminal);
}

void GamblingManagerAdapter::leaveTerminal(PlayerCreature* player, int machineType) {
	((GamblingManagerImplementation*) impl)->leaveTerminal(player, machineType);
}

void GamblingManagerAdapter::registerPlayer(GamblingTerminal* terminal, PlayerCreature* player) {
	((GamblingManagerImplementation*) impl)->registerPlayer(terminal, player);
}

void GamblingManagerAdapter::refreshRouletteMenu(PlayerCreature* player) {
	((GamblingManagerImplementation*) impl)->refreshRouletteMenu(player);
}

void GamblingManagerAdapter::continueGame(GamblingTerminal* terminal) {
	((GamblingManagerImplementation*) impl)->continueGame(terminal);
}

void GamblingManagerAdapter::stopGame(GamblingTerminal* terminal, bool cancel) {
	((GamblingManagerImplementation*) impl)->stopGame(terminal, cancel);
}

void GamblingManagerAdapter::calculateOutcome(GamblingTerminal* terminal) {
	((GamblingManagerImplementation*) impl)->calculateOutcome(terminal);
}

unsigned int GamblingManagerAdapter::createWindow(GamblingTerminal* terminal, PlayerCreature* player) {
	return ((GamblingManagerImplementation*) impl)->createWindow(terminal, player);
}

unsigned int GamblingManagerAdapter::createPayoutWindow(PlayerCreature* player) {
	return ((GamblingManagerImplementation*) impl)->createPayoutWindow(player);
}

unsigned int GamblingManagerAdapter::createSlotWindow(PlayerCreature* player, unsigned int payoutBoxID) {
	return ((GamblingManagerImplementation*) impl)->createSlotWindow(player, payoutBoxID);
}

unsigned int GamblingManagerAdapter::createRouletteWindow(PlayerCreature* player) {
	return ((GamblingManagerImplementation*) impl)->createRouletteWindow(player);
}

void GamblingManagerAdapter::createEvent(GamblingTerminal* terminal, int time) {
	((GamblingManagerImplementation*) impl)->createEvent(terminal, time);
}

bool GamblingManagerAdapter::isPlaying(PlayerCreature* player) {
	return ((GamblingManagerImplementation*) impl)->isPlaying(player);
}

/*
 *	GamblingManagerHelper
 */

GamblingManagerHelper* GamblingManagerHelper::staticInitializer = GamblingManagerHelper::instance();

GamblingManagerHelper::GamblingManagerHelper() {
	className = "GamblingManager";

	Core::getObjectBroker()->registerClass(className, this);
}

void GamblingManagerHelper::finalizeHelper() {
	GamblingManagerHelper::finalize();
}

DistributedObject* GamblingManagerHelper::instantiateObject() {
	return new GamblingManager(DummyConstructorParameter::instance());
}

DistributedObjectServant* GamblingManagerHelper::instantiateServant() {
	return new GamblingManagerImplementation(DummyConstructorParameter::instance());
}

DistributedObjectAdapter* GamblingManagerHelper::createAdapter(DistributedObjectStub* obj) {
	DistributedObjectAdapter* adapter = new GamblingManagerAdapter((GamblingManagerImplementation*) obj->_getImplementation());

	obj->_setClassName(className);
	obj->_setClassHelper(this);

	adapter->setStub(obj);

	return adapter;
}

