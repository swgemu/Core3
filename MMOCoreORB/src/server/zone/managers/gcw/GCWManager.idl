package server.zone.managers.gcw;

import engine.core.ManagedService;
import engine.core.Task;
import server.zone.Zone;
import engine.log.Logger;


import engine.core.ManagedObject;
import system.util.SortedVector;

import server.zone.objects.tangible.TangibleObject;
import server.zone.objects.structure.StructureObject;
import server.zone.objects.building.BuildingObject;
import server.zone.objects.installation.InstallationObject;
import server.zone.objects.creature.CreatureObject;
import server.zone.objects.player.PlayerObject;
import system.thread.Mutex;
import server.zone.objects.tangible.deed.structure.StructureDeed;

include server.zone.objects.building.components.DestructibleBuildingDataComponent;

class GCWManager extends ManagedService implements Logger {

	public final static int GCWCHECKTIMER = 7200; // 2 hours
	public final static int VULNERABILITYDURATION = 7200; //  2 hours
	public final static int VULNERABILITYFREQUENCY = 172800; // every 2 days
	public final static int RESETTIMER = 120; // amount of time before waiting to reset vulnerability	
	public final static int SLICECOOLDOWN = 30; // test for 30 seconds after a failed slice
	public final static int TOTALDNASAMPLES = 10;
	public final static int DNAMATCHESREQUIRED = 10;
	public final static int DESTRUCTIONTIMER = 300; // 3 minute 
	public final static int MAXBASES = 25;  // MAX BASES PER PLANET
	public final static int OVERTCOOLDOWN = 60;  // time in seconds that a player must be overt before aborting a facility shutdown
	public final static int REACTIVATIONTIMER = 60; // time in seconds to wait before reactivating the overload after the other 
							//  faction stopped the destruction

	public final static int IMPERIALHASH = 3679112276;
	public final static int REBELHASH = 370444368;
	
	private Zone zone;
	
	@dereferenced 
	protected transient SortedVector<BuildingObject > gcwBaseList;
	
	@dereferenced
	protected transient VectorMap<unsigned long, Reference<Task> > gcwStartTasks;
	
	@dereferenced
	protected transient VectorMap<unsigned long, Reference<Task> > gcwEndTasks;
	
	@dereferenced
	protected transient VectorMap<string, string> dnaHash;
	
	@dereferenced
	protected transient VectorMap<unsigned long, Reference<Task> > gcwDestroyTasks;
	
	@dereferenced
	protected transient Mutex baseMutex;

	private int rebelBases;

	private int imperialBases;

	public GCWManager(Zone zne){
		imperialBases = 0;
		rebelBases = 0;
		Logger.setLoggingName("GCWManager");
		Logger.info("GCWManager instantiated for " + zne.getZoneName(),true);
		gcwBaseList.setNoDuplicateInsertPlan();
		zone = zne;

		gcwStartTasks.setNoDuplicateInsertPlan();
		gcwStartTasks.setNullValue(null);

		gcwEndTasks.setNoDuplicateInsertPlan();
		gcwEndTasks.setNullValue(null);

		gcwDestroyTasks.setNoDuplicateInsertPlan();
		gcwDestroyTasks.setNullValue(null);
	}
	
	public native void initialize();
	
	public native void start();
	
	public native void loadFactionStructures(final string zoneName);
	
	//public native void initializeGCWBase(BuildingObject building);

	public native void registerGCWBase(BuildingObject building, boolean initializeBase);
	
	public native void unregisterGCWBase(BuildingObject building);
	
	public native void performGCWTasks();

	public native void startVulnerability(BuildingObject building);

	public native void endVulnerability(BuildingObject building);
	
	public native boolean isBaseVulnerable(BuildingObject building);
	
	public native boolean isBandIdentified(BuildingObject building);
	
	public native boolean isUplinkJammed(BuildingObject building);
	
	public native boolean isShutdownSequenceStarted(BuildingObject building);
	
	public native boolean isSecurityTermSliced(BuildingObject building);

	public native boolean isPowerOverloaded(BuildingObject building);
	
	// called to reschedule the vulnerability time of a base
	public native void resetVulnerability(CreatureObject creature, BuildingObject building);

	public  native void sendBaseDefenseStatus(CreatureObject creature, BuildingObject building);
	
	public native void doBaseDestruction(StructureObject structure);

	public native void doBaseDestruction(BuildingObject building);
	
	public native void sendResetVerification(CreatureObject creature, BuildingObject building);
	
	public native void sendJamUplinkMenu(CreatureObject creature, BuildingObject building);
	
	public native void verifyUplinkBand(CreatureObject creature, BuildingObject building, int band);
	
	public native boolean canStartSlice(CreatureObject creature, TangibleObject terminal);
	
	public native void sendDNASampleMenu(CreatureObject creature, BuildingObject building);
		
	public native void completeSecuritySlice(CreatureObject creature, TangibleObject securityTerminal);
	
	public native void failSecuritySlice(TangibleObject securityTerminal);
	
	public native boolean isTerminalDamaged(TangibleObject securityTerminal);
	
	public native boolean isDNASampled(BuildingObject building);
	
	public native void repairTerminal(CreatureObject creature, TangibleObject securityTerminal);
	
	public native void abortShutdownSequence(CreatureObject creature, BuildingObject building);
	
	public native void processDNASample(CreatureObject creature, BuildingObject building, int indx);
	
	//public native void processDNASample(CreatureObject creature, BuildingObject building, final string dnaString, int indx);
	
	public native void handlePowerRegulatorSwitch(CreatureObject creature, BuildingObject building, int indx);
	
	public native void sendPowerRegulatorControls(CreatureObject creature, BuildingObject building);
	
	public synchronized string getDNAHash(final string usersample){
		return dnaHash.get(usersample); 
	}
	
	protected synchronized void addDNAHash(final string usersample, final string systemsample){
		dnaHash.put(usersample, systemsample);
	}
	
	protected synchronized boolean hasBase(BuildingObject building){
		return gcwBaseList.contains(building);
	}
	
	protected synchronized boolean dropBase(BuildingObject building){
		return gcwBaseList.drop(building);
	}
	
	protected synchronized void addBase(BuildingObject building){
		gcwBaseList.put(building);
	}
	
	protected synchronized BuildingObject getBase(int indx){
		return gcwBaseList.get(indx);
	}
	protected synchronized boolean hasStartTask(unsigned long id){
		return gcwStartTasks.contains(id);
	}
	
	@local
	protected synchronized boolean addStartTask(unsigned long id, Reference<Task> newTask){
		if(!gcwStartTasks.contains(id)){
			return gcwStartTasks.put(id, newTask);
		}
	return false;
	}
	
	@local
	protected synchronized Reference<Task> getStartTask(unsigned long id){
		return gcwStartTasks.get(id);
	}
	
	protected synchronized boolean dropStartTask(unsigned long id){
		return gcwStartTasks.drop(id);
	}
	
	protected synchronized boolean hasEndTask(unsigned long id){
		return gcwEndTasks.contains(id);
	}
	
	@local
	protected synchronized boolean addEndTask(unsigned long id, Reference<Task> newTask){
		if(!gcwEndTasks.contains(id)){
			return	gcwEndTasks.put(id, newTask);
		}
		return false;
	}
	
	@local
	protected synchronized Reference<Task> getEndTask(unsigned long id){
		return gcwEndTasks.get(id);
	}
	
	protected synchronized boolean dropEndTask(unsigned long id){
		return gcwEndTasks.drop(id);
	}
	
	protected synchronized boolean hasDestroyTask(unsigned long id){
		return gcwDestroyTasks.contains(id);
	}
	
	@local
	protected synchronized boolean addDestroyTask(unsigned long id, Reference<Task> newTask){
		if(!gcwDestroyTasks.contains(id)){
			return	gcwDestroyTasks.put(id, newTask);
		}
		return false;
	}
	
	@local
	protected synchronized Reference<Task> getDestroyTask(unsigned long id){
		return gcwDestroyTasks.get(id);
	}
		
	protected synchronized boolean dropDestroyTask(unsigned long id){
		return gcwDestroyTasks.drop(id);
	}

	public synchronized boolean isPlanetCapped(){
		return MAXBASES <= gcwBaseList.size();
	}

	private native DestructibleBuildingDataComponent getDestructibleBuildingData(BuildingObject building);
	
	private native void checkVulnerabilityData(BuildingObject building);

	private native void scheduleVulnerabilityStart(BuildingObject building);

	private native void scheduleVulnerabilityEnd(BuildingObject building);

	public native void scheduleBaseDestruction(BuildingObject building, CreatureObject creature);
	
	private native void initializeBaseTimers(BuildingObject building);
	
	private native void renewUplinkBand(BuildingObject building);
	
	private native void refreshExpiredVulnerability(BuildingObject building);
	
	private native void initializeNewVulnerability(DestructibleBuildingDataComponent data);
	
	private native void refreshDNA(DestructibleBuildingDataComponent data);

	public native void spawnChildrenCreatures(BuildingObject building);

	public native void notifyTurretDestruction(InstallationObject turret);

	private native void destroyStandaloneTurret(InstallationObject turret);

	public native void sendSelectTurretToDonate(BuildingObject building, CreatureObject creature);

	public native void sendSelectDeedToDonate(BuildingObject building, CreatureObject creature,int turretIndex);

	public native void sendRemoveDefenseConfirmation(BuildingObject building, CreatureObject creature, unsigned long deedOID);

	public native void performDefenseDontation(BuildingObject building, CreatureObject creature, unsigned long deedOID, int turretIndex);

	private native void performDonateMine(BuildingObject building, CreatureObject creature, SceneObject sceneObject);

	private native void performDonateMinefield(BuildingObject building, CreatureObject creature, StructureDeed deed);

	private native void performDonateTurret(BuildingObject building, CreatureObject creature, StructureDeed deed);

	public native void sendStatus(BuildingObject building, CreatureObject creature);

	public native void addMinefield(BuildingObject building, SceneObject minefield);

	public native void addTurret(BuildingObject building, SceneObject turret);

	public native void addScanner(BuildingObject building, SceneObject scanner);

	public native void removeDefense(BuildingObject building, CreatureObject creature, unsigned long deedOID);

	private native void verifyTurrets(BuildingObject building);

	public int getImperialBaseCount(){
		return imperialBases;
	}

	public int getRebelBaseCount(){
		return rebelBases;
	}

	@local 
	private void setRebelBaseCount(int val){
		rebelBases = val;
	}

	@local
	private void setImperialBaseCount(int val){
		imperialBases = val;
	}
}

