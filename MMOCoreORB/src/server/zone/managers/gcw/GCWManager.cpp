/*
 *	server/zone/managers/gcw/GCWManager.cpp generated by engine3 IDL compiler 0.60
 */

#include "GCWManager.h"

#include "server/zone/Zone.h"

#include "server/zone/objects/tangible/TangibleObject.h"

#include "server/zone/objects/structure/StructureObject.h"

#include "server/zone/objects/building/BuildingObject.h"

#include "server/zone/objects/installation/InstallationObject.h"

#include "server/zone/objects/creature/CreatureObject.h"

#include "server/zone/objects/player/PlayerObject.h"

#include "server/zone/objects/tangible/deed/structure/StructureDeed.h"

/*
 *	GCWManagerStub
 */

enum {RPC_LOADLUACONFIG__ = 6,RPC_INITIALIZE__,RPC_START__,RPC_REGISTERGCWBASE__BUILDINGOBJECT_BOOL_,RPC_UNREGISTERGCWBASE__BUILDINGOBJECT_,RPC_PERFORMGCWTASKS__,RPC_STARTVULNERABILITY__BUILDINGOBJECT_,RPC_ENDVULNERABILITY__BUILDINGOBJECT_,RPC_ISBASEVULNERABLE__BUILDINGOBJECT_,RPC_ISBANDIDENTIFIED__BUILDINGOBJECT_,RPC_ISUPLINKJAMMED__BUILDINGOBJECT_,RPC_ISSHUTDOWNSEQUENCESTARTED__BUILDINGOBJECT_,RPC_ISSECURITYTERMSLICED__BUILDINGOBJECT_,RPC_ISPOWEROVERLOADED__BUILDINGOBJECT_,RPC_RESETVULNERABILITY__CREATUREOBJECT_BUILDINGOBJECT_,RPC_SENDBASEDEFENSESTATUS__CREATUREOBJECT_BUILDINGOBJECT_,RPC_DOBASEDESTRUCTION__STRUCTUREOBJECT_,RPC_DOBASEDESTRUCTION__BUILDINGOBJECT_,RPC_SENDRESETVERIFICATION__CREATUREOBJECT_BUILDINGOBJECT_,RPC_SENDJAMUPLINKMENU__CREATUREOBJECT_BUILDINGOBJECT_,RPC_VERIFYUPLINKBAND__CREATUREOBJECT_BUILDINGOBJECT_INT_,RPC_CANSTARTSLICE__CREATUREOBJECT_TANGIBLEOBJECT_,RPC_SENDDNASAMPLEMENU__CREATUREOBJECT_BUILDINGOBJECT_,RPC_COMPLETESECURITYSLICE__CREATUREOBJECT_TANGIBLEOBJECT_,RPC_FAILSECURITYSLICE__TANGIBLEOBJECT_,RPC_ISTERMINALDAMAGED__TANGIBLEOBJECT_,RPC_ISDNASAMPLED__BUILDINGOBJECT_,RPC_REPAIRTERMINAL__CREATUREOBJECT_TANGIBLEOBJECT_,RPC_ABORTSHUTDOWNSEQUENCE__CREATUREOBJECT_BUILDINGOBJECT_,RPC_PROCESSDNASAMPLE__CREATUREOBJECT_BUILDINGOBJECT_INT_,RPC_HANDLEPOWERREGULATORSWITCH__CREATUREOBJECT_BUILDINGOBJECT_INT_,RPC_SENDPOWERREGULATORCONTROLS__CREATUREOBJECT_BUILDINGOBJECT_,RPC_GETDNAHASH__STRING_,RPC_ISPLANETCAPPED__,RPC_SCHEDULEBASEDESTRUCTION__BUILDINGOBJECT_CREATUREOBJECT_,RPC_NOTIFYTURRETDESTRUCTION__INSTALLATIONOBJECT_,RPC_SENDSELECTTURRETTODONATE__BUILDINGOBJECT_CREATUREOBJECT_,RPC_SENDSELECTDEEDTODONATE__BUILDINGOBJECT_CREATUREOBJECT_INT_,RPC_SENDREMOVEDEFENSECONFIRMATION__BUILDINGOBJECT_CREATUREOBJECT_LONG_,RPC_PERFORMDEFENSEDONTATION__BUILDINGOBJECT_CREATUREOBJECT_LONG_INT_,RPC_SENDSTATUS__BUILDINGOBJECT_CREATUREOBJECT_,RPC_ADDMINEFIELD__BUILDINGOBJECT_SCENEOBJECT_,RPC_ADDTURRET__BUILDINGOBJECT_SCENEOBJECT_,RPC_ADDSCANNER__BUILDINGOBJECT_SCENEOBJECT_,RPC_REMOVEDEFENSE__BUILDINGOBJECT_CREATUREOBJECT_LONG_,RPC_CANUSETERMINALS__CREATUREOBJECT_BUILDINGOBJECT_SCENEOBJECT_,RPC_SENDTURRETATTACKLISTTO__CREATUREOBJECT_SCENEOBJECT_,RPC_GETIMPERIALBASECOUNT__,RPC_GETREBELBASECOUNT__,};

GCWManager::GCWManager(Zone* zne) : ManagedService(DummyConstructorParameter::instance()) {
	GCWManagerImplementation* _implementation = new GCWManagerImplementation(zne);
	_impl = _implementation;
	_impl->_setStub(this);
	_setClassName("GCWManager");
}

GCWManager::GCWManager(DummyConstructorParameter* param) : ManagedService(param) {
	_setClassName("GCWManager");
}

GCWManager::~GCWManager() {
}



void GCWManager::loadLuaConfig() {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_LOADLUACONFIG__);

		method.executeWithVoidReturn();
	} else
		_implementation->loadLuaConfig();
}

void GCWManager::initialize() {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INITIALIZE__);

		method.executeWithVoidReturn();
	} else
		_implementation->initialize();
}

void GCWManager::start() {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_START__);

		method.executeWithVoidReturn();
	} else
		_implementation->start();
}

void GCWManager::registerGCWBase(BuildingObject* building, bool initializeBase) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REGISTERGCWBASE__BUILDINGOBJECT_BOOL_);
		method.addObjectParameter(building);
		method.addBooleanParameter(initializeBase);

		method.executeWithVoidReturn();
	} else
		_implementation->registerGCWBase(building, initializeBase);
}

void GCWManager::unregisterGCWBase(BuildingObject* building) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UNREGISTERGCWBASE__BUILDINGOBJECT_);
		method.addObjectParameter(building);

		method.executeWithVoidReturn();
	} else
		_implementation->unregisterGCWBase(building);
}

void GCWManager::performGCWTasks() {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_PERFORMGCWTASKS__);

		method.executeWithVoidReturn();
	} else
		_implementation->performGCWTasks();
}

void GCWManager::startVulnerability(BuildingObject* building) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_STARTVULNERABILITY__BUILDINGOBJECT_);
		method.addObjectParameter(building);

		method.executeWithVoidReturn();
	} else
		_implementation->startVulnerability(building);
}

void GCWManager::endVulnerability(BuildingObject* building) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ENDVULNERABILITY__BUILDINGOBJECT_);
		method.addObjectParameter(building);

		method.executeWithVoidReturn();
	} else
		_implementation->endVulnerability(building);
}

bool GCWManager::isBaseVulnerable(BuildingObject* building) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISBASEVULNERABLE__BUILDINGOBJECT_);
		method.addObjectParameter(building);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isBaseVulnerable(building);
}

bool GCWManager::isBandIdentified(BuildingObject* building) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISBANDIDENTIFIED__BUILDINGOBJECT_);
		method.addObjectParameter(building);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isBandIdentified(building);
}

bool GCWManager::isUplinkJammed(BuildingObject* building) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISUPLINKJAMMED__BUILDINGOBJECT_);
		method.addObjectParameter(building);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isUplinkJammed(building);
}

bool GCWManager::isShutdownSequenceStarted(BuildingObject* building) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISSHUTDOWNSEQUENCESTARTED__BUILDINGOBJECT_);
		method.addObjectParameter(building);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isShutdownSequenceStarted(building);
}

bool GCWManager::isSecurityTermSliced(BuildingObject* building) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISSECURITYTERMSLICED__BUILDINGOBJECT_);
		method.addObjectParameter(building);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isSecurityTermSliced(building);
}

bool GCWManager::isPowerOverloaded(BuildingObject* building) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISPOWEROVERLOADED__BUILDINGOBJECT_);
		method.addObjectParameter(building);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isPowerOverloaded(building);
}

void GCWManager::resetVulnerability(CreatureObject* creature, BuildingObject* building) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_RESETVULNERABILITY__CREATUREOBJECT_BUILDINGOBJECT_);
		method.addObjectParameter(creature);
		method.addObjectParameter(building);

		method.executeWithVoidReturn();
	} else
		_implementation->resetVulnerability(creature, building);
}

void GCWManager::sendBaseDefenseStatus(CreatureObject* creature, BuildingObject* building) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDBASEDEFENSESTATUS__CREATUREOBJECT_BUILDINGOBJECT_);
		method.addObjectParameter(creature);
		method.addObjectParameter(building);

		method.executeWithVoidReturn();
	} else
		_implementation->sendBaseDefenseStatus(creature, building);
}

void GCWManager::doBaseDestruction(StructureObject* structure) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DOBASEDESTRUCTION__STRUCTUREOBJECT_);
		method.addObjectParameter(structure);

		method.executeWithVoidReturn();
	} else
		_implementation->doBaseDestruction(structure);
}

void GCWManager::doBaseDestruction(BuildingObject* building) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DOBASEDESTRUCTION__BUILDINGOBJECT_);
		method.addObjectParameter(building);

		method.executeWithVoidReturn();
	} else
		_implementation->doBaseDestruction(building);
}

void GCWManager::sendResetVerification(CreatureObject* creature, BuildingObject* building) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDRESETVERIFICATION__CREATUREOBJECT_BUILDINGOBJECT_);
		method.addObjectParameter(creature);
		method.addObjectParameter(building);

		method.executeWithVoidReturn();
	} else
		_implementation->sendResetVerification(creature, building);
}

void GCWManager::sendJamUplinkMenu(CreatureObject* creature, BuildingObject* building) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDJAMUPLINKMENU__CREATUREOBJECT_BUILDINGOBJECT_);
		method.addObjectParameter(creature);
		method.addObjectParameter(building);

		method.executeWithVoidReturn();
	} else
		_implementation->sendJamUplinkMenu(creature, building);
}

void GCWManager::verifyUplinkBand(CreatureObject* creature, BuildingObject* building, int band) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_VERIFYUPLINKBAND__CREATUREOBJECT_BUILDINGOBJECT_INT_);
		method.addObjectParameter(creature);
		method.addObjectParameter(building);
		method.addSignedIntParameter(band);

		method.executeWithVoidReturn();
	} else
		_implementation->verifyUplinkBand(creature, building, band);
}

bool GCWManager::canStartSlice(CreatureObject* creature, TangibleObject* terminal) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CANSTARTSLICE__CREATUREOBJECT_TANGIBLEOBJECT_);
		method.addObjectParameter(creature);
		method.addObjectParameter(terminal);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->canStartSlice(creature, terminal);
}

void GCWManager::sendDNASampleMenu(CreatureObject* creature, BuildingObject* building) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDDNASAMPLEMENU__CREATUREOBJECT_BUILDINGOBJECT_);
		method.addObjectParameter(creature);
		method.addObjectParameter(building);

		method.executeWithVoidReturn();
	} else
		_implementation->sendDNASampleMenu(creature, building);
}

void GCWManager::completeSecuritySlice(CreatureObject* creature, TangibleObject* securityTerminal) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_COMPLETESECURITYSLICE__CREATUREOBJECT_TANGIBLEOBJECT_);
		method.addObjectParameter(creature);
		method.addObjectParameter(securityTerminal);

		method.executeWithVoidReturn();
	} else
		_implementation->completeSecuritySlice(creature, securityTerminal);
}

void GCWManager::failSecuritySlice(TangibleObject* securityTerminal) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_FAILSECURITYSLICE__TANGIBLEOBJECT_);
		method.addObjectParameter(securityTerminal);

		method.executeWithVoidReturn();
	} else
		_implementation->failSecuritySlice(securityTerminal);
}

bool GCWManager::isTerminalDamaged(TangibleObject* securityTerminal) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISTERMINALDAMAGED__TANGIBLEOBJECT_);
		method.addObjectParameter(securityTerminal);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isTerminalDamaged(securityTerminal);
}

bool GCWManager::isDNASampled(BuildingObject* building) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISDNASAMPLED__BUILDINGOBJECT_);
		method.addObjectParameter(building);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isDNASampled(building);
}

void GCWManager::repairTerminal(CreatureObject* creature, TangibleObject* securityTerminal) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REPAIRTERMINAL__CREATUREOBJECT_TANGIBLEOBJECT_);
		method.addObjectParameter(creature);
		method.addObjectParameter(securityTerminal);

		method.executeWithVoidReturn();
	} else
		_implementation->repairTerminal(creature, securityTerminal);
}

void GCWManager::abortShutdownSequence(CreatureObject* creature, BuildingObject* building) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ABORTSHUTDOWNSEQUENCE__CREATUREOBJECT_BUILDINGOBJECT_);
		method.addObjectParameter(creature);
		method.addObjectParameter(building);

		method.executeWithVoidReturn();
	} else
		_implementation->abortShutdownSequence(creature, building);
}

void GCWManager::processDNASample(CreatureObject* creature, BuildingObject* building, int indx) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_PROCESSDNASAMPLE__CREATUREOBJECT_BUILDINGOBJECT_INT_);
		method.addObjectParameter(creature);
		method.addObjectParameter(building);
		method.addSignedIntParameter(indx);

		method.executeWithVoidReturn();
	} else
		_implementation->processDNASample(creature, building, indx);
}

void GCWManager::handlePowerRegulatorSwitch(CreatureObject* creature, BuildingObject* building, int indx) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HANDLEPOWERREGULATORSWITCH__CREATUREOBJECT_BUILDINGOBJECT_INT_);
		method.addObjectParameter(creature);
		method.addObjectParameter(building);
		method.addSignedIntParameter(indx);

		method.executeWithVoidReturn();
	} else
		_implementation->handlePowerRegulatorSwitch(creature, building, indx);
}

void GCWManager::sendPowerRegulatorControls(CreatureObject* creature, BuildingObject* building) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDPOWERREGULATORCONTROLS__CREATUREOBJECT_BUILDINGOBJECT_);
		method.addObjectParameter(creature);
		method.addObjectParameter(building);

		method.executeWithVoidReturn();
	} else
		_implementation->sendPowerRegulatorControls(creature, building);
}

String GCWManager::getDNAHash(const String& usersample) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETDNAHASH__STRING_);
		method.addAsciiParameter(usersample);

		String _return_getDNAHash;
		method.executeWithAsciiReturn(_return_getDNAHash);
		return _return_getDNAHash;
	} else
		return _implementation->getDNAHash(usersample);
}

bool GCWManager::isPlanetCapped() {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISPLANETCAPPED__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isPlanetCapped();
}

void GCWManager::scheduleBaseDestruction(BuildingObject* building, CreatureObject* creature) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SCHEDULEBASEDESTRUCTION__BUILDINGOBJECT_CREATUREOBJECT_);
		method.addObjectParameter(building);
		method.addObjectParameter(creature);

		method.executeWithVoidReturn();
	} else
		_implementation->scheduleBaseDestruction(building, creature);
}

void GCWManager::notifyTurretDestruction(InstallationObject* turret) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYTURRETDESTRUCTION__INSTALLATIONOBJECT_);
		method.addObjectParameter(turret);

		method.executeWithVoidReturn();
	} else
		_implementation->notifyTurretDestruction(turret);
}

void GCWManager::sendSelectTurretToDonate(BuildingObject* building, CreatureObject* creature) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDSELECTTURRETTODONATE__BUILDINGOBJECT_CREATUREOBJECT_);
		method.addObjectParameter(building);
		method.addObjectParameter(creature);

		method.executeWithVoidReturn();
	} else
		_implementation->sendSelectTurretToDonate(building, creature);
}

void GCWManager::sendSelectDeedToDonate(BuildingObject* building, CreatureObject* creature, int turretIndex) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDSELECTDEEDTODONATE__BUILDINGOBJECT_CREATUREOBJECT_INT_);
		method.addObjectParameter(building);
		method.addObjectParameter(creature);
		method.addSignedIntParameter(turretIndex);

		method.executeWithVoidReturn();
	} else
		_implementation->sendSelectDeedToDonate(building, creature, turretIndex);
}

void GCWManager::sendRemoveDefenseConfirmation(BuildingObject* building, CreatureObject* creature, unsigned long long deedOID) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDREMOVEDEFENSECONFIRMATION__BUILDINGOBJECT_CREATUREOBJECT_LONG_);
		method.addObjectParameter(building);
		method.addObjectParameter(creature);
		method.addUnsignedLongParameter(deedOID);

		method.executeWithVoidReturn();
	} else
		_implementation->sendRemoveDefenseConfirmation(building, creature, deedOID);
}

void GCWManager::performDefenseDontation(BuildingObject* building, CreatureObject* creature, unsigned long long deedOID, int turretIndex) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_PERFORMDEFENSEDONTATION__BUILDINGOBJECT_CREATUREOBJECT_LONG_INT_);
		method.addObjectParameter(building);
		method.addObjectParameter(creature);
		method.addUnsignedLongParameter(deedOID);
		method.addSignedIntParameter(turretIndex);

		method.executeWithVoidReturn();
	} else
		_implementation->performDefenseDontation(building, creature, deedOID, turretIndex);
}

void GCWManager::sendStatus(BuildingObject* building, CreatureObject* creature) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDSTATUS__BUILDINGOBJECT_CREATUREOBJECT_);
		method.addObjectParameter(building);
		method.addObjectParameter(creature);

		method.executeWithVoidReturn();
	} else
		_implementation->sendStatus(building, creature);
}

void GCWManager::addMinefield(BuildingObject* building, SceneObject* minefield) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDMINEFIELD__BUILDINGOBJECT_SCENEOBJECT_);
		method.addObjectParameter(building);
		method.addObjectParameter(minefield);

		method.executeWithVoidReturn();
	} else
		_implementation->addMinefield(building, minefield);
}

void GCWManager::addTurret(BuildingObject* building, SceneObject* turret) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDTURRET__BUILDINGOBJECT_SCENEOBJECT_);
		method.addObjectParameter(building);
		method.addObjectParameter(turret);

		method.executeWithVoidReturn();
	} else
		_implementation->addTurret(building, turret);
}

void GCWManager::addScanner(BuildingObject* building, SceneObject* scanner) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDSCANNER__BUILDINGOBJECT_SCENEOBJECT_);
		method.addObjectParameter(building);
		method.addObjectParameter(scanner);

		method.executeWithVoidReturn();
	} else
		_implementation->addScanner(building, scanner);
}

void GCWManager::removeDefense(BuildingObject* building, CreatureObject* creature, unsigned long long deedOID) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEDEFENSE__BUILDINGOBJECT_CREATUREOBJECT_LONG_);
		method.addObjectParameter(building);
		method.addObjectParameter(creature);
		method.addUnsignedLongParameter(deedOID);

		method.executeWithVoidReturn();
	} else
		_implementation->removeDefense(building, creature, deedOID);
}

bool GCWManager::canUseTerminals(CreatureObject* creature, BuildingObject* building, SceneObject* terminal) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CANUSETERMINALS__CREATUREOBJECT_BUILDINGOBJECT_SCENEOBJECT_);
		method.addObjectParameter(creature);
		method.addObjectParameter(building);
		method.addObjectParameter(terminal);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->canUseTerminals(creature, building, terminal);
}

void GCWManager::sendTurretAttackListTo(CreatureObject* creature, SceneObject* turretControlTerminal) {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDTURRETATTACKLISTTO__CREATUREOBJECT_SCENEOBJECT_);
		method.addObjectParameter(creature);
		method.addObjectParameter(turretControlTerminal);

		method.executeWithVoidReturn();
	} else
		_implementation->sendTurretAttackListTo(creature, turretControlTerminal);
}

int GCWManager::getImperialBaseCount() {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETIMPERIALBASECOUNT__);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getImperialBaseCount();
}

int GCWManager::getRebelBaseCount() {
	GCWManagerImplementation* _implementation = static_cast<GCWManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETREBELBASECOUNT__);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getRebelBaseCount();
}

DistributedObjectServant* GCWManager::_getImplementation() {

	 if (!_updated) _updated = true;
	return _impl;
}

void GCWManager::_setImplementation(DistributedObjectServant* servant) {
	_impl = servant;
}

/*
 *	GCWManagerImplementation
 */

GCWManagerImplementation::GCWManagerImplementation(DummyConstructorParameter* param) : ManagedServiceImplementation(param) {
	_initializeImplementation();
}


GCWManagerImplementation::~GCWManagerImplementation() {
}


void GCWManagerImplementation::finalize() {
}

void GCWManagerImplementation::_initializeImplementation() {
	_setClassHelper(GCWManagerHelper::instance());

	_this = NULL;

	_serializationHelperMethod();
}

void GCWManagerImplementation::_setStub(DistributedObjectStub* stub) {
	_this = static_cast<GCWManager*>(stub);
	ManagedServiceImplementation::_setStub(stub);
}

DistributedObjectStub* GCWManagerImplementation::_getStub() {
	return _this.get();
}

GCWManagerImplementation::operator const GCWManager*() {
	return _this.get();
}

void GCWManagerImplementation::lock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->lock(doLock);
}

void GCWManagerImplementation::lock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->lock(obj);
}

void GCWManagerImplementation::rlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->rlock(doLock);
}

void GCWManagerImplementation::wlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->wlock(doLock);
}

void GCWManagerImplementation::wlock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->wlock(obj);
}

void GCWManagerImplementation::unlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->unlock(doLock);
}

void GCWManagerImplementation::runlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->runlock(doLock);
}

void GCWManagerImplementation::_serializationHelperMethod() {
	ManagedServiceImplementation::_serializationHelperMethod();

	_setClassName("GCWManager");

}

void GCWManagerImplementation::readObject(ObjectInputStream* stream) {
	uint16 _varCount = stream->readShort();
	for (int i = 0; i < _varCount; ++i) {
		String _name;
		_name.parseFromBinaryStream(stream);

		uint32 _varSize = stream->readInt();

		int _currentOffset = stream->getOffset();

		if(GCWManagerImplementation::readObjectMember(stream, _name)) {
		}

		stream->setOffset(_currentOffset + _varSize);
	}

	initializeTransientMembers();
}

bool GCWManagerImplementation::readObjectMember(ObjectInputStream* stream, const String& _name) {
	if (ManagedServiceImplementation::readObjectMember(stream, _name))
		return true;

	if (_name == "GCWManager.zone") {
		TypeInfo<ManagedReference<Zone* > >::parseFromBinaryStream(&zone, stream);
		return true;
	}

	if (_name == "GCWManager.rebelBases") {
		TypeInfo<int >::parseFromBinaryStream(&rebelBases, stream);
		return true;
	}

	if (_name == "GCWManager.imperialBases") {
		TypeInfo<int >::parseFromBinaryStream(&imperialBases, stream);
		return true;
	}


	return false;
}

void GCWManagerImplementation::writeObject(ObjectOutputStream* stream) {
	int _currentOffset = stream->getOffset();
	stream->writeShort(0);
	int _varCount = GCWManagerImplementation::writeObjectMembers(stream);
	stream->writeShort(_currentOffset, _varCount);
}

int GCWManagerImplementation::writeObjectMembers(ObjectOutputStream* stream) {
	int _count = ManagedServiceImplementation::writeObjectMembers(stream);

	String _name;
	int _offset;
	uint32 _totalSize;
	_name = "GCWManager.zone";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedReference<Zone* > >::toBinaryStream(&zone, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_name = "GCWManager.rebelBases";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&rebelBases, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_name = "GCWManager.imperialBases";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&imperialBases, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);


	return _count + 3;
}

GCWManagerImplementation::GCWManagerImplementation(Zone* zne) {
	_initializeImplementation();
	// server/zone/managers/gcw/GCWManager.idl():  		imperialBases = 0;
	imperialBases = 0;
	// server/zone/managers/gcw/GCWManager.idl():  		rebelBases = 0;
	rebelBases = 0;
	// server/zone/managers/gcw/GCWManager.idl():  		Logger.setLoggingName("GCWManager");
	Logger::setLoggingName("GCWManager");
	// server/zone/managers/gcw/GCWManager.idl():  		Logger.info("GCWManager instantiated for " + zne.getZoneName(),true);
	Logger::info("GCWManager instantiated for " + zne->getZoneName(), true);
	// server/zone/managers/gcw/GCWManager.idl():  		gcwBaseList.setNoDuplicateInsertPlan();
	(&gcwBaseList)->setNoDuplicateInsertPlan();
	// server/zone/managers/gcw/GCWManager.idl():  		zone = zne;
	zone = zne;
	// server/zone/managers/gcw/GCWManager.idl():  		gcwStartTasks.setNoDuplicateInsertPlan();
	(&gcwStartTasks)->setNoDuplicateInsertPlan();
	// server/zone/managers/gcw/GCWManager.idl():  		gcwStartTasks.setNullValue(null);
	(&gcwStartTasks)->setNullValue(NULL);
	// server/zone/managers/gcw/GCWManager.idl():  		gcwEndTasks.setNoDuplicateInsertPlan();
	(&gcwEndTasks)->setNoDuplicateInsertPlan();
	// server/zone/managers/gcw/GCWManager.idl():  		gcwEndTasks.setNullValue(null);
	(&gcwEndTasks)->setNullValue(NULL);
	// server/zone/managers/gcw/GCWManager.idl():  		gcwDestroyTasks.setNoDuplicateInsertPlan();
	(&gcwDestroyTasks)->setNoDuplicateInsertPlan();
	// server/zone/managers/gcw/GCWManager.idl():  		gcwDestroyTasks.setNullValue(null);
	(&gcwDestroyTasks)->setNullValue(NULL);
}

String GCWManagerImplementation::getDNAHash(const String& usersample) {
	Locker _locker(_this.get());
	// server/zone/managers/gcw/GCWManager.idl():  		return dnaHash.get(usersample);
	return (&dnaHash)->get(usersample);
}

void GCWManagerImplementation::addDNAHash(const String& usersample, const String& systemsample) {
	Locker _locker(_this.get());
	// server/zone/managers/gcw/GCWManager.idl():  		dnaHash.put(usersample, systemsample);
	(&dnaHash)->put(usersample, systemsample);
}

bool GCWManagerImplementation::hasBase(BuildingObject* building) {
	Locker _locker(_this.get());
	// server/zone/managers/gcw/GCWManager.idl():  		return gcwBaseList.contains(building);
	return (&gcwBaseList)->contains(building);
}

bool GCWManagerImplementation::dropBase(BuildingObject* building) {
	Locker _locker(_this.get());
	// server/zone/managers/gcw/GCWManager.idl():  		return gcwBaseList.drop(building);
	return (&gcwBaseList)->drop(building);
}

void GCWManagerImplementation::addBase(BuildingObject* building) {
	Locker _locker(_this.get());
	// server/zone/managers/gcw/GCWManager.idl():  		gcwBaseList.put(building);
	(&gcwBaseList)->put(building);
}

BuildingObject* GCWManagerImplementation::getBase(int indx) {
	Locker _locker(_this.get());
	// server/zone/managers/gcw/GCWManager.idl():  		return gcwBaseList.get(indx);
	return (&gcwBaseList)->get(indx);
}

bool GCWManagerImplementation::hasStartTask(unsigned long long id) {
	Locker _locker(_this.get());
	// server/zone/managers/gcw/GCWManager.idl():  		return gcwStartTasks.contains(id);
	return (&gcwStartTasks)->contains(id);
}

bool GCWManagerImplementation::addStartTask(unsigned long long id, Reference<Task*> newTask) {
	Locker _locker(_this.get());
	// server/zone/managers/gcw/GCWManager.idl():  	return 
	if (!(&gcwStartTasks)->contains(id)){
	// server/zone/managers/gcw/GCWManager.idl():  			return gcwStartTasks.put(id, newTask);
	return (&gcwStartTasks)->put(id, newTask);
}
	// server/zone/managers/gcw/GCWManager.idl():  	return false;
	return false;
}

Reference<Task*> GCWManagerImplementation::getStartTask(unsigned long long id) {
	Locker _locker(_this.get());
	// server/zone/managers/gcw/GCWManager.idl():  		return gcwStartTasks.get(id);
	return (&gcwStartTasks)->get(id);
}

bool GCWManagerImplementation::dropStartTask(unsigned long long id) {
	Locker _locker(_this.get());
	// server/zone/managers/gcw/GCWManager.idl():  		return gcwStartTasks.drop(id);
	return (&gcwStartTasks)->drop(id);
}

bool GCWManagerImplementation::hasEndTask(unsigned long long id) {
	Locker _locker(_this.get());
	// server/zone/managers/gcw/GCWManager.idl():  		return gcwEndTasks.contains(id);
	return (&gcwEndTasks)->contains(id);
}

bool GCWManagerImplementation::addEndTask(unsigned long long id, Reference<Task*> newTask) {
	Locker _locker(_this.get());
	// server/zone/managers/gcw/GCWManager.idl():  		return 
	if (!(&gcwEndTasks)->contains(id)){
	// server/zone/managers/gcw/GCWManager.idl():  			return	gcwEndTasks.put(id, newTask);
	return (&gcwEndTasks)->put(id, newTask);
}
	// server/zone/managers/gcw/GCWManager.idl():  		return false;
	return false;
}

Reference<Task*> GCWManagerImplementation::getEndTask(unsigned long long id) {
	Locker _locker(_this.get());
	// server/zone/managers/gcw/GCWManager.idl():  		return gcwEndTasks.get(id);
	return (&gcwEndTasks)->get(id);
}

bool GCWManagerImplementation::dropEndTask(unsigned long long id) {
	Locker _locker(_this.get());
	// server/zone/managers/gcw/GCWManager.idl():  		return gcwEndTasks.drop(id);
	return (&gcwEndTasks)->drop(id);
}

bool GCWManagerImplementation::hasDestroyTask(unsigned long long id) {
	Locker _locker(_this.get());
	// server/zone/managers/gcw/GCWManager.idl():  		return gcwDestroyTasks.contains(id);
	return (&gcwDestroyTasks)->contains(id);
}

bool GCWManagerImplementation::addDestroyTask(unsigned long long id, Reference<Task*> newTask) {
	Locker _locker(_this.get());
	// server/zone/managers/gcw/GCWManager.idl():  		return 
	if (!(&gcwDestroyTasks)->contains(id)){
	// server/zone/managers/gcw/GCWManager.idl():  			return	gcwDestroyTasks.put(id, newTask);
	return (&gcwDestroyTasks)->put(id, newTask);
}
	// server/zone/managers/gcw/GCWManager.idl():  		return false;
	return false;
}

Reference<Task*> GCWManagerImplementation::getDestroyTask(unsigned long long id) {
	Locker _locker(_this.get());
	// server/zone/managers/gcw/GCWManager.idl():  		return gcwDestroyTasks.get(id);
	return (&gcwDestroyTasks)->get(id);
}

bool GCWManagerImplementation::dropDestroyTask(unsigned long long id) {
	Locker _locker(_this.get());
	// server/zone/managers/gcw/GCWManager.idl():  		return gcwDestroyTasks.drop(id);
	return (&gcwDestroyTasks)->drop(id);
}

bool GCWManagerImplementation::isPlanetCapped() {
	Locker _locker(_this.get());
	// server/zone/managers/gcw/GCWManager.idl():  		return maxBases <= gcwBaseList.size();
	return maxBases <= (&gcwBaseList)->size();
}

int GCWManagerImplementation::getImperialBaseCount() {
	// server/zone/managers/gcw/GCWManager.idl():  		return imperialBases;
	return imperialBases;
}

int GCWManagerImplementation::getRebelBaseCount() {
	// server/zone/managers/gcw/GCWManager.idl():  		return rebelBases;
	return rebelBases;
}

void GCWManagerImplementation::setRebelBaseCount(int val) {
	// server/zone/managers/gcw/GCWManager.idl():  		rebelBases = val;
	rebelBases = val;
}

void GCWManagerImplementation::setImperialBaseCount(int val) {
	// server/zone/managers/gcw/GCWManager.idl():  		imperialBases = val;
	imperialBases = val;
}

/*
 *	GCWManagerAdapter
 */


#include "engine/orb/messages/InvokeMethodMessage.h"


GCWManagerAdapter::GCWManagerAdapter(GCWManager* obj) : ManagedServiceAdapter(obj) {
}

void GCWManagerAdapter::invokeMethod(uint32 methid, DistributedMethod* inv) {
	DOBMessage* resp = inv->getInvocationMessage();

	switch (methid) {
	case RPC_LOADLUACONFIG__:
		{
			loadLuaConfig();
		}
		break;
	case RPC_INITIALIZE__:
		{
			initialize();
		}
		break;
	case RPC_START__:
		{
			start();
		}
		break;
	case RPC_REGISTERGCWBASE__BUILDINGOBJECT_BOOL_:
		{
			registerGCWBase(static_cast<BuildingObject*>(inv->getObjectParameter()), inv->getBooleanParameter());
		}
		break;
	case RPC_UNREGISTERGCWBASE__BUILDINGOBJECT_:
		{
			unregisterGCWBase(static_cast<BuildingObject*>(inv->getObjectParameter()));
		}
		break;
	case RPC_PERFORMGCWTASKS__:
		{
			performGCWTasks();
		}
		break;
	case RPC_STARTVULNERABILITY__BUILDINGOBJECT_:
		{
			startVulnerability(static_cast<BuildingObject*>(inv->getObjectParameter()));
		}
		break;
	case RPC_ENDVULNERABILITY__BUILDINGOBJECT_:
		{
			endVulnerability(static_cast<BuildingObject*>(inv->getObjectParameter()));
		}
		break;
	case RPC_ISBASEVULNERABLE__BUILDINGOBJECT_:
		{
			resp->insertBoolean(isBaseVulnerable(static_cast<BuildingObject*>(inv->getObjectParameter())));
		}
		break;
	case RPC_ISBANDIDENTIFIED__BUILDINGOBJECT_:
		{
			resp->insertBoolean(isBandIdentified(static_cast<BuildingObject*>(inv->getObjectParameter())));
		}
		break;
	case RPC_ISUPLINKJAMMED__BUILDINGOBJECT_:
		{
			resp->insertBoolean(isUplinkJammed(static_cast<BuildingObject*>(inv->getObjectParameter())));
		}
		break;
	case RPC_ISSHUTDOWNSEQUENCESTARTED__BUILDINGOBJECT_:
		{
			resp->insertBoolean(isShutdownSequenceStarted(static_cast<BuildingObject*>(inv->getObjectParameter())));
		}
		break;
	case RPC_ISSECURITYTERMSLICED__BUILDINGOBJECT_:
		{
			resp->insertBoolean(isSecurityTermSliced(static_cast<BuildingObject*>(inv->getObjectParameter())));
		}
		break;
	case RPC_ISPOWEROVERLOADED__BUILDINGOBJECT_:
		{
			resp->insertBoolean(isPowerOverloaded(static_cast<BuildingObject*>(inv->getObjectParameter())));
		}
		break;
	case RPC_RESETVULNERABILITY__CREATUREOBJECT_BUILDINGOBJECT_:
		{
			resetVulnerability(static_cast<CreatureObject*>(inv->getObjectParameter()), static_cast<BuildingObject*>(inv->getObjectParameter()));
		}
		break;
	case RPC_SENDBASEDEFENSESTATUS__CREATUREOBJECT_BUILDINGOBJECT_:
		{
			sendBaseDefenseStatus(static_cast<CreatureObject*>(inv->getObjectParameter()), static_cast<BuildingObject*>(inv->getObjectParameter()));
		}
		break;
	case RPC_DOBASEDESTRUCTION__STRUCTUREOBJECT_:
		{
			doBaseDestruction(static_cast<StructureObject*>(inv->getObjectParameter()));
		}
		break;
	case RPC_DOBASEDESTRUCTION__BUILDINGOBJECT_:
		{
			doBaseDestruction(static_cast<BuildingObject*>(inv->getObjectParameter()));
		}
		break;
	case RPC_SENDRESETVERIFICATION__CREATUREOBJECT_BUILDINGOBJECT_:
		{
			sendResetVerification(static_cast<CreatureObject*>(inv->getObjectParameter()), static_cast<BuildingObject*>(inv->getObjectParameter()));
		}
		break;
	case RPC_SENDJAMUPLINKMENU__CREATUREOBJECT_BUILDINGOBJECT_:
		{
			sendJamUplinkMenu(static_cast<CreatureObject*>(inv->getObjectParameter()), static_cast<BuildingObject*>(inv->getObjectParameter()));
		}
		break;
	case RPC_VERIFYUPLINKBAND__CREATUREOBJECT_BUILDINGOBJECT_INT_:
		{
			verifyUplinkBand(static_cast<CreatureObject*>(inv->getObjectParameter()), static_cast<BuildingObject*>(inv->getObjectParameter()), inv->getSignedIntParameter());
		}
		break;
	case RPC_CANSTARTSLICE__CREATUREOBJECT_TANGIBLEOBJECT_:
		{
			resp->insertBoolean(canStartSlice(static_cast<CreatureObject*>(inv->getObjectParameter()), static_cast<TangibleObject*>(inv->getObjectParameter())));
		}
		break;
	case RPC_SENDDNASAMPLEMENU__CREATUREOBJECT_BUILDINGOBJECT_:
		{
			sendDNASampleMenu(static_cast<CreatureObject*>(inv->getObjectParameter()), static_cast<BuildingObject*>(inv->getObjectParameter()));
		}
		break;
	case RPC_COMPLETESECURITYSLICE__CREATUREOBJECT_TANGIBLEOBJECT_:
		{
			completeSecuritySlice(static_cast<CreatureObject*>(inv->getObjectParameter()), static_cast<TangibleObject*>(inv->getObjectParameter()));
		}
		break;
	case RPC_FAILSECURITYSLICE__TANGIBLEOBJECT_:
		{
			failSecuritySlice(static_cast<TangibleObject*>(inv->getObjectParameter()));
		}
		break;
	case RPC_ISTERMINALDAMAGED__TANGIBLEOBJECT_:
		{
			resp->insertBoolean(isTerminalDamaged(static_cast<TangibleObject*>(inv->getObjectParameter())));
		}
		break;
	case RPC_ISDNASAMPLED__BUILDINGOBJECT_:
		{
			resp->insertBoolean(isDNASampled(static_cast<BuildingObject*>(inv->getObjectParameter())));
		}
		break;
	case RPC_REPAIRTERMINAL__CREATUREOBJECT_TANGIBLEOBJECT_:
		{
			repairTerminal(static_cast<CreatureObject*>(inv->getObjectParameter()), static_cast<TangibleObject*>(inv->getObjectParameter()));
		}
		break;
	case RPC_ABORTSHUTDOWNSEQUENCE__CREATUREOBJECT_BUILDINGOBJECT_:
		{
			abortShutdownSequence(static_cast<CreatureObject*>(inv->getObjectParameter()), static_cast<BuildingObject*>(inv->getObjectParameter()));
		}
		break;
	case RPC_PROCESSDNASAMPLE__CREATUREOBJECT_BUILDINGOBJECT_INT_:
		{
			processDNASample(static_cast<CreatureObject*>(inv->getObjectParameter()), static_cast<BuildingObject*>(inv->getObjectParameter()), inv->getSignedIntParameter());
		}
		break;
	case RPC_HANDLEPOWERREGULATORSWITCH__CREATUREOBJECT_BUILDINGOBJECT_INT_:
		{
			handlePowerRegulatorSwitch(static_cast<CreatureObject*>(inv->getObjectParameter()), static_cast<BuildingObject*>(inv->getObjectParameter()), inv->getSignedIntParameter());
		}
		break;
	case RPC_SENDPOWERREGULATORCONTROLS__CREATUREOBJECT_BUILDINGOBJECT_:
		{
			sendPowerRegulatorControls(static_cast<CreatureObject*>(inv->getObjectParameter()), static_cast<BuildingObject*>(inv->getObjectParameter()));
		}
		break;
	case RPC_GETDNAHASH__STRING_:
		{
			String usersample; 
			resp->insertAscii(getDNAHash(inv->getAsciiParameter(usersample)));
		}
		break;
	case RPC_ISPLANETCAPPED__:
		{
			resp->insertBoolean(isPlanetCapped());
		}
		break;
	case RPC_SCHEDULEBASEDESTRUCTION__BUILDINGOBJECT_CREATUREOBJECT_:
		{
			scheduleBaseDestruction(static_cast<BuildingObject*>(inv->getObjectParameter()), static_cast<CreatureObject*>(inv->getObjectParameter()));
		}
		break;
	case RPC_NOTIFYTURRETDESTRUCTION__INSTALLATIONOBJECT_:
		{
			notifyTurretDestruction(static_cast<InstallationObject*>(inv->getObjectParameter()));
		}
		break;
	case RPC_SENDSELECTTURRETTODONATE__BUILDINGOBJECT_CREATUREOBJECT_:
		{
			sendSelectTurretToDonate(static_cast<BuildingObject*>(inv->getObjectParameter()), static_cast<CreatureObject*>(inv->getObjectParameter()));
		}
		break;
	case RPC_SENDSELECTDEEDTODONATE__BUILDINGOBJECT_CREATUREOBJECT_INT_:
		{
			sendSelectDeedToDonate(static_cast<BuildingObject*>(inv->getObjectParameter()), static_cast<CreatureObject*>(inv->getObjectParameter()), inv->getSignedIntParameter());
		}
		break;
	case RPC_SENDREMOVEDEFENSECONFIRMATION__BUILDINGOBJECT_CREATUREOBJECT_LONG_:
		{
			sendRemoveDefenseConfirmation(static_cast<BuildingObject*>(inv->getObjectParameter()), static_cast<CreatureObject*>(inv->getObjectParameter()), inv->getUnsignedLongParameter());
		}
		break;
	case RPC_PERFORMDEFENSEDONTATION__BUILDINGOBJECT_CREATUREOBJECT_LONG_INT_:
		{
			performDefenseDontation(static_cast<BuildingObject*>(inv->getObjectParameter()), static_cast<CreatureObject*>(inv->getObjectParameter()), inv->getUnsignedLongParameter(), inv->getSignedIntParameter());
		}
		break;
	case RPC_SENDSTATUS__BUILDINGOBJECT_CREATUREOBJECT_:
		{
			sendStatus(static_cast<BuildingObject*>(inv->getObjectParameter()), static_cast<CreatureObject*>(inv->getObjectParameter()));
		}
		break;
	case RPC_ADDMINEFIELD__BUILDINGOBJECT_SCENEOBJECT_:
		{
			addMinefield(static_cast<BuildingObject*>(inv->getObjectParameter()), static_cast<SceneObject*>(inv->getObjectParameter()));
		}
		break;
	case RPC_ADDTURRET__BUILDINGOBJECT_SCENEOBJECT_:
		{
			addTurret(static_cast<BuildingObject*>(inv->getObjectParameter()), static_cast<SceneObject*>(inv->getObjectParameter()));
		}
		break;
	case RPC_ADDSCANNER__BUILDINGOBJECT_SCENEOBJECT_:
		{
			addScanner(static_cast<BuildingObject*>(inv->getObjectParameter()), static_cast<SceneObject*>(inv->getObjectParameter()));
		}
		break;
	case RPC_REMOVEDEFENSE__BUILDINGOBJECT_CREATUREOBJECT_LONG_:
		{
			removeDefense(static_cast<BuildingObject*>(inv->getObjectParameter()), static_cast<CreatureObject*>(inv->getObjectParameter()), inv->getUnsignedLongParameter());
		}
		break;
	case RPC_CANUSETERMINALS__CREATUREOBJECT_BUILDINGOBJECT_SCENEOBJECT_:
		{
			resp->insertBoolean(canUseTerminals(static_cast<CreatureObject*>(inv->getObjectParameter()), static_cast<BuildingObject*>(inv->getObjectParameter()), static_cast<SceneObject*>(inv->getObjectParameter())));
		}
		break;
	case RPC_SENDTURRETATTACKLISTTO__CREATUREOBJECT_SCENEOBJECT_:
		{
			sendTurretAttackListTo(static_cast<CreatureObject*>(inv->getObjectParameter()), static_cast<SceneObject*>(inv->getObjectParameter()));
		}
		break;
	case RPC_GETIMPERIALBASECOUNT__:
		{
			resp->insertSignedInt(getImperialBaseCount());
		}
		break;
	case RPC_GETREBELBASECOUNT__:
		{
			resp->insertSignedInt(getRebelBaseCount());
		}
		break;
	default:
		throw Exception("Method does not exists");
	}
}

void GCWManagerAdapter::loadLuaConfig() {
	(static_cast<GCWManager*>(stub))->loadLuaConfig();
}

void GCWManagerAdapter::initialize() {
	(static_cast<GCWManager*>(stub))->initialize();
}

void GCWManagerAdapter::start() {
	(static_cast<GCWManager*>(stub))->start();
}

void GCWManagerAdapter::registerGCWBase(BuildingObject* building, bool initializeBase) {
	(static_cast<GCWManager*>(stub))->registerGCWBase(building, initializeBase);
}

void GCWManagerAdapter::unregisterGCWBase(BuildingObject* building) {
	(static_cast<GCWManager*>(stub))->unregisterGCWBase(building);
}

void GCWManagerAdapter::performGCWTasks() {
	(static_cast<GCWManager*>(stub))->performGCWTasks();
}

void GCWManagerAdapter::startVulnerability(BuildingObject* building) {
	(static_cast<GCWManager*>(stub))->startVulnerability(building);
}

void GCWManagerAdapter::endVulnerability(BuildingObject* building) {
	(static_cast<GCWManager*>(stub))->endVulnerability(building);
}

bool GCWManagerAdapter::isBaseVulnerable(BuildingObject* building) {
	return (static_cast<GCWManager*>(stub))->isBaseVulnerable(building);
}

bool GCWManagerAdapter::isBandIdentified(BuildingObject* building) {
	return (static_cast<GCWManager*>(stub))->isBandIdentified(building);
}

bool GCWManagerAdapter::isUplinkJammed(BuildingObject* building) {
	return (static_cast<GCWManager*>(stub))->isUplinkJammed(building);
}

bool GCWManagerAdapter::isShutdownSequenceStarted(BuildingObject* building) {
	return (static_cast<GCWManager*>(stub))->isShutdownSequenceStarted(building);
}

bool GCWManagerAdapter::isSecurityTermSliced(BuildingObject* building) {
	return (static_cast<GCWManager*>(stub))->isSecurityTermSliced(building);
}

bool GCWManagerAdapter::isPowerOverloaded(BuildingObject* building) {
	return (static_cast<GCWManager*>(stub))->isPowerOverloaded(building);
}

void GCWManagerAdapter::resetVulnerability(CreatureObject* creature, BuildingObject* building) {
	(static_cast<GCWManager*>(stub))->resetVulnerability(creature, building);
}

void GCWManagerAdapter::sendBaseDefenseStatus(CreatureObject* creature, BuildingObject* building) {
	(static_cast<GCWManager*>(stub))->sendBaseDefenseStatus(creature, building);
}

void GCWManagerAdapter::doBaseDestruction(StructureObject* structure) {
	(static_cast<GCWManager*>(stub))->doBaseDestruction(structure);
}

void GCWManagerAdapter::doBaseDestruction(BuildingObject* building) {
	(static_cast<GCWManager*>(stub))->doBaseDestruction(building);
}

void GCWManagerAdapter::sendResetVerification(CreatureObject* creature, BuildingObject* building) {
	(static_cast<GCWManager*>(stub))->sendResetVerification(creature, building);
}

void GCWManagerAdapter::sendJamUplinkMenu(CreatureObject* creature, BuildingObject* building) {
	(static_cast<GCWManager*>(stub))->sendJamUplinkMenu(creature, building);
}

void GCWManagerAdapter::verifyUplinkBand(CreatureObject* creature, BuildingObject* building, int band) {
	(static_cast<GCWManager*>(stub))->verifyUplinkBand(creature, building, band);
}

bool GCWManagerAdapter::canStartSlice(CreatureObject* creature, TangibleObject* terminal) {
	return (static_cast<GCWManager*>(stub))->canStartSlice(creature, terminal);
}

void GCWManagerAdapter::sendDNASampleMenu(CreatureObject* creature, BuildingObject* building) {
	(static_cast<GCWManager*>(stub))->sendDNASampleMenu(creature, building);
}

void GCWManagerAdapter::completeSecuritySlice(CreatureObject* creature, TangibleObject* securityTerminal) {
	(static_cast<GCWManager*>(stub))->completeSecuritySlice(creature, securityTerminal);
}

void GCWManagerAdapter::failSecuritySlice(TangibleObject* securityTerminal) {
	(static_cast<GCWManager*>(stub))->failSecuritySlice(securityTerminal);
}

bool GCWManagerAdapter::isTerminalDamaged(TangibleObject* securityTerminal) {
	return (static_cast<GCWManager*>(stub))->isTerminalDamaged(securityTerminal);
}

bool GCWManagerAdapter::isDNASampled(BuildingObject* building) {
	return (static_cast<GCWManager*>(stub))->isDNASampled(building);
}

void GCWManagerAdapter::repairTerminal(CreatureObject* creature, TangibleObject* securityTerminal) {
	(static_cast<GCWManager*>(stub))->repairTerminal(creature, securityTerminal);
}

void GCWManagerAdapter::abortShutdownSequence(CreatureObject* creature, BuildingObject* building) {
	(static_cast<GCWManager*>(stub))->abortShutdownSequence(creature, building);
}

void GCWManagerAdapter::processDNASample(CreatureObject* creature, BuildingObject* building, int indx) {
	(static_cast<GCWManager*>(stub))->processDNASample(creature, building, indx);
}

void GCWManagerAdapter::handlePowerRegulatorSwitch(CreatureObject* creature, BuildingObject* building, int indx) {
	(static_cast<GCWManager*>(stub))->handlePowerRegulatorSwitch(creature, building, indx);
}

void GCWManagerAdapter::sendPowerRegulatorControls(CreatureObject* creature, BuildingObject* building) {
	(static_cast<GCWManager*>(stub))->sendPowerRegulatorControls(creature, building);
}

String GCWManagerAdapter::getDNAHash(const String& usersample) {
	return (static_cast<GCWManager*>(stub))->getDNAHash(usersample);
}

bool GCWManagerAdapter::isPlanetCapped() {
	return (static_cast<GCWManager*>(stub))->isPlanetCapped();
}

void GCWManagerAdapter::scheduleBaseDestruction(BuildingObject* building, CreatureObject* creature) {
	(static_cast<GCWManager*>(stub))->scheduleBaseDestruction(building, creature);
}

void GCWManagerAdapter::notifyTurretDestruction(InstallationObject* turret) {
	(static_cast<GCWManager*>(stub))->notifyTurretDestruction(turret);
}

void GCWManagerAdapter::sendSelectTurretToDonate(BuildingObject* building, CreatureObject* creature) {
	(static_cast<GCWManager*>(stub))->sendSelectTurretToDonate(building, creature);
}

void GCWManagerAdapter::sendSelectDeedToDonate(BuildingObject* building, CreatureObject* creature, int turretIndex) {
	(static_cast<GCWManager*>(stub))->sendSelectDeedToDonate(building, creature, turretIndex);
}

void GCWManagerAdapter::sendRemoveDefenseConfirmation(BuildingObject* building, CreatureObject* creature, unsigned long long deedOID) {
	(static_cast<GCWManager*>(stub))->sendRemoveDefenseConfirmation(building, creature, deedOID);
}

void GCWManagerAdapter::performDefenseDontation(BuildingObject* building, CreatureObject* creature, unsigned long long deedOID, int turretIndex) {
	(static_cast<GCWManager*>(stub))->performDefenseDontation(building, creature, deedOID, turretIndex);
}

void GCWManagerAdapter::sendStatus(BuildingObject* building, CreatureObject* creature) {
	(static_cast<GCWManager*>(stub))->sendStatus(building, creature);
}

void GCWManagerAdapter::addMinefield(BuildingObject* building, SceneObject* minefield) {
	(static_cast<GCWManager*>(stub))->addMinefield(building, minefield);
}

void GCWManagerAdapter::addTurret(BuildingObject* building, SceneObject* turret) {
	(static_cast<GCWManager*>(stub))->addTurret(building, turret);
}

void GCWManagerAdapter::addScanner(BuildingObject* building, SceneObject* scanner) {
	(static_cast<GCWManager*>(stub))->addScanner(building, scanner);
}

void GCWManagerAdapter::removeDefense(BuildingObject* building, CreatureObject* creature, unsigned long long deedOID) {
	(static_cast<GCWManager*>(stub))->removeDefense(building, creature, deedOID);
}

bool GCWManagerAdapter::canUseTerminals(CreatureObject* creature, BuildingObject* building, SceneObject* terminal) {
	return (static_cast<GCWManager*>(stub))->canUseTerminals(creature, building, terminal);
}

void GCWManagerAdapter::sendTurretAttackListTo(CreatureObject* creature, SceneObject* turretControlTerminal) {
	(static_cast<GCWManager*>(stub))->sendTurretAttackListTo(creature, turretControlTerminal);
}

int GCWManagerAdapter::getImperialBaseCount() {
	return (static_cast<GCWManager*>(stub))->getImperialBaseCount();
}

int GCWManagerAdapter::getRebelBaseCount() {
	return (static_cast<GCWManager*>(stub))->getRebelBaseCount();
}

/*
 *	GCWManagerHelper
 */

GCWManagerHelper* GCWManagerHelper::staticInitializer = GCWManagerHelper::instance();

GCWManagerHelper::GCWManagerHelper() {
	className = "GCWManager";

	Core::getObjectBroker()->registerClass(className, this);
}

void GCWManagerHelper::finalizeHelper() {
	GCWManagerHelper::finalize();
}

DistributedObject* GCWManagerHelper::instantiateObject() {
	return new GCWManager(DummyConstructorParameter::instance());
}

DistributedObjectServant* GCWManagerHelper::instantiateServant() {
	return new GCWManagerImplementation(DummyConstructorParameter::instance());
}

DistributedObjectAdapter* GCWManagerHelper::createAdapter(DistributedObjectStub* obj) {
	DistributedObjectAdapter* adapter = new GCWManagerAdapter(static_cast<GCWManager*>(obj));

	obj->_setClassName(className);
	obj->_setClassHelper(this);

	adapter->setStub(obj);

	return adapter;
}

