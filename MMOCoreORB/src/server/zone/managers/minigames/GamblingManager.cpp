/*
 *	server/zone/managers/minigames/GamblingManager.cpp generated by engine3 IDL compiler 0.60
 */

#include "GamblingManager.h"

#include "server/zone/objects/creature/CreatureObject.h"

#include "server/zone/ZoneServer.h"

#include "server/zone/Zone.h"

#include "server/zone/objects/scene/SceneObject.h"

#include "server/zone/objects/tangible/terminal/gambling/GamblingTerminal.h"

#include "server/zone/managers/minigames/events/GamblingEvent.h"

/*
 *	GamblingManagerStub
 */

enum {RPC_INITIALIZESLOTTIMER__,RPC_INITIALIZEROULETTETIMER__,RPC_INITIALIZESLOTS__,RPC_INITIALIZEROULETTERED__,RPC_INITIALIZEROULETTE__,RPC_NOTIFY__SCENEOBJECT_,RPC_ISHIGH__INT_,RPC_ISLOW__INT_,RPC_ISEVEN__INT_,RPC_ISODD__INT_,RPC_ISBLACK__INT_,RPC_ISRED__INT_,RPC_HANDLESLOT__CREATUREOBJECT_BOOL_BOOL_,RPC_BET__CREATUREOBJECT_INT_INT_INT_,RPC_BET__GAMBLINGTERMINAL_CREATUREOBJECT_INT_INT_,RPC_STARTGAME__CREATUREOBJECT_INT_,RPC_STARTGAME__GAMBLINGTERMINAL_,RPC_LEAVETERMINAL__CREATUREOBJECT_INT_,RPC_REGISTERPLAYER__GAMBLINGTERMINAL_CREATUREOBJECT_,RPC_REFRESHROULETTEMENU__CREATUREOBJECT_,RPC_CONTINUEGAME__GAMBLINGTERMINAL_,RPC_STOPGAME__GAMBLINGTERMINAL_BOOL_,RPC_CALCULATEOUTCOME__GAMBLINGTERMINAL_,RPC_CREATEWINDOW__GAMBLINGTERMINAL_CREATUREOBJECT_,RPC_CREATEPAYOUTWINDOW__CREATUREOBJECT_,RPC_CREATESLOTWINDOW__CREATUREOBJECT_INT_,RPC_CREATEROULETTEWINDOW__CREATUREOBJECT_,RPC_CREATEEVENT__GAMBLINGTERMINAL_INT_,RPC_ISPLAYING__CREATUREOBJECT_};

GamblingManager::GamblingManager() : Observer(DummyConstructorParameter::instance()) {
	GamblingManagerImplementation* _implementation = new GamblingManagerImplementation();
	_impl = _implementation;
	_impl->_setStub(this);
	_setClassName("GamblingManager");
}

GamblingManager::GamblingManager(DummyConstructorParameter* param) : Observer(param) {
	_setClassName("GamblingManager");
}

GamblingManager::~GamblingManager() {
}



Vector<String>* GamblingManager::getRoulette() {
	GamblingManagerImplementation* _implementation = static_cast<GamblingManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		return _implementation->getRoulette();
}

void GamblingManager::initializeSlotTimer() {
	GamblingManagerImplementation* _implementation = static_cast<GamblingManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INITIALIZESLOTTIMER__);

		method.executeWithVoidReturn();
	} else
		_implementation->initializeSlotTimer();
}

void GamblingManager::initializeRouletteTimer() {
	GamblingManagerImplementation* _implementation = static_cast<GamblingManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INITIALIZEROULETTETIMER__);

		method.executeWithVoidReturn();
	} else
		_implementation->initializeRouletteTimer();
}

void GamblingManager::initializeSlots() {
	GamblingManagerImplementation* _implementation = static_cast<GamblingManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INITIALIZESLOTS__);

		method.executeWithVoidReturn();
	} else
		_implementation->initializeSlots();
}

void GamblingManager::initializeRouletteRed() {
	GamblingManagerImplementation* _implementation = static_cast<GamblingManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INITIALIZEROULETTERED__);

		method.executeWithVoidReturn();
	} else
		_implementation->initializeRouletteRed();
}

void GamblingManager::initializeRoulette() {
	GamblingManagerImplementation* _implementation = static_cast<GamblingManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INITIALIZEROULETTE__);

		method.executeWithVoidReturn();
	} else
		_implementation->initializeRoulette();
}

int GamblingManager::notify(SceneObject* sceneObject) {
	GamblingManagerImplementation* _implementation = static_cast<GamblingManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFY__SCENEOBJECT_);
		method.addObjectParameter(sceneObject);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->notify(sceneObject);
}

bool GamblingManager::isHigh(int value) {
	GamblingManagerImplementation* _implementation = static_cast<GamblingManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISHIGH__INT_);
		method.addSignedIntParameter(value);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isHigh(value);
}

bool GamblingManager::isLow(int value) {
	GamblingManagerImplementation* _implementation = static_cast<GamblingManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISLOW__INT_);
		method.addSignedIntParameter(value);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isLow(value);
}

bool GamblingManager::isEven(int value) {
	GamblingManagerImplementation* _implementation = static_cast<GamblingManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISEVEN__INT_);
		method.addSignedIntParameter(value);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isEven(value);
}

bool GamblingManager::isOdd(int value) {
	GamblingManagerImplementation* _implementation = static_cast<GamblingManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISODD__INT_);
		method.addSignedIntParameter(value);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isOdd(value);
}

bool GamblingManager::isBlack(int value) {
	GamblingManagerImplementation* _implementation = static_cast<GamblingManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISBLACK__INT_);
		method.addSignedIntParameter(value);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isBlack(value);
}

bool GamblingManager::isRed(int value) {
	GamblingManagerImplementation* _implementation = static_cast<GamblingManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISRED__INT_);
		method.addSignedIntParameter(value);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isRed(value);
}

void GamblingManager::handleSlot(CreatureObject* player, bool cancel, bool other) {
	GamblingManagerImplementation* _implementation = static_cast<GamblingManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HANDLESLOT__CREATUREOBJECT_BOOL_BOOL_);
		method.addObjectParameter(player);
		method.addBooleanParameter(cancel);
		method.addBooleanParameter(other);

		method.executeWithVoidReturn();
	} else
		_implementation->handleSlot(player, cancel, other);
}

void GamblingManager::bet(CreatureObject* player, int amount, int target, int machineType) {
	GamblingManagerImplementation* _implementation = static_cast<GamblingManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_BET__CREATUREOBJECT_INT_INT_INT_);
		method.addObjectParameter(player);
		method.addSignedIntParameter(amount);
		method.addSignedIntParameter(target);
		method.addSignedIntParameter(machineType);

		method.executeWithVoidReturn();
	} else
		_implementation->bet(player, amount, target, machineType);
}

void GamblingManager::bet(GamblingTerminal* terminal, CreatureObject* player, int amount, int target) {
	GamblingManagerImplementation* _implementation = static_cast<GamblingManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_BET__GAMBLINGTERMINAL_CREATUREOBJECT_INT_INT_);
		method.addObjectParameter(terminal);
		method.addObjectParameter(player);
		method.addSignedIntParameter(amount);
		method.addSignedIntParameter(target);

		method.executeWithVoidReturn();
	} else
		_implementation->bet(terminal, player, amount, target);
}

void GamblingManager::startGame(CreatureObject* player, int machineType) {
	GamblingManagerImplementation* _implementation = static_cast<GamblingManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_STARTGAME__CREATUREOBJECT_INT_);
		method.addObjectParameter(player);
		method.addSignedIntParameter(machineType);

		method.executeWithVoidReturn();
	} else
		_implementation->startGame(player, machineType);
}

void GamblingManager::startGame(GamblingTerminal* terminal) {
	GamblingManagerImplementation* _implementation = static_cast<GamblingManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_STARTGAME__GAMBLINGTERMINAL_);
		method.addObjectParameter(terminal);

		method.executeWithVoidReturn();
	} else
		_implementation->startGame(terminal);
}

void GamblingManager::leaveTerminal(CreatureObject* player, int machineType) {
	GamblingManagerImplementation* _implementation = static_cast<GamblingManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_LEAVETERMINAL__CREATUREOBJECT_INT_);
		method.addObjectParameter(player);
		method.addSignedIntParameter(machineType);

		method.executeWithVoidReturn();
	} else
		_implementation->leaveTerminal(player, machineType);
}

void GamblingManager::registerPlayer(GamblingTerminal* terminal, CreatureObject* player) {
	GamblingManagerImplementation* _implementation = static_cast<GamblingManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REGISTERPLAYER__GAMBLINGTERMINAL_CREATUREOBJECT_);
		method.addObjectParameter(terminal);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else
		_implementation->registerPlayer(terminal, player);
}

void GamblingManager::refreshRouletteMenu(CreatureObject* player) {
	GamblingManagerImplementation* _implementation = static_cast<GamblingManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REFRESHROULETTEMENU__CREATUREOBJECT_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else
		_implementation->refreshRouletteMenu(player);
}

void GamblingManager::continueGame(GamblingTerminal* terminal) {
	GamblingManagerImplementation* _implementation = static_cast<GamblingManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CONTINUEGAME__GAMBLINGTERMINAL_);
		method.addObjectParameter(terminal);

		method.executeWithVoidReturn();
	} else
		_implementation->continueGame(terminal);
}

void GamblingManager::stopGame(GamblingTerminal* terminal, bool cancel) {
	GamblingManagerImplementation* _implementation = static_cast<GamblingManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_STOPGAME__GAMBLINGTERMINAL_BOOL_);
		method.addObjectParameter(terminal);
		method.addBooleanParameter(cancel);

		method.executeWithVoidReturn();
	} else
		_implementation->stopGame(terminal, cancel);
}

void GamblingManager::calculateOutcome(GamblingTerminal* terminal) {
	GamblingManagerImplementation* _implementation = static_cast<GamblingManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CALCULATEOUTCOME__GAMBLINGTERMINAL_);
		method.addObjectParameter(terminal);

		method.executeWithVoidReturn();
	} else
		_implementation->calculateOutcome(terminal);
}

unsigned int GamblingManager::createWindow(GamblingTerminal* terminal, CreatureObject* player) {
	GamblingManagerImplementation* _implementation = static_cast<GamblingManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CREATEWINDOW__GAMBLINGTERMINAL_CREATUREOBJECT_);
		method.addObjectParameter(terminal);
		method.addObjectParameter(player);

		return method.executeWithUnsignedIntReturn();
	} else
		return _implementation->createWindow(terminal, player);
}

unsigned int GamblingManager::createPayoutWindow(CreatureObject* player) {
	GamblingManagerImplementation* _implementation = static_cast<GamblingManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CREATEPAYOUTWINDOW__CREATUREOBJECT_);
		method.addObjectParameter(player);

		return method.executeWithUnsignedIntReturn();
	} else
		return _implementation->createPayoutWindow(player);
}

unsigned int GamblingManager::createSlotWindow(CreatureObject* player, unsigned int payoutBoxID) {
	GamblingManagerImplementation* _implementation = static_cast<GamblingManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CREATESLOTWINDOW__CREATUREOBJECT_INT_);
		method.addObjectParameter(player);
		method.addUnsignedIntParameter(payoutBoxID);

		return method.executeWithUnsignedIntReturn();
	} else
		return _implementation->createSlotWindow(player, payoutBoxID);
}

unsigned int GamblingManager::createRouletteWindow(CreatureObject* player) {
	GamblingManagerImplementation* _implementation = static_cast<GamblingManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CREATEROULETTEWINDOW__CREATUREOBJECT_);
		method.addObjectParameter(player);

		return method.executeWithUnsignedIntReturn();
	} else
		return _implementation->createRouletteWindow(player);
}

void GamblingManager::createEvent(GamblingTerminal* terminal, int time) {
	GamblingManagerImplementation* _implementation = static_cast<GamblingManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CREATEEVENT__GAMBLINGTERMINAL_INT_);
		method.addObjectParameter(terminal);
		method.addSignedIntParameter(time);

		method.executeWithVoidReturn();
	} else
		_implementation->createEvent(terminal, time);
}

bool GamblingManager::isPlaying(CreatureObject* player) {
	GamblingManagerImplementation* _implementation = static_cast<GamblingManagerImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISPLAYING__CREATUREOBJECT_);
		method.addObjectParameter(player);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isPlaying(player);
}

DistributedObjectServant* GamblingManager::_getImplementation() {

	 if (!_updated) _updated = true;
	return _impl;
}

void GamblingManager::_setImplementation(DistributedObjectServant* servant) {
	_impl = servant;
}

/*
 *	GamblingManagerImplementation
 */

GamblingManagerImplementation::GamblingManagerImplementation(DummyConstructorParameter* param) : ObserverImplementation(param) {
	_initializeImplementation();
}


GamblingManagerImplementation::~GamblingManagerImplementation() {
}


void GamblingManagerImplementation::finalize() {
}

void GamblingManagerImplementation::_initializeImplementation() {
	_setClassHelper(GamblingManagerHelper::instance());

	_this = NULL;

	_serializationHelperMethod();
}

void GamblingManagerImplementation::_setStub(DistributedObjectStub* stub) {
	_this = static_cast<GamblingManager*>(stub);
	ObserverImplementation::_setStub(stub);
}

DistributedObjectStub* GamblingManagerImplementation::_getStub() {
	return _this.get();
}

GamblingManagerImplementation::operator const GamblingManager*() {
	return _this.get();
}

void GamblingManagerImplementation::lock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->lock(doLock);
}

void GamblingManagerImplementation::lock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->lock(obj);
}

void GamblingManagerImplementation::rlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->rlock(doLock);
}

void GamblingManagerImplementation::wlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->wlock(doLock);
}

void GamblingManagerImplementation::wlock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->wlock(obj);
}

void GamblingManagerImplementation::unlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->unlock(doLock);
}

void GamblingManagerImplementation::runlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->runlock(doLock);
}

void GamblingManagerImplementation::_serializationHelperMethod() {
	ObserverImplementation::_serializationHelperMethod();

	_setClassName("GamblingManager");

}

void GamblingManagerImplementation::readObject(ObjectInputStream* stream) {
	uint16 _varCount = stream->readShort();
	for (int i = 0; i < _varCount; ++i) {
		String _name;
		_name.parseFromBinaryStream(stream);

		uint32 _varSize = stream->readInt();

		int _currentOffset = stream->getOffset();

		if(GamblingManagerImplementation::readObjectMember(stream, _name)) {
		}

		stream->setOffset(_currentOffset + _varSize);
	}

	initializeTransientMembers();
}

bool GamblingManagerImplementation::readObjectMember(ObjectInputStream* stream, const String& _name) {
	if (ObserverImplementation::readObjectMember(stream, _name))
		return true;

	if (_name == "GamblingManager.slotGames") {
		TypeInfo<VectorMap<ManagedReference<CreatureObject* >, ManagedReference<GamblingTerminal* > > >::parseFromBinaryStream(&slotGames, stream);
		return true;
	}

	if (_name == "GamblingManager.rouletteGames") {
		TypeInfo<VectorMap<ManagedReference<CreatureObject* >, ManagedReference<GamblingTerminal* > > >::parseFromBinaryStream(&rouletteGames, stream);
		return true;
	}

	if (_name == "GamblingManager.roulette") {
		TypeInfo<Vector<String> >::parseFromBinaryStream(&roulette, stream);
		return true;
	}

	if (_name == "GamblingManager.red") {
		TypeInfo<Vector<String> >::parseFromBinaryStream(&red, stream);
		return true;
	}

	if (_name == "GamblingManager.slot") {
		TypeInfo<Vector<int> >::parseFromBinaryStream(&slot, stream);
		return true;
	}

	if (_name == "GamblingManager.slotTimer") {
		TypeInfo<Vector<int> >::parseFromBinaryStream(&slotTimer, stream);
		return true;
	}

	if (_name == "GamblingManager.rouletteTimer") {
		TypeInfo<Vector<int> >::parseFromBinaryStream(&rouletteTimer, stream);
		return true;
	}


	return false;
}

void GamblingManagerImplementation::writeObject(ObjectOutputStream* stream) {
	int _currentOffset = stream->getOffset();
	stream->writeShort(0);
	int _varCount = GamblingManagerImplementation::writeObjectMembers(stream);
	stream->writeShort(_currentOffset, _varCount);
}

int GamblingManagerImplementation::writeObjectMembers(ObjectOutputStream* stream) {
	int _count = ObserverImplementation::writeObjectMembers(stream);

	String _name;
	int _offset;
	uint32 _totalSize;
	_name = "GamblingManager.slotGames";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<VectorMap<ManagedReference<CreatureObject* >, ManagedReference<GamblingTerminal* > > >::toBinaryStream(&slotGames, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_name = "GamblingManager.rouletteGames";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<VectorMap<ManagedReference<CreatureObject* >, ManagedReference<GamblingTerminal* > > >::toBinaryStream(&rouletteGames, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_name = "GamblingManager.roulette";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Vector<String> >::toBinaryStream(&roulette, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_name = "GamblingManager.red";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Vector<String> >::toBinaryStream(&red, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_name = "GamblingManager.slot";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Vector<int> >::toBinaryStream(&slot, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_name = "GamblingManager.slotTimer";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Vector<int> >::toBinaryStream(&slotTimer, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);

	_name = "GamblingManager.rouletteTimer";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Vector<int> >::toBinaryStream(&rouletteTimer, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);


	return _count + 7;
}

GamblingManagerImplementation::GamblingManagerImplementation() {
	_initializeImplementation();
	// server/zone/managers/minigames/GamblingManager.idl():  		initializeRoulette();
	initializeRoulette();
	// server/zone/managers/minigames/GamblingManager.idl():  		initializeRouletteRed();
	initializeRouletteRed();
	// server/zone/managers/minigames/GamblingManager.idl():  		initializeSlots();
	initializeSlots();
	// server/zone/managers/minigames/GamblingManager.idl():  		initializeSlotTimer();
	initializeSlotTimer();
	// server/zone/managers/minigames/GamblingManager.idl():  		initializeRouletteTimer();
	initializeRouletteTimer();
	// server/zone/managers/minigames/GamblingManager.idl():  		Logger.setLoggingName("GamblingManager");
	Logger::setLoggingName("GamblingManager");
	// server/zone/managers/minigames/GamblingManager.idl():  		Logger.setLogging(true);
	Logger::setLogging(true);
}

Vector<String>* GamblingManagerImplementation::getRoulette() {
	// server/zone/managers/minigames/GamblingManager.idl():  		return roulette;
	return (&roulette);
}

void GamblingManagerImplementation::initializeSlotTimer() {
	// server/zone/managers/minigames/GamblingManager.idl():  		slotTimer.add(6);
	(&slotTimer)->add(6);
	// server/zone/managers/minigames/GamblingManager.idl():  		slotTimer.add(4);
	(&slotTimer)->add(4);
	// server/zone/managers/minigames/GamblingManager.idl():  		slotTimer.add(4);
	(&slotTimer)->add(4);
	// server/zone/managers/minigames/GamblingManager.idl():  		slotTimer.add(4);
	(&slotTimer)->add(4);
	// server/zone/managers/minigames/GamblingManager.idl():  		slotTimer.add(1);
	(&slotTimer)->add(1);
	// server/zone/managers/minigames/GamblingManager.idl():  		slotTimer.add(1);
	(&slotTimer)->add(1);
}

void GamblingManagerImplementation::initializeRouletteTimer() {
	// server/zone/managers/minigames/GamblingManager.idl():  		rouletteTimer.add(30);
	(&rouletteTimer)->add(30);
	// server/zone/managers/minigames/GamblingManager.idl():  		rouletteTimer.add(30);
	(&rouletteTimer)->add(30);
	// server/zone/managers/minigames/GamblingManager.idl():  		rouletteTimer.add(30);
	(&rouletteTimer)->add(30);
	// server/zone/managers/minigames/GamblingManager.idl():  		rouletteTimer.add(10);
	(&rouletteTimer)->add(10);
	// server/zone/managers/minigames/GamblingManager.idl():  		rouletteTimer.add(5);
	(&rouletteTimer)->add(5);
	// server/zone/managers/minigames/GamblingManager.idl():  		rouletteTimer.add(5);
	(&rouletteTimer)->add(5);
	// server/zone/managers/minigames/GamblingManager.idl():  		rouletteTimer.add(5);
	(&rouletteTimer)->add(5);
	// server/zone/managers/minigames/GamblingManager.idl():  		rouletteTimer.add(5);
	(&rouletteTimer)->add(5);
	// server/zone/managers/minigames/GamblingManager.idl():  		rouletteTimer.add(10);
	(&rouletteTimer)->add(10);
	// server/zone/managers/minigames/GamblingManager.idl():  		rouletteTimer.add(5);
	(&rouletteTimer)->add(5);
	// server/zone/managers/minigames/GamblingManager.idl():  		rouletteTimer.add(5);
	(&rouletteTimer)->add(5);
	// server/zone/managers/minigames/GamblingManager.idl():  		rouletteTimer.add(2);
	(&rouletteTimer)->add(2);
}

void GamblingManagerImplementation::initializeSlots() {
	// server/zone/managers/minigames/GamblingManager.idl():  		slot.add(4);
	(&slot)->add(4);
	// server/zone/managers/minigames/GamblingManager.idl():  		slot.add(50);
	(&slot)->add(50);
	// server/zone/managers/minigames/GamblingManager.idl():  		slot.add(75);
	(&slot)->add(75);
	// server/zone/managers/minigames/GamblingManager.idl():  		slot.add(100);
	(&slot)->add(100);
	// server/zone/managers/minigames/GamblingManager.idl():  		slot.add(250);
	(&slot)->add(250);
	// server/zone/managers/minigames/GamblingManager.idl():  		slot.add(500);
	(&slot)->add(500);
	// server/zone/managers/minigames/GamblingManager.idl():  		slot.add(1000);
	(&slot)->add(1000);
	// server/zone/managers/minigames/GamblingManager.idl():  		slot.add(1500);
	(&slot)->add(1500);
}

void GamblingManagerImplementation::initializeRouletteRed() {
	// server/zone/managers/minigames/GamblingManager.idl():  		red.add("1");
	(&red)->add("1");
	// server/zone/managers/minigames/GamblingManager.idl():  		red.add("3");
	(&red)->add("3");
	// server/zone/managers/minigames/GamblingManager.idl():  		red.add("5");
	(&red)->add("5");
	// server/zone/managers/minigames/GamblingManager.idl():  		red.add("7");
	(&red)->add("7");
	// server/zone/managers/minigames/GamblingManager.idl():  		red.add("9");
	(&red)->add("9");
	// server/zone/managers/minigames/GamblingManager.idl():  		red.add("12");
	(&red)->add("12");
	// server/zone/managers/minigames/GamblingManager.idl():  		red.add("14");
	(&red)->add("14");
	// server/zone/managers/minigames/GamblingManager.idl():  		red.add("16");
	(&red)->add("16");
	// server/zone/managers/minigames/GamblingManager.idl():  		red.add("18");
	(&red)->add("18");
	// server/zone/managers/minigames/GamblingManager.idl():  		red.add("19");
	(&red)->add("19");
	// server/zone/managers/minigames/GamblingManager.idl():  		red.add("21");
	(&red)->add("21");
	// server/zone/managers/minigames/GamblingManager.idl():  		red.add("23");
	(&red)->add("23");
	// server/zone/managers/minigames/GamblingManager.idl():  		red.add("25");
	(&red)->add("25");
	// server/zone/managers/minigames/GamblingManager.idl():  		red.add("27");
	(&red)->add("27");
	// server/zone/managers/minigames/GamblingManager.idl():  		red.add("30");
	(&red)->add("30");
	// server/zone/managers/minigames/GamblingManager.idl():  		red.add("32");
	(&red)->add("32");
	// server/zone/managers/minigames/GamblingManager.idl():  		red.add("34");
	(&red)->add("34");
	// server/zone/managers/minigames/GamblingManager.idl():  		red.add("36");
	(&red)->add("36");
}

void GamblingManagerImplementation::initializeRoulette() {
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("0");
	(&roulette)->add("0");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("1");
	(&roulette)->add("1");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("2");
	(&roulette)->add("2");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("3");
	(&roulette)->add("3");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("4");
	(&roulette)->add("4");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("5");
	(&roulette)->add("5");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("6");
	(&roulette)->add("6");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("7");
	(&roulette)->add("7");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("8");
	(&roulette)->add("8");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("9");
	(&roulette)->add("9");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("10");
	(&roulette)->add("10");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("11");
	(&roulette)->add("11");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("12");
	(&roulette)->add("12");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("13");
	(&roulette)->add("13");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("14");
	(&roulette)->add("14");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("15");
	(&roulette)->add("15");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("16");
	(&roulette)->add("16");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("17");
	(&roulette)->add("17");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("18");
	(&roulette)->add("18");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("19");
	(&roulette)->add("19");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("20");
	(&roulette)->add("20");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("21");
	(&roulette)->add("21");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("22");
	(&roulette)->add("22");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("23");
	(&roulette)->add("23");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("24");
	(&roulette)->add("24");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("25");
	(&roulette)->add("25");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("26");
	(&roulette)->add("26");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("27");
	(&roulette)->add("27");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("28");
	(&roulette)->add("28");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("29");
	(&roulette)->add("29");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("30");
	(&roulette)->add("30");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("31");
	(&roulette)->add("31");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("32");
	(&roulette)->add("32");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("33");
	(&roulette)->add("33");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("34");
	(&roulette)->add("34");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("35");
	(&roulette)->add("35");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("36");
	(&roulette)->add("36");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("00");
	(&roulette)->add("00");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("odd");
	(&roulette)->add("odd");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("even");
	(&roulette)->add("even");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("high");
	(&roulette)->add("high");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("low");
	(&roulette)->add("low");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("red");
	(&roulette)->add("red");
	// server/zone/managers/minigames/GamblingManager.idl():  		roulette.add("black");
	(&roulette)->add("black");
}

int GamblingManagerImplementation::notify(SceneObject* sceneObject) {
	// server/zone/managers/minigames/GamblingManager.idl():  		return 
	if (sceneObject->isCreatureObject())	// server/zone/managers/minigames/GamblingManager.idl():  			return 1;
	return 1;
	// server/zone/managers/minigames/GamblingManager.idl():  		return 0;
	return 0;
}

bool GamblingManagerImplementation::isHigh(int value) {
	// server/zone/managers/minigames/GamblingManager.idl():  		return 
	if ((value > 18) && (value != 37))	// server/zone/managers/minigames/GamblingManager.idl():  			return true;
	return true;
	// server/zone/managers/minigames/GamblingManager.idl():  		return false;
	return false;
}

bool GamblingManagerImplementation::isLow(int value) {
	// server/zone/managers/minigames/GamblingManager.idl():  		return 
	if ((value > 0) && (value < 19))	// server/zone/managers/minigames/GamblingManager.idl():  			return true;
	return true;
	// server/zone/managers/minigames/GamblingManager.idl():  		return false;
	return false;
}

bool GamblingManagerImplementation::isEven(int value) {
	// server/zone/managers/minigames/GamblingManager.idl():  		if 
	if ((value == 0) || (value == 37))	// server/zone/managers/minigames/GamblingManager.idl():  			return false;
	return false;
	// server/zone/managers/minigames/GamblingManager.idl():  		return 
	if ((value % 2) == 0)	// server/zone/managers/minigames/GamblingManager.idl():  			return true;
	return true;
	// server/zone/managers/minigames/GamblingManager.idl():  		return false;
	return false;
}

bool GamblingManagerImplementation::isOdd(int value) {
	// server/zone/managers/minigames/GamblingManager.idl():  		if 
	if ((value == 0) || (value == 37))	// server/zone/managers/minigames/GamblingManager.idl():  			return false;
	return false;
	// server/zone/managers/minigames/GamblingManager.idl():  		return 
	if ((value % 2) == 1)	// server/zone/managers/minigames/GamblingManager.idl():  			return true;
	return true;
	// server/zone/managers/minigames/GamblingManager.idl():  		return false;
	return false;
}

bool GamblingManagerImplementation::isBlack(int value) {
	// server/zone/managers/minigames/GamblingManager.idl():  		if 
	if ((&roulette)->get(value) == "0" || (&roulette)->get(value) == "00")	// server/zone/managers/minigames/GamblingManager.idl():  			return false;
	return false;
	// server/zone/managers/minigames/GamblingManager.idl():  		return 
	if (isRed(value))	// server/zone/managers/minigames/GamblingManager.idl():  			return false;
	return false;
	// server/zone/managers/minigames/GamblingManager.idl():  		return true;
	return true;
}

bool GamblingManagerImplementation::isRed(int value) {
	// server/zone/managers/minigames/GamblingManager.idl():  		for 
	if ((&roulette)->get(value) == "0" || (&roulette)->get(value) == "00")	// server/zone/managers/minigames/GamblingManager.idl():  			return false;
	return false;
	// server/zone/managers/minigames/GamblingManager.idl():  		}
	for (	// server/zone/managers/minigames/GamblingManager.idl():  		for (int i = 0;
	int i = 0;
	i < (&red)->size();
 ++i) {
	// server/zone/managers/minigames/GamblingManager.idl():  		}
	if ((&red)->get(i) == (&roulette)->get(value)){
	// server/zone/managers/minigames/GamblingManager.idl():  				return true;
	return true;
}
}
	// server/zone/managers/minigames/GamblingManager.idl():  		return false;
	return false;
}

bool GamblingManagerImplementation::isPlaying(CreatureObject* player) {
	// server/zone/managers/minigames/GamblingManager.idl():  		return (slotGames.contains(player) || rouletteGames.contains(player));
	return ((&slotGames)->contains(player) || (&rouletteGames)->contains(player));
}

/*
 *	GamblingManagerAdapter
 */


#include "engine/orb/messages/InvokeMethodMessage.h"


GamblingManagerAdapter::GamblingManagerAdapter(GamblingManager* obj) : ObserverAdapter(obj) {
}

void GamblingManagerAdapter::invokeMethod(uint32 methid, DistributedMethod* inv) {
	DOBMessage* resp = inv->getInvocationMessage();

	switch (methid) {
	case RPC_INITIALIZESLOTTIMER__:
		{
			initializeSlotTimer();
		}
		break;
	case RPC_INITIALIZEROULETTETIMER__:
		{
			initializeRouletteTimer();
		}
		break;
	case RPC_INITIALIZESLOTS__:
		{
			initializeSlots();
		}
		break;
	case RPC_INITIALIZEROULETTERED__:
		{
			initializeRouletteRed();
		}
		break;
	case RPC_INITIALIZEROULETTE__:
		{
			initializeRoulette();
		}
		break;
	case RPC_NOTIFY__SCENEOBJECT_:
		{
			resp->insertSignedInt(notify(static_cast<SceneObject*>(inv->getObjectParameter())));
		}
		break;
	case RPC_ISHIGH__INT_:
		{
			resp->insertBoolean(isHigh(inv->getSignedIntParameter()));
		}
		break;
	case RPC_ISLOW__INT_:
		{
			resp->insertBoolean(isLow(inv->getSignedIntParameter()));
		}
		break;
	case RPC_ISEVEN__INT_:
		{
			resp->insertBoolean(isEven(inv->getSignedIntParameter()));
		}
		break;
	case RPC_ISODD__INT_:
		{
			resp->insertBoolean(isOdd(inv->getSignedIntParameter()));
		}
		break;
	case RPC_ISBLACK__INT_:
		{
			resp->insertBoolean(isBlack(inv->getSignedIntParameter()));
		}
		break;
	case RPC_ISRED__INT_:
		{
			resp->insertBoolean(isRed(inv->getSignedIntParameter()));
		}
		break;
	case RPC_HANDLESLOT__CREATUREOBJECT_BOOL_BOOL_:
		{
			handleSlot(static_cast<CreatureObject*>(inv->getObjectParameter()), inv->getBooleanParameter(), inv->getBooleanParameter());
		}
		break;
	case RPC_BET__CREATUREOBJECT_INT_INT_INT_:
		{
			bet(static_cast<CreatureObject*>(inv->getObjectParameter()), inv->getSignedIntParameter(), inv->getSignedIntParameter(), inv->getSignedIntParameter());
		}
		break;
	case RPC_BET__GAMBLINGTERMINAL_CREATUREOBJECT_INT_INT_:
		{
			bet(static_cast<GamblingTerminal*>(inv->getObjectParameter()), static_cast<CreatureObject*>(inv->getObjectParameter()), inv->getSignedIntParameter(), inv->getSignedIntParameter());
		}
		break;
	case RPC_STARTGAME__CREATUREOBJECT_INT_:
		{
			startGame(static_cast<CreatureObject*>(inv->getObjectParameter()), inv->getSignedIntParameter());
		}
		break;
	case RPC_STARTGAME__GAMBLINGTERMINAL_:
		{
			startGame(static_cast<GamblingTerminal*>(inv->getObjectParameter()));
		}
		break;
	case RPC_LEAVETERMINAL__CREATUREOBJECT_INT_:
		{
			leaveTerminal(static_cast<CreatureObject*>(inv->getObjectParameter()), inv->getSignedIntParameter());
		}
		break;
	case RPC_REGISTERPLAYER__GAMBLINGTERMINAL_CREATUREOBJECT_:
		{
			registerPlayer(static_cast<GamblingTerminal*>(inv->getObjectParameter()), static_cast<CreatureObject*>(inv->getObjectParameter()));
		}
		break;
	case RPC_REFRESHROULETTEMENU__CREATUREOBJECT_:
		{
			refreshRouletteMenu(static_cast<CreatureObject*>(inv->getObjectParameter()));
		}
		break;
	case RPC_CONTINUEGAME__GAMBLINGTERMINAL_:
		{
			continueGame(static_cast<GamblingTerminal*>(inv->getObjectParameter()));
		}
		break;
	case RPC_STOPGAME__GAMBLINGTERMINAL_BOOL_:
		{
			stopGame(static_cast<GamblingTerminal*>(inv->getObjectParameter()), inv->getBooleanParameter());
		}
		break;
	case RPC_CALCULATEOUTCOME__GAMBLINGTERMINAL_:
		{
			calculateOutcome(static_cast<GamblingTerminal*>(inv->getObjectParameter()));
		}
		break;
	case RPC_CREATEWINDOW__GAMBLINGTERMINAL_CREATUREOBJECT_:
		{
			resp->insertInt(createWindow(static_cast<GamblingTerminal*>(inv->getObjectParameter()), static_cast<CreatureObject*>(inv->getObjectParameter())));
		}
		break;
	case RPC_CREATEPAYOUTWINDOW__CREATUREOBJECT_:
		{
			resp->insertInt(createPayoutWindow(static_cast<CreatureObject*>(inv->getObjectParameter())));
		}
		break;
	case RPC_CREATESLOTWINDOW__CREATUREOBJECT_INT_:
		{
			resp->insertInt(createSlotWindow(static_cast<CreatureObject*>(inv->getObjectParameter()), inv->getUnsignedIntParameter()));
		}
		break;
	case RPC_CREATEROULETTEWINDOW__CREATUREOBJECT_:
		{
			resp->insertInt(createRouletteWindow(static_cast<CreatureObject*>(inv->getObjectParameter())));
		}
		break;
	case RPC_CREATEEVENT__GAMBLINGTERMINAL_INT_:
		{
			createEvent(static_cast<GamblingTerminal*>(inv->getObjectParameter()), inv->getSignedIntParameter());
		}
		break;
	case RPC_ISPLAYING__CREATUREOBJECT_:
		{
			resp->insertBoolean(isPlaying(static_cast<CreatureObject*>(inv->getObjectParameter())));
		}
		break;
	default:
		throw Exception("Method does not exists");
	}
}

void GamblingManagerAdapter::initializeSlotTimer() {
	(static_cast<GamblingManager*>(stub))->initializeSlotTimer();
}

void GamblingManagerAdapter::initializeRouletteTimer() {
	(static_cast<GamblingManager*>(stub))->initializeRouletteTimer();
}

void GamblingManagerAdapter::initializeSlots() {
	(static_cast<GamblingManager*>(stub))->initializeSlots();
}

void GamblingManagerAdapter::initializeRouletteRed() {
	(static_cast<GamblingManager*>(stub))->initializeRouletteRed();
}

void GamblingManagerAdapter::initializeRoulette() {
	(static_cast<GamblingManager*>(stub))->initializeRoulette();
}

int GamblingManagerAdapter::notify(SceneObject* sceneObject) {
	return (static_cast<GamblingManager*>(stub))->notify(sceneObject);
}

bool GamblingManagerAdapter::isHigh(int value) {
	return (static_cast<GamblingManager*>(stub))->isHigh(value);
}

bool GamblingManagerAdapter::isLow(int value) {
	return (static_cast<GamblingManager*>(stub))->isLow(value);
}

bool GamblingManagerAdapter::isEven(int value) {
	return (static_cast<GamblingManager*>(stub))->isEven(value);
}

bool GamblingManagerAdapter::isOdd(int value) {
	return (static_cast<GamblingManager*>(stub))->isOdd(value);
}

bool GamblingManagerAdapter::isBlack(int value) {
	return (static_cast<GamblingManager*>(stub))->isBlack(value);
}

bool GamblingManagerAdapter::isRed(int value) {
	return (static_cast<GamblingManager*>(stub))->isRed(value);
}

void GamblingManagerAdapter::handleSlot(CreatureObject* player, bool cancel, bool other) {
	(static_cast<GamblingManager*>(stub))->handleSlot(player, cancel, other);
}

void GamblingManagerAdapter::bet(CreatureObject* player, int amount, int target, int machineType) {
	(static_cast<GamblingManager*>(stub))->bet(player, amount, target, machineType);
}

void GamblingManagerAdapter::bet(GamblingTerminal* terminal, CreatureObject* player, int amount, int target) {
	(static_cast<GamblingManager*>(stub))->bet(terminal, player, amount, target);
}

void GamblingManagerAdapter::startGame(CreatureObject* player, int machineType) {
	(static_cast<GamblingManager*>(stub))->startGame(player, machineType);
}

void GamblingManagerAdapter::startGame(GamblingTerminal* terminal) {
	(static_cast<GamblingManager*>(stub))->startGame(terminal);
}

void GamblingManagerAdapter::leaveTerminal(CreatureObject* player, int machineType) {
	(static_cast<GamblingManager*>(stub))->leaveTerminal(player, machineType);
}

void GamblingManagerAdapter::registerPlayer(GamblingTerminal* terminal, CreatureObject* player) {
	(static_cast<GamblingManager*>(stub))->registerPlayer(terminal, player);
}

void GamblingManagerAdapter::refreshRouletteMenu(CreatureObject* player) {
	(static_cast<GamblingManager*>(stub))->refreshRouletteMenu(player);
}

void GamblingManagerAdapter::continueGame(GamblingTerminal* terminal) {
	(static_cast<GamblingManager*>(stub))->continueGame(terminal);
}

void GamblingManagerAdapter::stopGame(GamblingTerminal* terminal, bool cancel) {
	(static_cast<GamblingManager*>(stub))->stopGame(terminal, cancel);
}

void GamblingManagerAdapter::calculateOutcome(GamblingTerminal* terminal) {
	(static_cast<GamblingManager*>(stub))->calculateOutcome(terminal);
}

unsigned int GamblingManagerAdapter::createWindow(GamblingTerminal* terminal, CreatureObject* player) {
	return (static_cast<GamblingManager*>(stub))->createWindow(terminal, player);
}

unsigned int GamblingManagerAdapter::createPayoutWindow(CreatureObject* player) {
	return (static_cast<GamblingManager*>(stub))->createPayoutWindow(player);
}

unsigned int GamblingManagerAdapter::createSlotWindow(CreatureObject* player, unsigned int payoutBoxID) {
	return (static_cast<GamblingManager*>(stub))->createSlotWindow(player, payoutBoxID);
}

unsigned int GamblingManagerAdapter::createRouletteWindow(CreatureObject* player) {
	return (static_cast<GamblingManager*>(stub))->createRouletteWindow(player);
}

void GamblingManagerAdapter::createEvent(GamblingTerminal* terminal, int time) {
	(static_cast<GamblingManager*>(stub))->createEvent(terminal, time);
}

bool GamblingManagerAdapter::isPlaying(CreatureObject* player) {
	return (static_cast<GamblingManager*>(stub))->isPlaying(player);
}

/*
 *	GamblingManagerHelper
 */

GamblingManagerHelper* GamblingManagerHelper::staticInitializer = GamblingManagerHelper::instance();

GamblingManagerHelper::GamblingManagerHelper() {
	className = "GamblingManager";

	Core::getObjectBroker()->registerClass(className, this);
}

void GamblingManagerHelper::finalizeHelper() {
	GamblingManagerHelper::finalize();
}

DistributedObject* GamblingManagerHelper::instantiateObject() {
	return new GamblingManager(DummyConstructorParameter::instance());
}

DistributedObjectServant* GamblingManagerHelper::instantiateServant() {
	return new GamblingManagerImplementation();
}

DistributedObjectAdapter* GamblingManagerHelper::createAdapter(DistributedObjectStub* obj) {
	DistributedObjectAdapter* adapter = new GamblingManagerAdapter(static_cast<GamblingManager*>(obj));

	obj->_setClassName(className);
	obj->_setClassHelper(this);

	adapter->setStub(obj);

	return adapter;
}

