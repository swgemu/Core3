/*
				Copyright <SWGEmu>
		See file COPYING for copying conditions.*/

package server.zone.objects.creature;

import server.zone.objects.tangible.TangibleObject;
import server.chat.StringIdChatParameter;
import server.zone.objects.group.GroupObject;
import server.zone.objects.guild.GuildObject;
import server.zone.objects.tangible.weapon.WeaponObject;
import server.zone.managers.objectcontroller.ObjectController;
import server.zone.objects.creature.CreatureObject;
import server.zone.objects.player.PlayerObject;
import server.zone.objects.scene.SceneObject;
import server.zone.objects.intangible.ControlDevice;
import server.zone.objects.area.CampSiteActiveArea;
import engine.core.ManagedObject;
import engine.lua.LuaObject;
import system.util.Vector;
import system.util.VectorMap;
import system.lang.Time;
import server.zone.Zone;
import system.util.SortedVector;
import server.zone.objects.creature.events.DizzyFallDownEvent;
import server.zone.templates.SharedObjectTemplate;
import server.zone.objects.creature.buffs.Buff;
import server.zone.objects.tangible.weapon.WeaponObject;
import server.zone.ZoneClientSession;
include server.zone.objects.creature.variables.CooldownTimerMap;
include server.zone.objects.creature.buffs.BuffList;
include server.zone.objects.creature.damageovertime.DamageOverTimeList;
include server.zone.objects.scene.variables.DeltaVector;
include server.zone.objects.creature.variables.CommandQueueActionVector;
include server.zone.objects.scene.variables.DeltaVectorMap;
include server.zone.objects.creature.variables.SkillList;
include server.zone.objects.creature.variables.SkillModList;
include server.zone.objects.creature.variables.SkillModEntry;
include server.zone.objects.creature.variables.CommandQueueAction;
include server.zone.objects.creature.CreaturePosture;
include server.zone.objects.creature.CreatureState;
include server.zone.objects.creature.SpeedMultiplierModChanges;
include server.zone.objects.creature.variables.Skill;
include server.zone.objects.creature.variables.WearablesDeltaVector;
import system.lang.Long;
import engine.service.proto.BasePacket;
import server.zone.packets.scene.AttributeListMessage;
import system.thread.Mutex;

@mock
class CreatureObject extends TangibleObject {
	protected transient ZoneClientSession owner;

	protected int bankCredits;
	protected int cashCredits;

	@dereferenced
	protected DeltaVector<int> baseHAM;

	protected byte posture;
	protected byte locomotion;
	protected byte factionRank;

	protected boolean invisible;

	@weakReference
	protected CreatureObject linkedCreature;

	@weakReference
	protected ControlDevice controlDevice;

	protected float shockWounds;

	@dereferenced
	protected DeltaVector<int> wounds;

	protected unsigned long stateBitmask;

	@dereferenced
	protected DeltaVector<int> encumbrances;

	@dereferenced
	protected WearablesDeltaVector wearablesVector;

	protected float accelerationMultiplierBase;
	protected float accelerationMultiplierMod;
	protected float speedMultiplierBase;
	@dereferenced
	protected SpeedMultiplierModChanges speedMultiplierModChanges;
	protected float speedMultiplierMod;
	protected float turnScale;
	protected float runSpeed;
	protected float walkSpeed;
	protected float currentSpeed;
	protected float terrainNegotiation;
	protected float runAcceleration;
	protected float walkAcceleration;
	protected float height;
	protected float swimHeight;
	protected float slopeModPercent;
	protected float slopeModAngle;

	protected unsigned long listenToID;
	protected unsigned long watchToID;

	protected string performanceAnimation;
	protected string moodString;

	protected WeaponObject weapon;

	protected GroupObject group;
	protected unsigned long groupInviterID;
	protected unsigned long groupInviteCounter;
	protected GuildObject guild;
	protected unsigned long targetID;
	protected byte moodID;
	protected int performanceCounter;
	protected int instrumentID;

	@dereferenced
	protected DeltaVector<int> hamList;

	@dereferenced
	protected DeltaVector<int> maxHamList;

	protected byte frozen;

	protected string templateString;

	// Skill stuff
	@dereferenced
	protected SkillList skillList;

	@dereferenced
	protected SkillModList skillModList;

	@dereferenced
	protected transient Mutex skillModMutex;

	@transactional
	protected transient CommandQueueActionVector commandQueue;

	@transactional
	protected transient CommandQueueActionVector immediateQueue;

	protected transient unsigned int lastActionCounter;

	@dereferenced
	protected Time nextAction;

	@transactional
	protected CooldownTimerMap cooldownTimerMap;

	@dereferenced
	protected BuffList creatureBuffs;
	@dereferenced
	protected DamageOverTimeList damageOverTimeList;

	@dereferenced
	protected Time lastSuccessfulCombatAction;

	protected transient DizzyFallDownEvent dizzyFallDownEvent;

	@dereferenced
	protected Time timeOfDeath;

	@dereferenced
	private transient Mutex screenPlayStatesMutex;
	/*
	 * Whenever screenPlayStates is being used the screenPlayStatesMutex should be held.
	 */
	@dereferenced
	private VectorMap<string, unsigned long> screenPlayStates;

	protected transient byte healthWoundHeal;
	protected transient byte actionWoundHeal;
	protected transient byte mindWoundHeal;

	protected transient byte currentWeather;
	protected transient byte currentWind;

	@dereferenced
	protected transient Time lastCombatActionTime;

	@dereferenced
	protected transient Vector3 lastCombatPosition;

	protected transient string alternateAppearance;

	public static final int HUMAN = 0;
	public static final int RODIAN = 1;
	public static final int TRANDOSHAN = 2;
	public static final int MONCAL = 3;
	public static final int WOOKIE = 4;
	public static final int BOTHAN = 5;
	public static final int TWILEK = 6;
	public static final int ZABRAK = 7;
	public static final int ITHORIAN = 0x21;
	public static final int SULLUSTAN = 0x31;

	public static final int MALE = 0;
	public static final int FEMALE = 1;

	public static transient float DEFAULTRUNSPEED;

	public static final unsigned long DEAD_TOO_LONG = 1800000; //30 minutes - How long can someone be dead and still be resuscitated in Miliseconds 

	/**
	 * CreatureObject constructor, used to initialized the object
	 * @pre { templateData is a valid SharedCreatureObjectTemplate LuaObject that contains the necessary values to initialize CreatureObject }
	 * @post { CreatureObject is initialized } 
	 * @param templateData templateData points to the SharedCreatureObjectTemplate LuaObject that is used to initialize CreatureObject members
	 */
	public CreatureObject() {
		Logger.setLoggingName("CreatureObject");
		
		initializeMembers();
	}

	public native void initializeMembers();

	public native void finalize();

	public native void createChildObjects();

	/**
	 * Reads and sets the template data from a SharedTangibleObjectTemplate LuaObject
	 * @pre { templateData is a valid pointer }
	 * @post { TangibleObject members are initialized }
	 * @param templateData templateData points to the SharedTangibleObjectTemplate LuaObject that is used to initialize the TangibleObject members
	 */
	@local
	public native void loadTemplateData(SharedObjectTemplate templateData);

	/**
	 * Initializes the transient members of SceneObject, must call the inherited object method first.
	 * @pre {transient members are not initialized }
	 * @post { transient members are initialized }
	 */
	public native void initializeTransientMembers();

	/**
	 * Sends a CommandQueueRemove ObjectControllerMessage to the owner client of this object
	 * @pre { }
	 * @post { client received the CommandQueueRemove message }
	 * @param actioncntr action id that will be cleared from clients queue
	 * @param timer how many seconds will the action take to execute
	 * @param tab1 message 1
	 * @param tab2 message 2 
	 */
	@preLocked
	public native void clearQueueAction(unsigned int actioncntr, float timer = 0, unsigned int tab1 = 0, unsigned int tab2 = 0);
	@preLocked
	public native void clearQueueActions(boolean combatOnly = true);

	/**
	 * Sends the CREO baseline messages of this object to the specified player
	 * @pre { this object is locked }
	 * @post { this object is locked, player received the baseline messages }
	 * @param player SceneObject that will receive the baselines 
	 */
	@dirty
	public native void sendBaselinesTo(SceneObject player);

	/**
	 * Sends the necessary messages to owner client
	 * @pre { this object is locked }
	 * @post { this object is locked, owner received its own scene object }
	 * @param doClose if true a SceneObjectCloseMessage is sent to finish the object
	 */
	@dirty
	public native void sendToOwner(boolean doClose = true);

	/**
	 * Sends the necessary messages to player in order to create this object
	 * @pre { this object is locked }
	 * @post { this object is locked, player received this object }
	 * @param player SceneObject that will receive the messages
	 * @param doClose if true a SceneObjectCloseMessage is sent to finish the object
	 */
	@dirty
	public native void sendTo(SceneObject player, boolean doClose);

	/**
	 * Sends a system message to the client of this object
	 * @pre {}
	 * @post { this object received the message }
	 * @param message string message to send
	 */
	@dirty
	public native void sendSystemMessage(final string message);

	/**
	 * Sends a PlayMusicMessage
	 */
	@dirty
	public native void playMusicMessage(final string file);

	/**
	 * Sends a tutorial request
	 */
	@dirty
	public native void sendNewbieTutorialRequest(final string request);

	/**
	 * Sends NewbieTutorialEnableHud
	 */
	@dirty
	public native void sendNewbieTutorialEnableHudElement(final string ui, boolean enable = true, float blinkCount = 0.0f);

	@dirty
	public native void sendOpenHolocronToPageMessage();

	/**
	 * Sends a system message to the client of this object
	 * @pre {}
	 * @post { this object received the message }
	 * @param message unicode message to send
	 */
	@dirty
	public native void sendSystemMessage(unicode message);

	/**
	 * Sends a system message to the client of this object
	 * @pre {}
	 * @post { this object received the message }
	 * @param file stf file name of the message
	 * @param stringid stf stringid of the message
	 */
	//public native void sendSystemMessage(final string file, final string stringid);

	/**
	 * Sends a system message to the client of this object
	 * @pre {}
	 * @post { this object received the message }
	 * @param message StringIdChatParameter message to send
	 */
	@local
	@dirty
	public native void sendSystemMessage(@dereferenced StringIdChatParameter stringid);

	/**
	 * Sends the contained slotted objects to the specified player
	 * @pre { this object is locked }
	 * @post { this object is locked, player received the slotted objects }
	 * @param player SceneObject that will receive the objects 
	 */
	@dirty
	public native void sendSlottedObjectsTo(SceneObject player);

	/**
	 * Sets the combat state
	 * @pre { this object is locked }
	 * @post { this object is locked, this object is in a combat state }
	 */
	@preLocked
	public abstract native void setCombatState();

	/**
	 * Cleares the combat state
	 * @pre { this object is locked }
	 * @post { this object is locked, this object is not in a combat state }
	 * @param clearDefenders if true the defender vector willl be emptied
	 */
	@preLocked
	public native void clearCombatState(boolean clearDefenders = true);

	@preLocked
	public native void addMountedCombatSlow();

	@preLocked
	public native void removeMountedCombatSlow();

	/**
	 * Sets a new posture
	 * @pre { this object is locked }
	 * @post {this object is locked, this object has the new posture set }
	 * @param newPosture posture to set
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	@preLocked
	public native abstract void setPosture(int newPosture, boolean notifyClient = true);

	/**
	 * checks locomotion and sets a new one if appropriate
	 * @pre { this object is locked }
	 * @post {this object is locked, this object has the new locomotion set, if appropriate }
	 */
	@dirty
	public native float calculateSpeed();

	@preLocked
	public native abstract void updateLocomotion();

	@preLocked
	public native void setHeight(float heigh, boolean notifyClient = true);

	/**
	 * Updates the acceleration speed multiplier base
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @param newMultiplierBase new multiplier base to set
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	@preLocked
	public native void setAccelerationMultiplierBase(float newMultiplierBase, boolean notifyClient = true);

	/**
	 * Updates the acceleration speed multiplier mod
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @param newMultiplierMod new multiplier mod to set
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	@preLocked
	public native void setAccelerationMultiplierMod(float newMultiplierMod, boolean notifyClient = true);

	/**
	 * Updates the speed multiplier base
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @param newMultiplierBase new multiplier base to set
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	@preLocked
	public native void setSpeedMultiplierBase(float newMultiplierBase, boolean notifyClient = true);

	/**
	 * Updates the speed multiplier mod
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @param newMultiplierMod new multiplier mod to set
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	@preLocked
	public native abstract void setSpeedMultiplierMod(float newMultiplierMod, boolean notifyClient = true);

	/**
	 * Updates the turn scale mod
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @param newMultiplierMod new multiplier mod to set
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	@preLocked
	public native abstract void setTurnScale(float newMultiplierMod, boolean notifyClient = true);

	/**
	 * Updates the run speed
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * 
	 */
	@preLocked
	public native void setRunSpeed(float newSpeed, boolean notifyClient = true);

	@preLocked
	public void setCurrentSpeed(float newSpeed) {
		currentSpeed = newSpeed;
	}

	/**
	 * Updates a specific type of the HAM
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the HAM type updated to the new value }
	 * @param type specifies which HAM type to update
	 * @param value the new value
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	public native void setHAM(int type, int value, boolean notifyClient = true);

	/**
	 * Inflicts damage into the object
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @return unused for now
	 */
	@preLocked
	@arg1preLocked
	public native int inflictDamage(TangibleObject attacker, int damageType, float damage, boolean destroy, boolean notifyClient = true);

	@preLocked
	@arg1preLocked
	public native int inflictDamage(TangibleObject attacker, int damageType, float damage, boolean destroy, final string xp, boolean notifyClient = true);

	@dirty
	public boolean hasDamage(int attribute) {
		return hamList.get(attribute) + wounds.get(attribute) < maxHamList.get(attribute);
	}

	/**
	 * Heals damage
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @return unused for now
	 */
	@preLocked
	public native int healDamage(TangibleObject healer, int damageType, int damage, boolean notifyClient = true, boolean notifyObservers = true);

	/**
	 * Heals wounds
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @return unused for now
	 */
	@preLocked
	public native abstract int healWound(TangibleObject healer, int damageType, int damage, boolean notifyClient = true, boolean notifyObservers = true);

	/**
	 * Updates a specific type of the Base HAM
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the Base HAM type updated to the new value }
	 * @param type specifies which Base HAM type to update
	 * @param value the new value
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	public native void setBaseHAM(int type, int value, boolean notifyClient = true);

	/**
	 * Updates a specific type of wound
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the Wounds type updated to the new value }
	 * @param type specifies which Wounds type to update
	 * @param value the new value
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	public native abstract void setWounds(int type, int value, boolean notifyClient = true);

	/**
	 * adds wounds
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @return returns wounds added
	 */
	@preLocked
	public native abstract int addWounds(int type, int value, boolean notifyClient = true, boolean doShockWounds = true);

	/**
	 * Updates a specific type of the Max HAM
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the Max HAM type updated to the new value }
	 * @param type specifies which Max HAM type to update
	 * @param value the new value
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	@preLocked
	public native void setMaxHAM(int type, int value, boolean notifyClient = true);
	@preLocked
	public native void addMaxHAM(int type, int value, boolean notifyClient = true);

	/**
	 * Updates a specific type of the Encumbrance
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the Encumbrance type updated to the new value }
	 * @param type specifies which Encumbrance type to update
	 * @param value the new value
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	public native void setEncumbrance(int type, int value, boolean notifyClient = true);

	public native void addEncumbrance(int type, int value, boolean notifyClient = true);

	/**
	 * Updates the weapon to the specified object
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the specified weapon id }
	 * @param weao the new weapon
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	@preLocked
	public native void setWeapon(WeaponObject weao, boolean notifyClient = false);

	/**
	 * Is called when this object has been inserted with an object
	 * @param object object that has been inserted
	 */
	public native int notifyObjectInserted(SceneObject object);

	/**
	 * Is called when an object was removed
	 * @param object object that has been inserted
	 */
	public native int notifyObjectRemoved(SceneObject object);

	/**
	 * Updates the instrument id to the specified object id
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the specified weapon id }
	 * @param instrumentid the new instrument id
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	@preLocked
	public native void setInstrumentID(int instrumentid, boolean notifyClient = true);

	/**
	 * Updates listen id
	 */
	@preLocked
	public native void setListenToID(unsigned long id, boolean notifyClient = true); 

	/**
	 * Updates the preformance counter
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the counter updated }
	 * @param counter new performance counter
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	@preLocked
	public native void setPerformanceCounter(int counter, boolean notifyClient = true);

	/**
	 * Updates the preformance animation string
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the animation updated }
	 * @param animation new animation
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	@preLocked
	public native void setPerformanceAnimation(final string animation, boolean notifyClient = true);

	/**
	 * Updates shock wounds
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the specified target id }
	 * @param shock new shock wounds
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	@preLocked
	public native void setShockWounds(int newShock, boolean notifyClient = true);

	@preLocked
	public native void addShockWounds(int shockToAdd, boolean notiyClient = true, boolean sendSpam = true);

	/**
	 * Updates the target id to the specified object id
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the specified target id }
	 * @param objectID the new target id
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	@preLocked
	public native void setTargetID(unsigned long targetID, boolean notifyClient = true);

	/**
	 * Updates the bank credits of this object
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the specified bank credits }
	 * @param credits the new credits
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	@preLocked
	public native void setBankCredits(int credits, boolean notifyClient = true);

	/**
	 * Adds the buff to the creature, activating it and sending packets if it is a player.
	 * Buffs should never be added to the list without sending of packets.
	 * @param buff The Buff object to add the creature.
	 */
	@preLocked
	@arg1preLocked
	public native void addBuff(Buff buff);

	/**
	 * Removes the buff from the creature, activating it and sending packets if it is a player.
	 * Buffs should never be removed from the list without sending of packets.
	 * @param buffcrc The buff crc to remove from the buff list.
	 */
	@preLocked
	public native boolean removeBuff(unsigned int buffcrc);

	/**
	 * Removes the buff from the creature, activating it and sending packets if it is a player.
	 * Buffs should never be removed from the list without sending of packets.
	 * @param buffcrc The buff object to remove from the list.
	 */
	@preLocked
	@arg1preLocked
	public native void removeBuff(Buff buff);

	@preLocked
	public native boolean removeStateBuff(unsigned long state);

	/**
	 * Removes all buffs from the creature, deactivating any currently active buffs.
	 * @param updateclient Should packets be sent to the player?
	 */
	@preLocked
	public native void clearBuffs(boolean updateclient);
	
	public native void updateVehiclePosition(boolean sendPackets);

	@preLocked
	public native void addWearableObject(TangibleObject object, boolean notifyClient = true);

	@preLocked
	public native void removeWearableObject(TangibleObject object, boolean notifyClient = true);

	@local
	@dirty
	public WearablesDeltaVector getWearablesDeltaVector() {
		return wearablesVector;
	}

	@dirty
	public void sendBuffsTo(CreatureObject creature) {
		creatureBuffs.sendTo(creature);
	}

	@local
	@dirty
	public BuffList getBuffList() {
		return creatureBuffs;
	}

	@dirty
	public Buff getBuff(unsigned int buffcrc) {
		if (creatureBuffs.hasBuff(buffcrc))
			return creatureBuffs.getBuffByCRC(buffcrc);

		return null;
	}

	@dirty
	public long getSkillModFromBuffs(final string skillMod) {
		return creatureBuffs.getModifierByName(skillMod);
	}

	@preLocked
	public abstract int addDotState(CreatureObject attacker, unsigned long dotType, unsigned long objectID, unsigned int strength, byte type, unsigned int duration, float potency, unsigned int defense, int secondaryStrength = 0) {
		return damageOverTimeList.addDot(this, attacker, objectID, duration, dotType, type, strength, potency, defense, secondaryStrength);
	}

	@preLocked
	public boolean healDot(unsigned long dotType, int reduction) {
		return damageOverTimeList.healState(this, dotType, reduction);
	}

	@preLocked
	public void clearDots() {
		damageOverTimeList.clear(this);
	}

	@local
	public DamageOverTimeList getDamageOverTimeList() { 
		return damageOverTimeList;
	}

	@dirty
	public boolean hasBuff(unsigned int buffcrc) {
		return creatureBuffs.hasBuff(buffcrc);
	}

	@preLocked
	public native void notifySelfPositionUpdate();

	@preLocked
	public native void notifyPostureChange(int newPosture);

	@preLocked
	public native void setLevel(int level, boolean randomHam = true);

	public native void updateToDatabaseAllObjects(boolean startTask);

	@dirty
	public native boolean isResuscitable();

	@preLocked
	public void addBankCredits(int credits, boolean notifyClient = true) {
		int newCredits = bankCredits + credits;
		setBankCredits(newCredits);
	}

	@preLocked
	public void addCashCredits(int credits, boolean notifyClient = true) {
		int newCredits = cashCredits + credits;
		setCashCredits(newCredits);
	}

	@preLocked
	public native void subtractBankCredits(int credits);

	@preLocked
	public native void subtractCashCredits(int credits);

	@dirty
	public boolean verifyCashCredits(int credits) {
		if (credits < 0)
			return false;

		if (cashCredits < credits)
			return false;

		return true;
	}

	@dirty
	public boolean verifyBankCredits(int credits) {
		if (credits < 0)
			return false;

		if (bankCredits < credits)
			return false;

		return true;
	}

	@dirty
	public native boolean isDancing();

	@dirty
	public native boolean isPlayingMusic();

	@preLocked
	public native void stopEntertaining();

	@dirty
	public native boolean isEntertaining() {
		return isDancing() || isPlayingMusic();
	}

	/**
	 * Update the cash credits of this object
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the specified cash credits }
	 * @param credits the new credits
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	@preLocked
	public native void setCashCredits(int credits, boolean notifyClient = true);

	/**
	 * Sets the terrain negotiation variable, and updates it.
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the specified terrain negotiation }
	 * @param terrain new terrain negotiation
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	@preLocked
	public native void setTerrainNegotiation(float value, boolean notifyClient = true);

	/**
	 * Updates the client with the players current terrain negotiation.
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the specified terrain negotiation }
	 */
	public native void updateTerrainNegotiation();

	/**
	 * Adds the specified skillbox to this object
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the specified skillbox in the delta vector
	 * @param skillbox skillbox to add
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	@preLocked
	@local
	public native void addSkill(Skill skill, boolean notifyClient = true);

	/**
	 * Adds the specified skillbox to this object
	 * @pre { this object is locked }
	 * @post { this object is locked, this object has the specified skillbox in the delta vector
	 * @param skillbox skillbox name to add
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	@preLocked
	public native void addSkill(final string skill, boolean notifyClient = true);

	/**
	 * Removes the specified skillbox from this object
	 * @pre { this object is locked }
	 * @post { this obejct is locked, skillbox is removed }
	 * @param skillBox skillBox to remove
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	@preLocked
	@local
	public native void removeSkill(Skill skill, boolean notifyClient = true);

	/**
	 * Removes the specified skillbox from this object
	 * @pre { this object is locked }
	 * @post { this obejct is locked, skillbox is removed }
	 * @param skillBox skillBox to remove
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	@preLocked
	public native void removeSkill(final string skill, boolean notifyClient = true);

	/**
	 * Adds new value to the specified skillmod (add a negative number to subtract)
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @param skillMod skill mod to change
	 * @param value value to add/subtract
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	@preLocked
	public native void addSkillMod(final int modType, final string skillMod, int value, boolean notifyClient = true);

	/**
	 * Adds new value to the specified skillmod (add a negative number to subtract)
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @param skillMod skill mod to change
	 * @param value value to add/subtract
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	//public native void addWearableSkillMod(final string skillMod, long value, boolean notifyClient = true);

	/**
	 * Removes skill mod from the list (same as setting to 0)
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @param skillMod skill mod to remove
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	@preLocked
	public native void removeSkillMod(final int modType, final string skillMod, int value, boolean notifyClient = true);

	@preLocked
	public native void removeAllSkillModsOfType(final int modType, boolean notifyClient = true);

	/**
	 * Sets a new group inviter id
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @param id object id of the inviter
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	@preLocked
	public native void updateGroupInviterID(unsigned long id, boolean notifyClient = true);

	/**
	 * Sets the group of this object
	 * @pre { this object is locked }
	 * @post {this object is locked }
	 * @param group GroupObject to update
	 * @param notifyClient if set true the client will be updated with the changes
	 */
	@preLocked
	public native void updateGroup(GroupObject group, boolean notifyClient = true);

	/**
	 * Enqueues a command action
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @param actionCRC queue command crc
	 * @param actionCount command count
	 * @param targetID target
	 * @param arguments arguments
	 * @param priority command priority
	 */
	@preLocked
	public native void enqueueCommand(unsigned int actionCRC, unsigned int actionCount, unsigned long targetID, final unicode arguments, int priority = -1, int compareCount = -1);

	@preLocked
	public native void sendCommand(unsigned int crc, final unicode args, unsigned long targetID = 0, int priority = 2);

	@preLocked
	public native void sendCommand(final string action, final unicode args, unsigned long targetID = 0, int priority = 2);

	/**
	 * Sets characters mood
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @param moodID mood to set
	 */
	@preLocked
	public native void setMood(byte moodID, boolean notifyClient = true);

	/**
	 * Sets a new mood animation
	 * @pre { this is locked }
	 * @post { this is locked }
	 * @param mood mood animation string
	 */
	@preLocked
	public native void setMoodString(final string animation, boolean notifyClient = true);

	/**
	 * Removes a command from queue
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @param actionCount the action count to remove
	 */
	@preLocked
	public native void deleteQueueAction(unsigned int actionCount);

	/**
	 * Sets a new state to the statebitmask
	 * @pre { this object is locked }
	 * @post { this object is locked, stateBitmask has the new state }
	 * @param state state to add
	 */
	@preLocked
	public native boolean setState(unsigned long state, boolean notifyClient = true);

	/**
	 * Sets an alternate appearance
	 * @pre { this object is locked }
	 * @post { this object is locked, alternateAppearance is set and clients updated
	 * @param serverAppearanceTemplate appearance template
	 * @notifyClient updates all in range clients and self
	 */
	@preLocked
	public native void setAlternateAppearance(final string appearanceTeamplate, boolean notifyClient = true);

	/**
	 * Cleares a state from the state bitmask
	 * @pre { this object is locked }
	 * @post { this object is locked, stateBitmask doesnt have the specified state }
	 * @param state state to clear
	 */
	@preLocked
	public native boolean clearState(unsigned long state, boolean notifyClient = true);

	@preLocked
	public void setControlDevice(ControlDevice device) {
		controlDevice = device;
	}

	/**
	 * Updates creatureLinkID with specified object
	 * @pre { this is locked }
	 * @post { this is locked }
	 */
	@preLocked
	public native void setCreatureLink(CreatureObject object, boolean notifyClient = true);

	/**
	 * Executes an object controller command
	 */
	@preLocked
	public native void executeObjectControllerAction(unsigned int actionCRC);

	@preLocked
	public native void executeObjectControllerAction(unsigned int actionCRC, unsigned long targetID, final unicode args);

	/**
	 * Evaluates if this object can be attacket by the passed creature object
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @return returns true if the creature object can attack this 
	 */
	@dirty
	public native boolean isAttackableBy(CreatureObject object);

	@dirty
	public native boolean isAttackableBy(TangibleObject attacker);

	@dirty
	public native boolean isHealableBy(CreatureObject object);

	/**
	 * Evaluates if the bounty hunter has a mission with the target.
	 * @param bountyHunter the bounty hunter.
	 * @param target the target.
	 * @return true if bounty hunter has a mission with the target.
	 */
	@dirty
	public native boolean isInBountyMission(CreatureObject bountyHunter, CreatureObject target);

	/**
	 * sends the conversation list 
	 * @pre {this locked, player locked }
	 * @post { this locked, player locked }
	 * @return whether the conversation was started or not
	 */
	@dirty
	public abstract boolean sendConversationStartTo(SceneObject player) {
		return false;
	}

	/**
	 * sends the conversation list 
	 * @pre {this locked, player locked }
	 * @post { this locked, player locked }
	 */
	public abstract void selectConversationOption(int option, SceneObject obj) {
		
	}

	/**
	 * Sends a message to client
	 * @pre { }
	 * @post { message is sent to client }
	 * @param msg BasePacket to send
	 */
	@dirty
	public native void sendMessage(BasePacket msg);

	/**
	 * Sends CombatSpam to players for state/posture changes
	 * @pre { }
	 * @post { CombatSpam is sent to clients }
	 * @param stringName The string name in cbt_spam.stf to send.
	 * @param color The color of the combat spam text. 0 = white, 1 = auto green/red, 10 = red, 11 = yellow
	 * @param broadcast Specifies whether to send the packet to all nearby players or just this player.
	 */
	@dirty
	public native void sendStateCombatSpam(final string fileName, final string stringName, byte color, int damage = 0, boolean broadcast = true);

	/**
	 * Sends custom CombatSpam strings to players
	 * @pre { }
	 * @post { CombatSpam is sent to clients }
	 * @param customString The string to send to combat spam window.
	 * @param color The color of the combat spam text. 0 = white, 10 = red, 11 = yellow
	 */
	@dirty
	public native void sendCustomCombatSpam(final unicode customString, byte color);

	/**
	 * Sends a ExecuteConsoleCommand to the client
	 * @param command example "/attack"
	 */
	@dirty
	public native void sendExecuteConsoleCommand(final string command);

	/**
	 * Evaluates if this creature is aggresive to the object
	 * @pre { }
	 * @post { }
	 * @return returns true if its aggressive
	 */
	@dirty
	public native boolean isAggressiveTo(CreatureObject object);

	/**
	 * Is called when this object is destroyed
	 * @pre { this, attacker locked }
	 * @post { this, attacker locked }
	 */
	@preLocked
	@arg1preLocked
	public native int notifyObjectDestructionObservers(TangibleObject attacker, int condition);

	/**
	 * Is called when this object is killed
	 * @pre { this, killer locked }
	 * @post { this, killer locked }
	 * @param killer The killer.
	 */
	@preLocked
	@arg1preLocked
	public native int notifyObjectKillObservers(TangibleObject killer);

	/**
	 * Gets called when this objects is loaded from database
	 * @pre { this locked }
	 * @post { this locked }
	 */
	@preLocked
	public native void notifyLoadFromDatabase();

	/**
	 * Destroys this object from database
	 * @pre { this is locked }
	 * @post { this is locked }
	 * @param destroyContainedObjects if true, will destroy from database all its contained objects
	 */
	@preLocked
	public void destroyObjectFromDatabase(boolean destroyContainedObjects = false) {
		clearBuffs(false);

		super.destroyObjectFromDatabase(destroyContainedObjects);
	}

	@preLocked
	public native void setFactionRank(int rank, boolean notifyClient = true);

	@dirty
	public native string getFirstName();

	@dirty
	public native string getLastName();

	@dirty
	public boolean isOnline() {
		PlayerObject ghost = getPlayerObject();
		
		if (ghost == null)
			return false;
		
		return ghost.isOnline();
	}

	@dirty
	public boolean canTreatInjuries() {
		return super.getPendingTask("injuryTreatment") == null;
	}

	@dirty
	public boolean canTreatStates() {
		return super.getPendingTask("stateTreatment") == null;
	}

	@dirty
	public boolean canTreatWounds() {
		return super.getPendingTask("woundTreatment") == null;
	}

	@dirty
	public boolean canTreatConditions() {
		return super.getPendingTask("conditionTreatment") == null;
	}

	@reference
	@dirty
	public native PlayerObject getPlayerObject();

	@read
	public boolean isListening() {
		return listenToID != 0;
	}

	@read
	public boolean isWatching() {
		return watchToID != 0;
	}

	@preLocked
	public void setClient(ZoneClientSession cli) {
		owner = cli;
	}

	@preLocked
	public native void dismount();

	@dirty
	public native float calculateBFRatio();

	@preLocked
	public native void setDizziedState(int durationSeconds = 5);

	@preLocked
	public native void setRalliedState(int durationSeconds = 5);

	@preLocked
	public native void setAimingState(int durationSeconds = 5);

	@preLocked
	public native void setCoverState(int durationSeconds = 40);

	@preLocked
	public native void setBerserkedState(unsigned int duration);

	@preLocked
	public native void setStunnedState(int durationSeconds = 5);

	@preLocked
	public native void setBlindedState(int durationSeconds = 5);

	@preLocked
	public native void setIntimidatedState(unsigned int mod, unsigned int crc, int durationSeconds = 15);

	@preLocked
	public native void setSnaredState(int durationSeconds = 20);

	@preLocked
	public native void setRootedState(int durationSeconds = 20);

	public native boolean setNextAttackDelay(unsigned int mod, int del);

	@preLocked
	public native void setMeditateState();

	@preLocked
	public abstract native void activateHAMRegeneration();

	@preLocked
	public abstract native void activatePassiveWoundRegeneration();

	@preLocked
	public abstract native void activateStateRecovery();

	@preLocked
	public void updateTimeOfDeath() {
		timeOfDeath.updateToCurrentTime();
	}

	@dirty
	public boolean hasAttackDelay() {
		return !cooldownTimerMap.isPast("nextAttackDelay");
	}

	public void removeAttackDelay() {
		cooldownTimerMap.updateToCurrentTime("nextAttackDelay");
	}

	@local
	public CooldownTimerMap getCooldownTimerMap() { 
		return cooldownTimerMap;
	}

	@dirty
	public boolean hasSpice() {
		return creatureBuffs.hasSpice();
	}

	public void updateLastSuccessfulCombatAction() {
		lastSuccessfulCombatAction.updateToCurrentTime();
	}

	public void updatePostureChangeDelay(int delay) {
		cooldownTimerMap.updateToCurrentAndAddMili("postureChangeDelay", delay);
	}

	@dirty
	public boolean checkPostureChangeDelay() {
		return cooldownTimerMap.isPast("postureChangeDelay");
	}

	public void updatePostureDownRecovery() {
		cooldownTimerMap.updateToCurrentAndAddMili("postureDownRecovery", 30000);
	}

	@dirty
	public boolean checkPostureDownRecovery() {
		return cooldownTimerMap.isPast("postureDownRecovery");
	}

	public void updatePostureUpRecovery() {
		cooldownTimerMap.updateToCurrentAndAddMili("postureUpRecovery", 30000);
	}

	@dirty
	public boolean checkPostureUpRecovery() {
		return cooldownTimerMap.isPast("postureUpRecovery");
	}

	public void updateKnockdownRecovery() {
		cooldownTimerMap.updateToCurrentAndAddMili("knockdownRecovery", 30000);
	}

	@dirty
	public boolean checkKnockdownRecovery() {
		return cooldownTimerMap.isPast("knockdownRecovery");
	}

	// misc methods
	@preLocked
	public abstract native void queueDizzyFallEvent();

	public boolean hasDizzyEvent() {
		return dizzyFallDownEvent != null;
	}

	@preLocked
	public void clearDizzyEvent() {
		if (hasDizzyEvent()) {
			dizzyFallDownEvent.cancel();
			dizzyFallDownEvent = null;
		}
	}

	/**
	 * Returns the given ScreenPlayState.
	 * Takes the screenPlayStatesMutex.
	 * @param screenPlay ScreenPlay to retrieve
         */
	public unsigned long getScreenPlayState(final string screenPlay) {
		synchronized (screenPlayStatesMutex) {
			return screenPlayStates.get(screenPlay);
		}
	}

	/**
	 * Sets the given ScreenPlayState.
	 * Takes the screenPlayStatesMutex.
	 * @param screenPlay ScreenPlay to modify
	 * @param state the State to set
         */
	public void setScreenPlayState(final string screenPlay, unsigned long state) {
		synchronized (screenPlayStatesMutex) {
			screenPlayStates.put(screenPlay, state);
		}
	}

	public void updateCooldownTimer(final string coooldownTimer, unsigned int miliSecondsToAdd = 0) {
		if (miliSecondsToAdd != 0) {
			cooldownTimerMap.updateToCurrentAndAddMili(coooldownTimer, miliSecondsToAdd);
		} else {
			cooldownTimerMap.updateToCurrentTime(coooldownTimer);
		}
	}

	@dirty
	public boolean checkCooldownRecovery(final string cooldown) {
		return cooldownTimerMap.isPast(cooldown);
	}

	@local
	public Time getCooldownTime(final string cooldown) {
		return cooldownTimerMap.getTime(cooldown);
	}

	public void addCooldown(final string name, unsigned int miliseconds) {
		cooldownTimerMap.updateToCurrentAndAddMili(name, miliseconds);
	}

	@dirty
	public native void doAnimation(final string animation);

	@dirty
	public native void doCombatAnimation(CreatureObject defender, unsigned int animationCRC, byte hit, byte trails);

	@preLocked
	public native void activateQueueAction();

	@preLocked
	public native void activateImmediateAction();

	@dirty
	public native unicode getCreatureName();

	@read
	public boolean isGrouped() {
		return group != null;
	}

	@read
	public int getBankCredits() {
		return bankCredits;
	}

	@read
	public int getCashCredits() {
		return cashCredits;
	}

	@dirty
	public int getBaseHAM(int idx) {
		return baseHAM.get(idx);
	}

	@dirty
	public int getWounds(int idx) {
		return wounds.get(idx);
	}

	@local
	@dirty
	public DeltaVector<int> getWounds() {
		return wounds;
	}

	@dirty
	public int getHAM(int idx) {
		return hamList.get(idx);
	}

	@dirty
	@local
	public DeltaVector<int> getHAM() {
		return hamList;
	}

	@dirty
	public int getMaxHAM(int idx) {
		return maxHamList.get(idx);
	}

	@local
	@dirty
	public DeltaVector<int> getMaxHAM() {
		return maxHamList;
	}

	@dirty
	public int getEncumbrance(int idx) {
		return encumbrances.get(idx);
	}

	@local
	@dirty
	public DeltaVector<int> getEncumbrances() {
		return encumbrances;
	}

	@read
	public byte getPosture() {
		return posture;
	}

	@read
	public byte getLocomotion() {
		return locomotion;
	}

	@read
	public byte getFactionRank() {
		return factionRank;
	}

	@weakReference
	@read
	public CreatureObject getLinkedCreature() {
		return linkedCreature;
	}

	@read
	public unsigned long getCreatureLinkID() {
		CreatureObject strongRef = linkedCreature;
		
		if (strongRef != null)
			return strongRef.getObjectID();
		else
			return 0;
	}

	@read
	public float getShockWounds() {
		return shockWounds;
	}

	@read
	public unsigned long getWatchToID() {
		return watchToID;
	}

	@read
	public unsigned long getStateBitmask() {
		return stateBitmask;
	}

	@read
	public boolean hasState(unsigned long state) {
		return stateBitmask & state;
	}

	@read
	public boolean hasStates() {
		return stateBitmask != 0;
	}

	@read
	public unsigned long getListenID() {
		return listenToID;
	}

	@read
	public float getAccelerationMultiplierBase() {
		return accelerationMultiplierBase;
	}

	@read
	public float getAccelerationMultiplierMod() {
		return accelerationMultiplierMod;
	}

	@read
	public float getSpeedMultiplierBase() {
		return speedMultiplierBase;
	}

	@read
	public float getSpeedMultiplierMod() {
		return speedMultiplierMod;
	}

	@read
	public float getCurrentSpeed() {
		return currentSpeed;
	}

	@preLocked
	@local
	@dirty
	public SpeedMultiplierModChanges getSpeedMultiplierModChanges() {
		return speedMultiplierModChanges;
	}

	@preLocked
	@local
	@dirty
	public CommandQueueActionVector getCommandQueue() {
		return commandQueue;
	}

	@read
	public int getCommandQueueSize() {
		return commandQueue.size();
	}

	@preLocked
	public void setLastActionCounter(unsigned int ctr) {
		lastActionCounter = ctr;
	}

	@preLocked
	public unsigned int incrementLastActionCounter() {
		lastActionCounter = lastActionCounter + 32;
		if (lastActionCounter < 0x40000000)
			lastActionCounter = 0x40000000;
		
		return lastActionCounter;
	}

	public unsigned int getLastActionCounter() {
		return lastActionCounter;
	}

	@read
	public float getRunSpeed() {
		return runSpeed;
	}

	@read
	public float getWalkSpeed() {
		return walkSpeed;
	}

	@read
	public float getTurnScale() {
		return turnScale;
	}

	@dirty
	public native float getTerrainNegotiation();

	@read
	public float getRunAcceleration() {
		return runAcceleration;
	}

	@read
	public float getWalkAcceleration() {
		return walkAcceleration;
	}

	@read
	public string getPerformanceAnimation() {
		return performanceAnimation;
	}

	@read
	public string getMoodString() {
		return moodString;
	}

	@read
	public unsigned long getWeaponID() {
		if (weapon == null)
			return 0;
		else
			return weapon.getObjectID();
	}

	@reference
	@dirty
	@preLocked
	public native WeaponObject getWeapon();

	@reference
	@read
	public GuildObject getGuildObject() {
		return guild;
	}

	@read
	public int getGuildID() {
		if (guild == null)
			return 0;
		
		return guild.getGuildID();
	}

	@read
	public boolean isInGuild() {
		return guild != null;
	}

	@preLocked
	public void setGuildObject(GuildObject guildobj) {
		guild = guildobj;
	}

	@read
	public unsigned long getGroupID() {
		if (group != null)
			return group.getObjectID();
		else
			return 0;
	}

	@read
	public unsigned long getGroupInviterID() {
		return groupInviterID;
	}

	@read
	@reference
	public GroupObject getGroup() {
		return group;
	}

	@read
	public unsigned long getGroupInviteCounter() {
		return groupInviteCounter;
	}

	@read
	public unsigned long getTargetID() {
		return targetID;
	}

	@read
	public byte getMoodID() {
		return moodID;
	}

	@read
	public float getSlopeModPercent() {
		return slopeModPercent;
	}

	@read
	public int getPerformanceCounter() {
		return performanceCounter;
	}

	@read
	public int getInstrumentID() {
		return instrumentID;
	}

	@read
	public byte getFrozen() {
		return frozen;
	}

	@read
	public float getHeight() {
		return height;
	}

	@dirty
	public boolean isDroidSpecies() {
		//Determine if creature is a droid.
		return getSpecies() >= 203 && getSpecies() <= 225 && getSpecies() != 207;
	}

	@dirty 
	public boolean isWalkerSpecies() {
		//Determine if creature is an ATST or ATAT.
		return getSpecies() == 226;
	}
	
	@dirty
	public boolean isProbotSpecies() {
		return getSpecies() == 216;
	}

	@dirty
	public native boolean hasEffectImmunity(byte effectType);

	@dirty
	public native boolean hasDotImmunity(unsigned int dotType);

	public abstract native int getSpecies();

	public string getSpeciesName() {
		int species = getSpecies();
		if(species == 0)
			return "human";
		else if(species == 1)
			return "rodian";
		else if(species == 2)
			return "trandoshan";
		else if(species == 3)
			return "moncal";
		else if(species == 4)
			return "wookiee";
		else if(species == 5)
			return "bothan";
		else if(species == 6)
			return "twilek";
		else if(species == 7)
			return "zabrak";
		else if(species == 0x21)
			return "ithorian";
		else if(species == 0x31)
			return "sullustan";
		else
			return "";
	}

	public native int getGender();

	@local
	@dirty
	public DeltaVector<int> getBaseHAM() {
		return baseHAM;
	}

	@local
	@dirty
	public SkillList getSkillList() {
		return skillList;
	}

	@dirty
	@preLocked
	public native int getSkillMod(final string skillmod);

	@dirty
	@preLocked
	public native int getSkillModOfType(final string skillmod, final unsigned int modType);

	@dirty
	public boolean hasSkill(final string skill) {
		return skillList.containsSkill(skill);
	}

	@local
	@dirty
	public SkillModList getSkillModList() {
		return skillModList;
	}

	@preLocked
	public void setWatchToID(unsigned long id) {
		watchToID = id;
	}

	@dirty
	public boolean isCreatureObject() {
		return true;
	}
	
	@dirty
	@nativeStub
	@local
	public native CreatureObject asCreatureObject();

	@dirty
	public boolean isNextActionPast() {
		return nextAction.isPast();
	}

	@dirty
	public abstract boolean isTrainerCreature() {
		return false;
	}

	@read
	public boolean isSwimming() {
		return stateBitmask & CreatureState.SWIMMING;
	}

	@dirty
	public ZoneClientSession getClient() {
		return owner;
	}

	@weakReference
	@read
	public ControlDevice getControlDevice() {
		return controlDevice;
	}

	@read
	public float getSwimHeight() {
		return swimHeight;
	}

	@read
	public boolean isIncapacitated() {
		return posture == CreaturePosture.INCAPACITATED;
	}

	@read
	public boolean isDead() {
		return posture == CreaturePosture.DEAD;
	}

	@read
	public boolean isKnockedDown() {
		return posture == CreaturePosture.KNOCKEDDOWN;
	}

	@read
	public boolean isKneeling() {
		return posture == CreaturePosture.CROUCHED;
	}

	@read
	public boolean isProne() {
		return posture == CreaturePosture.PRONE;
	}

	@read
	public boolean isStanding() {
		return posture == CreaturePosture.UPRIGHT;
	}

	@read
	public boolean isSitting() {
		return posture == CreaturePosture.SITTING;
	}

	@read
	public boolean isSkillAnimating() {
		return posture == CreaturePosture.SKILLANIMATING;
	}

	@read
	public boolean isRallied() {
		return stateBitmask & CreatureState.RALLIED;
	}

	@read
	public boolean isInCombat() {
		return stateBitmask & CreatureState.COMBAT;
	}

	@read
	public boolean isDizzied() {
		return stateBitmask & CreatureState.DIZZY;
	}

	@read
	public boolean isBerserked() {
		return stateBitmask & CreatureState.BERSERK;
	}

	@read
	public boolean isStunned() {
		return stateBitmask & CreatureState.STUNNED;
	}	

	@read
	public boolean isBlinded() {
		return stateBitmask & CreatureState.BLINDED;
	}

	@read
	public boolean isIntimidated() {
		return stateBitmask & CreatureState.INTIMIDATED;
	}

	@read
	public boolean isSnared() {
		return stateBitmask & CreatureState.IMMOBILIZED;
	}

	@read
	public boolean isImmobilized() {
		return stateBitmask & CreatureState.IMMOBILIZED;
	}

	@read
	public boolean isRooted() {
		return stateBitmask & CreatureState.FROZEN;
	}

	@read
	public boolean isFrozen() {
		return stateBitmask & CreatureState.FROZEN;
	}

	@read
	public boolean isDiseased() {
		return stateBitmask & CreatureState.DISEASED;
	}

	@read
	public boolean isPoisoned() {
		return stateBitmask & CreatureState.POISONED;
	}

	@read
	public boolean isBleeding() {
		return stateBitmask & CreatureState.BLEEDING;
	}

	@read
	public boolean isOnFire() {
		return stateBitmask & CreatureState.ONFIRE;
	}

	@read
	public boolean isRidingMount() {
		return stateBitmask & CreatureState.RIDINGMOUNT;
	}

	@read
	public boolean hasRidingCreature() {
		return stateBitmask & CreatureState.MOUNTEDCREATURE;
	}

	@read
	public boolean isPeaced() {
		return stateBitmask & CreatureState.PEACE;
	}

	@read
	public boolean isMeditating() {
		return stateBitmask & CreatureState.ALERT;
	}

	@read
	public boolean isAiming() {
		return stateBitmask & CreatureState.AIMING;
	}

	@read
	public boolean isInCover() {
		return stateBitmask & CreatureState.COVER;
	}

	@read
	public boolean isRunning() {
		return currentSpeed >= runSpeed;
	}

	@dirty
	public abstract boolean isNonPlayerCreatureObject() {
		return false;
	}

	@dirty
	public abstract boolean isDroidObject() {
		return false;
	}	

	@dirty
	public boolean isPlayerCreature() {
		return getPlayerObject() != null;
	}

	@dirty
	public abstract boolean isInformantCreature() {
		return false;
	}

	@dirty
	public native CampSiteActiveArea getCurrentCamp();

	@read
	public byte getCurrentWeather() {
		return currentWeather;
	}

	@preLocked
	public void setCurrentWeather(byte value) {
		currentWeather = value;
	}

	@read
	public byte getCurrentWind() {
		return currentWind;
	}

	@preLocked
	public void setCurrentWind(byte value) {
		currentWind = value;
	}

	@preLocked
	@arg1preLocked
	public native int handleObjectMenuSelect(CreatureObject player, byte selectedID);

	@read
	public boolean isInvisible() {
		return invisible;
	}

	@preLocked
	public void setInvisible(boolean invis) {
		invisible = invis;
	}

	public string getAlternateAppearance() {
		return alternateAppearance;
	}

	@local
	@dirty
	public Mutex getSkillModMutex() {
		return skillModMutex;
	}

	@dirty
	public native float calculateCostAdjustment(byte stat, float baseCost);

	@preLocked
	public native void updateSpeedAndAccelerationMods();

	@preLocked
	public native void setFaction(unsigned int crc);

	/**
	 * Destroys a PlayerCreature from the database. If this object is not a PlayerCreature then the method will return without doing anything.
	 * @pre { this is locked }
	 * @post { this is locked }
	 * @param destroyContainedObjects if true, will destroy from database all its contained objects
	 */
	@preLocked
	public abstract native void destroyPlayerCreatureFromDatabase(boolean destroyContainedObjects = false);

	public native float getTemplateRadius();

	@preLocked
	public abstract void reloadTemplate() {
	}
}
