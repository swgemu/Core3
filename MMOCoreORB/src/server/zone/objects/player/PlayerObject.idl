/*
				Copyright <SWGEmu>
		See file COPYING for copying conditions.*/

package server.zone.objects.player;

import engine.service.proto.BaseMessage;
import engine.service.proto.BasePacket;
import engine.util.u3d.Vector3;
import server.zone.objects.building.BuildingObject;
import server.zone.objects.creature.CreatureObject;
import server.zone.objects.creature.ai.AiAgent;
import server.zone.objects.intangible.IntangibleObject;
import server.zone.objects.player.events.PlayerDisconnectEvent;
import server.zone.objects.player.events.PlayerRecoveryEvent;
import server.zone.objects.player.events.ForceRegenerationEvent;
import server.zone.objects.player.events.PvpTefRemovalTask;
import server.zone.objects.scene.SceneObject;
import server.zone.objects.structure.StructureObject;
import server.zone.objects.waypoint.WaypointObject;
include templates.SharedObjectTemplate;
import server.zone.ZoneClientSession;
import server.login.account.Account;
include system.lang.ref.Reference;
import system.util.SortedVector;
import system.util.Vector;
import system.util.VectorMap;
import system.util.SynchronizedSortedVector;
include system.lang.Time;
include server.login.account.GalaxyAccountInfo;
include server.zone.objects.draftschematic.DraftSchematic;
include server.zone.objects.player.badges.Badges;
include server.zone.objects.player.sui.SuiBox;
include server.zone.objects.player.ValidatedPosition;
include server.zone.objects.player.variables.Ability;
include server.zone.objects.player.variables.AbilityList;
include server.zone.objects.player.variables.FactionStandingList;
include server.zone.objects.player.variables.FriendList;
include server.zone.objects.player.variables.FrsData;
include server.zone.objects.player.variables.IgnoreList;
include server.zone.objects.player.variables.SchematicList;
include server.zone.objects.player.variables.WaypointList;
include server.zone.objects.player.variables.PlayerQuestData;
include server.zone.objects.scene.variables.DeltaVector;
include server.zone.objects.scene.variables.DeltaVectorMap;
include server.zone.objects.scene.variables.DeltaBitArray;

class PlayerObject extends IntangibleObject {
	protected unsigned int characterBitmask;
	protected string title;

	protected string savedTerrainName;
	protected unsigned long savedParentID;

	@dereferenced
	protected Badges badges;

	protected int forcePower;
	protected int forcePowerMax;

	protected int foodFilling;
	protected int foodFillingMax;

	protected int drinkFilling;
	protected int drinkFillingMax;

	protected int reactionFines;

	protected transient GalaxyAccountInfo galaxyAccountInfo;

	protected transient Account account;

	@dereferenced
	protected Time reactionFineTimestamp; // Timestamp of when player was given a fine

	@dereferenced
	protected Time reactionFineMailTimestamp; // Timestamp of last mail sent regarding fine being due

	protected string starterProfession;

	protected string bankLocation;

	protected boolean teleporting;

	protected boolean onLoadScreen;

	protected boolean muted;
	protected string mutedReason;
	protected int tosVersionAccepted;

	@dereferenced
	protected SortedVector<unsigned long> ownedStructures;

	@dereferenced
	protected SortedVector<unsigned long> ownedVendors;

	protected byte maximumLots;

	protected int jediState;
	protected unsigned int adminLevel;
	protected int priviledgeFlag;

	protected byte languageID;

	@dereferenced
	protected VectorMap<string, int> xpTypeCapList;

	@dereferenced
	protected VectorMap<unsigned int, string> commandMessageStrings;

	@dereferenced
	protected DeltaVectorMap<string, int> experienceList;
	
	@dereferenced
	protected FrsData frsData;

	@dereferenced
	protected WaypointList waypointList;

	@dereferenced
	protected AbilityList abilityList;

	@dereferenced
	protected FriendList friendList;

	@dereferenced
	protected IgnoreList ignoreList;

	@dereferenced
	protected FactionStandingList factionStandingList;

	@dereferenced
	protected SchematicList schematicList;

	@dereferenced
	protected Vector<unsigned int> incapacitationTimes;

	protected unsigned int suiBoxNextID;

	@dereferenced
	protected VectorMap<unsigned int, SuiBox> suiBoxes;

	@dereferenced
	protected SortedVector<unsigned int> chatRooms;

	@dereferenced
	protected SortedVector<unsigned int> ownedChatRooms;

	@dereferenced
	protected transient SynchronizedSortedVector<CreatureObject> duelList;

	@dereferenced
	protected Vector<unsigned long> newKillerList;

	protected unsigned long declaredResidence;

	protected unsigned long cloningFacility;

	@dereferenced
	protected SortedVector<unsigned long> persistentMessages;

	protected unicode biography; //char biography

	@dereferenced
	protected SortedVector<string> consentList;

	//npc conversation
	protected string lastNpcConvoMessage;
	protected string lastNpcConvo;

	@dereferenced
	protected Vector<string> lastNpcConvoOptions; //Deprecate. Conversation could also be a session.

	protected unsigned long conversatingCreature; //If conversation is a session, then this would be stored on the session.

	// Jedi Trainers.
	@local
	@dereferenced
	protected Vector3 trainerCoordinates;

	protected string trainerZoneName;

	@dereferenced
	protected transient Reference<PlayerDisconnectEvent> disconnectEvent;

	@dereferenced
	protected transient Reference<PlayerRecoveryEvent> recoveryEvent;

	@dereferenced
	protected transient Reference<ForceRegenerationEvent> forceRegenerationEvent;

	@dereferenced
	protected Time logoutTimeStamp;

	protected int onlineStatus;

	protected int skillPoints; //TODO: This could be encapsulated in the skill list.

	protected int pvpRating;
	
	@dereferenced
	protected Time lastPvpRatingUpdate; // Timestamp of when last time player received a pvp rating change

	@dereferenced
	protected Vector<byte> hologrindProfessions;

	protected unsigned int clientLastMovementStamp;

	@dereferenced
	protected Time serverLastMovementStamp;

	@dereferenced
	protected ValidatedPosition lastValidatedPosition;

	protected unsigned int accountID;

	@dereferenced
	protected VectorMap<string, string> screenPlayData;

	@dereferenced
	protected SortedVector<string> permissionGroups;

	protected unsigned long performanceBuffTarget;

	protected boolean debugOutput;

	protected float visibility;

	@dereferenced
	protected Time lastVisibilityUpdateTimestamp;
	
	@dereferenced
	protected Time lastBhPvpCombatActionTimestamp;

	@dereferenced
	protected Time lastGcwPvpCombatActionTimestamp;

	@dereferenced
	protected Reference<PvpTefRemovalTask> pvpTefTask;

	@dereferenced
	protected Time lastDigestion;

	@dereferenced
	protected SortedVector<AiAgent> activePets;

	@dereferenced
	protected DeltaBitArray activeQuests;

	@dereferenced
	protected DeltaBitArray completedQuests;

	protected string installedHoloEmote;

	protected int holoEmoteUseCount;

	protected string spouseName;

	@dereferenced
	protected VectorMap<unsigned int, string> chosenVeteranRewards; // milestone, templateFile

	@dereferenced
	protected SortedVector<unsigned long> currentEventPerks;

	@weakReference
	protected transient SceneObject currentClientPathWaypoint;

	/**
	 * the key is the quest.hashCode()
	 */
	@dereferenced
	@rawTemplate(value = "uint32, PlayerQuestData")
	protected DeltaVectorMap playerQuestsData;

	public static final int LFG = 1;
	public static final int NEWBIEHELPER = 2;
	public static final int ROLEPLAYER = 4;
	public static final int AFK = 0x80;
	public static final int LD = 0x100;
	public static final int FACTIONRANK = 0x200;
	public static final int ANONYMOUS = 0x80000000;

	public static final int ONLINE = 1;
	public static final int OFFLINE = 2;
	public static final int LINKDEAD = 3;
	public static final int LOGGINGIN = 4;
	public static final int LOGGINGOUT = 5;
	public static final int LOADING = 6;

	public static final int PVP_RATING_FLOOR = 500;
	public static final unsigned long PVP_RESET_TIME = 259200000; // 3 days

	public PlayerObject() {
		characterBitmask = 0;

		commandMessageStrings.setNoDuplicateInsertPlan();

		bankLocation = "";

		teleporting = false;
		onLoadScreen = false;

		muted = false;
		mutedReason = "";

		debugOutput = false;

		suiBoxNextID = 0;

		savedParentID = 0;

		declaredResidence = 0;

		cloningFacility = 0;

		skillPoints = 0;

		conversatingCreature = 0;

		forcePower = 0;
		forcePowerMax = 0;

		jediState = 0;

		pvpRating = 1200;

		trainerZoneName = "";

		duelList.setNoDuplicateInsertPlan();
		persistentMessages.setNoDuplicateInsertPlan();
		consentList.setNoDuplicateInsertPlan();
		activePets.setNoDuplicateInsertPlan();
		chosenVeteranRewards.setNoDuplicateInsertPlan();

		accountID = 0;

		clientLastMovementStamp = 0;

		maximumLots = 10;

		adminLevel = 0;
		priviledgeFlag = 0;

		languageID = 0;

		setOffline();

		performanceBuffTarget = 0;

		visibility = 0;
		lastVisibilityUpdateTimestamp.updateToCurrentTime();

		lastBhPvpCombatActionTimestamp.updateToCurrentTime();
		lastGcwPvpCombatActionTimestamp.updateToCurrentTime();

		lastDigestion.updateToCurrentTime();

		installedHoloEmote = "";

		holoEmoteUseCount = 0;

		spouseName = "";

		foodFilling = 0;
		foodFillingMax = 0;

		drinkFilling = 0;
		drinkFillingMax = 0;

		reactionFines = 0;
		
		lastPvpRatingUpdate.updateToCurrentTime();
                
                tosVersionAccepted = 0;
		
		Logger.setLoggingName("PlayerObject");
	}

	public void finalize() {

	}

	public void setClientPathWaypoint(SceneObject obj) {
		currentClientPathWaypoint = obj;
	}

	public native void initializeAccount();

	/**
	 * Gets called when this objects is loaded from database
	 * @pre { this locked }
	 * @post { this locked }
	 */
	public native void notifyLoadFromDatabase();

	public native void unload();
	
	public native int calculateBhReward();

	@local
	public native void loadTemplateData(SharedObjectTemplate templateData);
	public native void initializeTransientMembers();

	@dirty
	public native void sendBaselinesTo(SceneObject player);

	@dirty
	@local
	public native void sendMessage(BasePacket msg);

	public synchronized void addOwnedStructure(StructureObject obj) {
		if (obj == null)
			return;

		ownedStructures.put(obj.getObjectID());
	}

	public synchronized void removeOwnedStructure(StructureObject obj) {
		if (obj == null)
			return;

		ownedStructures.drop(obj.getObjectID());
		if(obj.getObjectID() == getDeclaredResidence())
			setDeclaredResidence(null);

	}

	@dirty
	public int getAcceptedTOSVersion() {
		return tosVersionAccepted;
	}

	public void setAcceptedTOSVersion(int version) {
		tosVersionAccepted = version;
	}

	@dirty
	public native void checkAndShowTOS();

	@dirty
	public synchronized int getTotalOwnedStructureCount() {
		return ownedStructures.size();
	}

	@dirty
	public synchronized boolean isOwnedStructure(StructureObject obj) {
		if (obj == null)
			return false;

		return ownedStructures.contains(obj.getObjectID());
	}

	@dirty
	public synchronized unsigned long getOwnedStructure(int i) {
		return ownedStructures.get(i);
	}

	@dirty
	public native int getLotsRemaining();

	@dirty
	public synchronized boolean hasLotsRemaining(int lots) {
		return lots <= getLotsRemaining();
	}

	public native void notifySceneReady();

	public native void checkPendingMessages();

	 /**
	 * Adds experience of a type to the player's experience pool.
	 * @pre { this is locked }
	 * @post { this is locked }
	 * @param xpType The string value for the type of experience to add.
	 * @param xp The value of experience to add.
	 * @param notifyClient Boolean to determing whether the client should receive a delta packet for the experience gain.
	 * @return returns total experience awarded
	 */
	public native int addExperience(final string xpType, int xp, boolean notifyClient = true);

    /**
	 * Removes experience of a type from the player's experience pool.
	 * @pre { this is locked }
	 * @post { this is locked }
	 * @param xpType The string value for the type of experience to remove.
	 * @param notifyClient Boolean to determing whether the client should receive a delta packet for the experience loss.
	 */
	public native void removeExperience(final string xpType, boolean notifyClient = true);

    /**
	 * Checks if the player has capped the experience type.
	 * @param xpType The string value for the type of experience to check.
	 * @return true if experience is capped, false otherwise.
	 */
	@dirty
	public native boolean hasCappedExperience(final string xpType);

	/**
	 * Adds waypoint object to waypointList
	 * @pre { this is locked }
	 * @post { this is locked, waypoint object is in the list }
	 * @param waypoint waypoint object to add
	 * @param checkName determines whether to remove existing Waypoint with equal customName
	 * @param notifyClient determines whether to update the client with the changes
	 */
	public native void addWaypoint(WaypointObject waypoint, boolean checkName, boolean notifyClient = true);
	public native void setWaypoint(WaypointObject waypoint, boolean notifyClient = true);

	/** 
	 * Adds a new waypoint with the specified coordinates
	 * @pre { this is locked }
	 * @post { this is locked, waypoint object is in the list }
	 * @param planet planet where waypoint will be created
	 * @param positionX waypoint position X
	 * @param positionY waypoint position Y
	 * @param notifyClient determines whether to update the client with the changes
	 */
	@local
	public native WaypointObject addWaypoint(final string planet, float positionX, float positionY, boolean notifyClient = true);

	/**
	 * Removes a waypoint from this player
	 * @pre { this is locked }
	 * @post { this is locked, waypoint list doesnt contain the specified waypoint }
	 * @param waypointID waypoint object id to remove
	 * @param notifyClient determines whether to update the client with the changes
	 * @param destroy determines whether to remove the waypoint from the database
	 */
	public native void removeWaypoint(unsigned long waypointID, boolean notifyClient = true, boolean destroy = true);

	/**
	 * Updates the client with a waypoint change
	 * @pre { this is locked }
	 * @post { this is locked }
	 * @param waypointID waypoint object id to update
	 */
	public native void updateWaypoint(unsigned long waypointID);

	/**
	 * Removes a waypoint of a special type from this player
	 * @pre { this is locked }
	 * @post { this is locked, waypoint list doesnt contain a waypoint of the special type }
	 * @param specialTypeID id of special type to remove
	 * @param notifyClient determines whether to update the client with the changes
	 */
	public native void removeWaypointBySpecialType(int specialTypeID, boolean notifyClient = true);

	/**
	 * Gets the first waypoint of a special type from this player
	 * @param specialTypeID id of special type to find
	 */
	@dirty
	public native WaypointObject getWaypointBySpecialType(int specialTypeID);

	@dirty
	public native WaypointObject getSurveyWaypoint();

	public boolean hasWaypoint(unsigned long objectID) {
		return waypointList.contains(objectID);
	}

	public WaypointObject getWaypointAt(float x, float y, string planet) {
		return waypointList.getWaypointAt(x, y, planet);
	}

	@dirty
	@local
	public void insertWaypointListToMessage(BaseMessage msg) {
		waypointList.insertToMessage(msg);
	}

	@dirty
	public int getWaypointListSize() {
		return waypointList.size();
	}

	@dirty
	public WaypointObject getWaypoint(int index) {
		return waypointList.getValueAt(index);
	}

	/**
	 * Adds new abilities commands to player
	 * @pre { this is locked }
	 * @post { this is locked }
	 * @param abilities Vector of abilities to add
	 * @param notifyClient determines whether to update the client with the changes
	 */
	@local
	public native void addAbilities(@dereferenced Vector<Ability> abilities, boolean notifyClient = true);

	@local
	public native void addAbility(Ability ability, boolean notifyClient = true);

	/**
	 * Removes certifications from player
	 * @pre { this is locked }
	 * @post { this is locked }
	 * @param skills Vector of skills to add
	 * @param notifyClient determines whether to update the client with the changes
	 */
	@local
	public native void removeAbilities(@dereferenced Vector<Ability> abilities, boolean notifyClient = true);

	@local
	public native void removeAbility(Ability ability, boolean notifyClient = true);

	@local
	public native boolean addSchematics(@dereferenced Vector<DraftSchematic> schematics, boolean notifyClient = true);

	@local
	public native void removeSchematics(@dereferenced Vector<DraftSchematic> schematics, boolean notifyClient = true);

	@local
	public native boolean addRewardedSchematic(DraftSchematic schematic, short type, int quantity = 1, boolean notifyClient = true);

	@local
	public native void removeRewardedSchematic(DraftSchematic schematic, boolean notifyClient = true);

	@local
	public native void decreaseSchematicUseCount(DraftSchematic schematic); 

	//@local
	//public native void addSchematic(DraftSchematic schematic, boolean notifyClient = true);

	//@local
	//public native void removeSchematic(DraftSchematic schematic, boolean notifyClient = true);

	/**
	 * Sets the specified language id
	 * @pre { }
	 * @post { }
	 * @param language language id to set
	 * @param notifyClient determines whether to update the client with the changes
	 */
	public native void setLanguageID(byte language, boolean notifyClient = true);

	/**
	 * Adds a friend to the friend list
	 * @pre { this is locked}
	 * @post { this is locked }
	 * @param name friends name
	 * @param notifyClient determines whether to update the client with the changes
	 */
	public native void addFriend(final string name, boolean notifyClient = true);

	/**
	 * Removes the specified friend from the friend list
	 * @pre { this is locked }
	 * @post { this is locked}
	 * @param name friend name to remove
	 * @param notifyClient determines whether to update the client with the changes
	 */
	public native void removeFriend(final string name, boolean notifyClient = true);

	//Used when a character is renamed
	public native void removeAllReverseFriends(final string oldName);

	/**
	 * Adds a player to the ignore list
	 * @pre { this is locked}
	 * @post { this is locked }
	 * @param name player name
	 * @param notifyClient determines whether to update the client with the changes
	 */
	public native void addIgnore(final string name, boolean notifyClient = true);

	/**
	 * Removes the specified player from the ignore list
	 * @pre { this is locked }
	 * @post { this is locked}
	 * @param name player name to remove
	 * @param notifyClient determines whether to update the client with the changes
	 */
	public native void removeIgnore(final string name, boolean notifyClient = true);

	public native void setTitle(final string characterTitle, boolean notifyClient = true);

	public native void setFoodFilling(int newValue, boolean notifyClient = true);
	public native void setDrinkFilling(int newValue, boolean notifyClient = true);

	/**
	 * Adds the amount of faction points to the faction point list.
	 * @pre { this locked }
	 * @post { this locked }
	 * @param factionName The string key for the faction the faction points are to be added.
	 * @param amount The float amount of faction points to add. 
	 */
	public native void increaseFactionStanding(final string factionName, float amount);
	public native void decreaseFactionStanding(final string factionName, float amount);
	public native void setFactionStanding(final string factionName, float amount);

	public native float getFactionStanding(final string factionName);

	public void setScreenPlayData(final string screenPlay, final string variable, final string data) {
		screenPlayData.put(screenPlay + "_" + variable, data);
	}

	public void deleteScreenPlayData(final string screenPlay, final string variable) {
		screenPlayData.drop(screenPlay + "_" + variable);
	}

	@dirty
	public string getScreenPlayData(final string screenPlay, final string variable) {
		return screenPlayData.get(screenPlay + "_" + variable);
	}

	public native void clearScreenPlayData(final string screenPlay);

	public native void activateRecovery();

	public native void activateForcePowerRegen();

	public native void doRecovery(int latency);

	private native void checkForNewSpawns();

	public native void disconnect(boolean closeClient, boolean doLock);

	public native void reload(ZoneClientSession client);

	public void setOffline() {
		if (isLinkDead()) {
			// clear LD flag
		}

		onlineStatus = OFFLINE;
	}

	public native void setLinkDead(boolean isSafeLogout = false);

	public native void setOnline();

	public void setLoggingOut() {
		onlineStatus = LOGGINGOUT;
	}

	/**
	 * Sends a badges response message
	 * @pre { }
	 * @post { }
	 * @param player CreatureObject to receive badges response message
	 */
	public native void sendBadgesResponseTo(CreatureObject player);

	public native void logout(boolean doLock);

	public native void setJediState(int state, boolean notifyClient = true);

	public native void setActiveQuestsBit(int bitIndex, byte value, boolean notifyClient = true);

	public void clearActiveQuestsBit(int bitIndex, boolean notifyClient = true) {
		setActiveQuestsBit(bitIndex, (byte)0, notifyClient);
	}

	@dirty
	public native boolean canActivateQuest(int questID);

	public native void activateQuest(int questID);

	@dirty
	public boolean hasActiveQuestBitSet(int bitIndex) {
		return activeQuests.getBitValue(bitIndex);
	}

	@dirty
	public boolean hasCompletedQuestsBitSet(int bitIndex) {
		return completedQuests.getBitValue(bitIndex);
	}

	public native void setCompletedQuestsBit(int bitIndex, byte value, boolean notifyClient = true);

	public void clearCompletedQuestsBit(int bitIndex, boolean notifyClient = true) {
		setCompletedQuestsBit(bitIndex, (byte)0, notifyClient);
	}

	public native void completeQuest(int questID);

	@dereferenced
	@local
	@dirty
	public native PlayerQuestData getQuestData(unsigned int questHashCode);

	@dirty
	public boolean hasQuestData(unsigned int questHashCode) {
		return playerQuestsData.contains(questHashCode);
	}

	@local
	public native void setPlayerQuestData(unsigned int questHashCode, @dereferenced PlayerQuestData data, boolean notifyClient = true);

	/**
	 * Gets the faction point list.
	 */
	@local
	@dirty
	public FactionStandingList getFactionStandingList() {
		return factionStandingList;
	}

	//NPC Conversation Methods
	public void setLastNpcConvStr(final string conv) {
		lastNpcConvo = conv;
	}

	public void setLastNpcConvMessStr(final string mess) {
		lastNpcConvoMessage = mess;
	}

	@dirty
	public string getLastNpcConvStr() {
		return lastNpcConvo;
	}

	@dirty
	public string getLastNpcConvMessStr() {
		return lastNpcConvoMessage;
	}

	@dirty
	public string getLastNpcConvOption(int idx) {
		return lastNpcConvoOptions.get(idx);
	}

	public void addLastNpcConvOptions(final string option) {
		lastNpcConvoOptions.add(option);
	}

	@dirty
	public int countLastNpcConvOptions() {
		return lastNpcConvoOptions.size();
	}

	public void clearLastNpcConvOptions() {
		lastNpcConvoOptions.removeAll();
	}

	public void setConversatingCreature(CreatureObject creature) {
		if (creature == null)
			conversatingCreature = 0;
		else
			conversatingCreature = creature.getObjectID();
	}

	@dirty
	public unsigned long getConversatingCreature() {
		return conversatingCreature;
	}

	@local
	public native void setTrainerCoordinates(@dereferenced final Vector3 trainer);

	@local
	@dereferenced
	@dirty
	public native Vector3 getTrainerCoordinates();

	public void setTrainerZoneName(string zoneName) {
		trainerZoneName = zoneName;
	}

	@dirty
	public string getTrainerZoneName() {
		return trainerZoneName;
	}

	@local
	@dirty
	public SortedVector<unsigned long> getPersistentMessages() {
		return persistentMessages;
	}

	public void addPersistentMessage(unsigned long id) {
		persistentMessages.put(id);
	}

	public void dropPersistentMessage(unsigned long id) {
		persistentMessages.drop(id);
	}

	/**
	 * Unloads all the spawned creatures from the datapad control devices
	 */
	public native void unloadSpawnedChildren();

	public void addToConsentList(final string name) {
		consentList.put(name);
	}

	public boolean hasInConsentList(final string name) {
		return consentList.contains(name);
	}

	public void removeFromConsentList(final string name) {
		consentList.drop(name);
	}

	@dirty
	public string getConsentName(int i) {
		return consentList.get(i);
	}

	@dirty
	public int getConsentListSize() {
		return consentList.size();
	}

	@dirty
	public int getReactionFines() {
		return reactionFines;
	}

	@local
	@dirty
	public string getFactionRank() {
		return factionStandingList.getFactionRank();
	}

	@local
	public void setFactionRank(final string rank) {
		factionStandingList.setFactionRank(rank);
	}

	public void setCommandMessageString(unsigned int actionCRC, string message) {
		commandMessageStrings.put(actionCRC, message);
	}

	public void removeCommandMessageString(unsigned int actionCRC) {
		commandMessageStrings.drop(actionCRC);
	}

	@read
	public unsigned long getDeclaredResidence() {
		return declaredResidence;
	}

	public void setDeclaredResidence(BuildingObject residence) {
		if (residence == null)
			declaredResidence = 0;
		else
			declaredResidence = residence.getObjectID();
	}

	public void setCloningFacility(BuildingObject cloningfac) {
		if (cloningfac == null)
			cloningFacility = 0;
		else
			cloningFacility = cloningfac.getObjectID();
	}

	@read
	public unsigned long getCloningFacility() {
		return cloningFacility;
	}

	/**
	 * Notifies all reverse friends online status
	 * @pre { }
	 * @post { }
	 */
	public native void notifyOnline();

	public native void doDigest(int fillingReduction);

	@dirty
	public boolean isDigesting() {
		if (getDrinkFilling() > 0 || getFoodFilling() > 0) {
			return true;
		} else {
			return false;
		}
	}

	@read
	public string getSavedTerrainName() {
		return savedTerrainName;
	}

	public void setSavedParentID(unsigned long id) {
		savedParentID = id;
	}

	public void setSavedTerrainName(final string name) {
		savedTerrainName = name;
	}

	public native void setForcePower(int fp, boolean notifyClient = true);

	public native void setForcePowerMax(int newValue, boolean notifyClient = true);

	public native void doForceRegen();

	@dirty
	public native int getForcePowerRegen();

	@read
	public unsigned long getSavedParentID() {
		return savedParentID;
	}

	@dirty
	public native unsigned int getNewSuiBoxID(unsigned int type);

	@dirty
	public boolean hasSuiBox(unsigned int boxID) {
		return suiBoxes.contains(boxID);
	}

	@reference
	@dirty
	public SuiBox getSuiBox(unsigned int boxID) {
		return suiBoxes.get(boxID);
	}

	/**
	 * Removes the specified box id and optionally closes the client sui
	 */
	public native void removeSuiBox(unsigned int boxID, boolean closeWindowToClient = false);

	public native void removeSuiBoxType(unsigned int windowType);

	@dirty
	public boolean hasSuiBoxWindowType(unsigned int windowType) {
		unsigned int type = 0;
		
		for (int i = 0; i < suiBoxes.size(); ++i) {
			SuiBox sui = suiBoxes.get(i);
			
			type = sui.getWindowType();
			
			if (windowType == type)
				return true;
		}

		return false;
	}

	public void closeSuiWindowType(unsigned int windowType) {
		if (hasSuiBoxWindowType(windowType)) {
			SuiBox sui = getSuiBoxFromWindowType(windowType);
			
			if (sui != null) {
				sendMessage(sui.generateCloseMessage());
				removeSuiBox(sui.getBoxID());
			}
		}
	}

	@reference
	@dirty
	public SuiBox getSuiBoxFromWindowType(unsigned int windowType) {
		unsigned int type = 0;

		for (int i = 0; i < suiBoxes.size(); ++i) {
			SuiBox sui = suiBoxes.get(i);
			
			if (windowType == sui.getWindowType())
				return sui;
		}

		return null;
	}

	public void addSuiBox(SuiBox sui) {
		unsigned int key = sui.getBoxID();
		suiBoxes.put(key, sui);
	}

	public native void addPermissionGroup(final string group, boolean updatePermissions = false);

	public native void removePermissionGroup(final string group, boolean updatePermissions = false);

	public native void updateInRangeBuildingPermissions();

	@dirty
	public native boolean hasPermissionGroup(final string group);

	@local
	@dirty
	public SortedVector<string> getPermissionGroups() {
		return permissionGroups;
	}

	public native void addIncapacitationTime();

	@read
	public byte getIncapacitationCounter() {
		return incapacitationTimes.size();
	}

	public void resetIncapacitationTimes() {
		incapacitationTimes.removeAll();
	}

	//Duel list manipulation methods
	public void addToDuelList(CreatureObject targetPlayer) {
		duelList.put(targetPlayer);
	}

	public void removeFromDuelList(CreatureObject targetPlayer) {
		duelList.drop(targetPlayer);
	}

	@reference
	@dirty
	public CreatureObject getDuelListObject(int index) {
		return duelList.get(index);
	}

	@dirty
	public boolean requestedDuelTo(CreatureObject targetPlayer) {
		return duelList.contains(targetPlayer);
	}

	@dirty
	public boolean isDuelListEmpty() {
		return duelList.isEmpty();
	}

	@dirty
	public int getDuelListSize() {
		return duelList.size();
	}

	//Active Pets manipulation methods
	public void addToActivePets(AiAgent pet) {
		activePets.put(pet);
	}

	public void removeFromActivePets(AiAgent pet) {
		activePets.drop(pet);
	}

	@dirty
	public AiAgent getActivePet(int index) {
		return activePets.get(index);
	}

	@dirty
	public boolean hasActivePet(AiAgent pet) {
		return activePets.contains(pet);
	}

	@dirty
	public int getActivePetsSize() {
		return activePets.size();
	}

	@read
	public unicode getBiography() {
		return biography;
	}

	/**
	 * Notifies all reverse friends offline status
	 * @pre { }
	 * @post { }
	 */
	public native void notifyOffline();

	public void setBadge(unsigned int badge) {
		badges.setBadge(badge);
	}

	public native void awardBadge(unsigned int badge);

	public void setTeleporting(boolean val) {
		teleporting = val;
	}

	public void setOnLoadScreen(boolean val) {
		onLoadScreen = val;
	}

	@dirty
	public int getNumBadges() {
		return badges.getNumBadges();
	}

	@dirty
	public int getBadgeTypeCount(unsigned int type) {
		return badges.getTypeCount(type);
	}

	@dirty
	public boolean hasFriend(final string name) {
		return friendList.contains(name);
	}

	@dirty
	public int getFriendListSize() {
		return friendList.size();
	}

	public native boolean isIgnoring(final string name);

	public void addReverseFriend(final string name) {
		friendList.addReversePlayer(name);
	}

	public void removeReverseFriend(final string name) {
		friendList.removeReversePlayer(name);
	}

	public native void sendFriendLists();

	/**
	 * Checks to see if this player object has the specified ability.
	 * @param ability The ability to search for.
	 * @return True if the player has the ability.
	 */
	@local
	@dirty
	public boolean hasAbility(final string ability) {
		return abilityList.contains(ability);
	}

	@dirty
	public boolean hasCommandMessageString(unsigned int actionCRC) {
		return commandMessageStrings.contains(actionCRC);
	}

	@read
	public unsigned int getCharacterBitmask() {
		return characterBitmask;
	}

	@read
	public string getTitle() {
		return title;
	}

	@read
	public unsigned int getAdminLevel() {
		return adminLevel;
	}

	public void setAdminLevel(unsigned int adminlvl) {
		adminLevel = adminlvl;
	}
	
	@read
	public int getPriviledgeFlag() {
		return priviledgeFlag;
	}

	public void setPriviledgeFlag(int flag) {
		priviledgeFlag = flag;
	}

	public void setBiography(final unicode bio) {
		biography = bio;
	}

	@dirty
	public boolean hasGodMode() {
		return (adminLevel > 0 && hasAbility("admin"));
	}

	@dirty
	public boolean isPrivileged() {
		return (adminLevel > 6 && hasAbility("admin"));
	}

	@dirty
	public boolean isStaff() {
		return (adminLevel > 10 && hasAbility("admin"));
	}

	@dirty
	public boolean isAdmin() {
		return (adminLevel == 15 && hasAbility("admin"));
	}

	public void setCharacterBitmask(unsigned int bitmask) {
		characterBitmask = bitmask;
	}

	public native boolean setCharacterBit(unsigned int bit, boolean notifyClient = false);
	public native boolean clearCharacterBit(unsigned int bit, boolean notifyClient = false);
	public native void toggleCharacterBit(unsigned int bit);
	/**
	 * is the player AFK
	 */
	@dirty
	public native boolean isLFG();
	public native boolean isAFK();
	public native boolean isAnonymous();
	public native boolean isRoleplayer();
	public native boolean isNewbieHelper();
	@local
	@dirty
	public VectorMap<string, int> getXpTypeCapList() {
	    return xpTypeCapList;
	}

	@local
	@dirty
	public DeltaVectorMap<string, int> getExperienceList() {
		return experienceList;
	}

	@local
	@rawTemplate(value = "uint32, PlayerQuestData")
	@dirty
	public DeltaVectorMap getPlayerQuestsData() {
		return playerQuestsData;
	}

	@local
	@dirty
	public DeltaBitArray getActiveQuests() {
		return activeQuests;
	}

	@local 
	@dirty
	public DeltaBitArray getCompletedQuests() {
		return completedQuests;
	}

	@read
	public int getForcePower() {
		return forcePower;
	}

	@read
	public int getForcePowerMax() {
		return forcePowerMax;
	}

	@local
	@dirty
	public AbilityList getAbilityList() {
		return abilityList;
	}

	@local
	@dirty
	public FrsData getFrsData() {
		return frsData;
	}
	
	@local
	@dirty
	public SchematicList getSchematics() {
		return schematicList;
	}

	@dirty
	public DraftSchematic getSchematic(int i) {
		return schematicList.get(i);
	}

	@local
	@dereferenced
	public native Vector<DraftSchematic> filterSchematicList(CreatureObject player, Vector<unsigned int> enabledTabs, int complexityLevel);

	@read
	public int getFoodFilling() {
		return foodFilling;
	}

	@read
	public int getFoodFillingMax() {
		return foodFillingMax;
	}

	@read
	public int getDrinkFilling() {
		return drinkFilling;
	}

	@read
	public int getDrinkFillingMax() {
		return drinkFillingMax;
	}

	@read
	public int getJediState() {
		return jediState;
	}

	@read
	public byte getLanguageID() {
		return languageID;
	}

	@local
	@dirty
	public DeltaVector<string> getFriendList() {
		return friendList;
	}

	@read
	public boolean isTeleporting() {
		return teleporting;
	}

	@read
	public boolean isOnLoadScreen() {
		return onLoadScreen;
	}

	public void addChatRoom(unsigned int roomID) {
		chatRooms.put(roomID);
	}

	public void removeChatRoom(unsigned int roomID) {
		chatRooms.drop(roomID);
	}

	public void addOwnedChatRoom(unsigned int roomID) {
		ownedChatRooms.put(roomID);
	}

	public void removeOwnedChatRoom(unsigned int roomID) {
		ownedChatRooms.drop(roomID);
	}

	public native int getOwnedChatRoomCount();

	public void setBankLocation(final string location) {
		bankLocation = location;
	}

	@read
	public string getBankLocation() {
		return bankLocation;
	}

	@local
	@dirty
	public DeltaVector<string> getIgnoreList() {
		return ignoreList;
	}

	@dirty
	public int getExperience(final string xp) {
		if (experienceList.contains(xp)) {
			return experienceList.get(xp);
		} else {
			return 0;
		}
	}

	/**
	 * Maximizes all types of experience for the player.
	 */
	public native void maximizeExperience();

	public native void activateMissions();

	@dirty
	public string getCommandMessageString(unsigned int actionCRC) {
		return commandMessageStrings.get(actionCRC);
	}

	@dirty
	public boolean hasBadge(unsigned int badge) {
		return badges.hasBadge(badge);
	}

	public native void clearDisconnectEvent();

	@read
	public boolean isOnline() {
		return onlineStatus != OFFLINE && onlineStatus != LINKDEAD;
	}

	@read
	public boolean isOffline() {
		return onlineStatus == OFFLINE;
	}

	@read
	public boolean isLoading() {
		return onlineStatus == LOADING || onlineStatus == LOGGINGOUT;
	}

	@read
	public boolean isLinkDead() {
		return onlineStatus == LINKDEAD;
	}

	@read
	public boolean isLoggingIn() {
		return onlineStatus == LOGGINGIN;
	}

	@read
	public boolean isLoggingOut() {
		return onlineStatus == LOGGINGOUT;
	}

	@local
	public Time getLastLogout() {
		return logoutTimeStamp;
	}

	@local
	public int getDaysSinceLastLogout() {
		return (int)(logoutTimeStamp.miliDifference() / 1000 / 60 / 60 / 24);
	}

	public void setSkillPoints(int points) {
		skillPoints = points;
	}

	public void addSkillPoints(int points) {
		skillPoints += points;
	}

	@read
	public int getSkillPoints() {
		return skillPoints;
	}

	@local
	public ValidatedPosition getLastValidatedPosition() {
		return lastValidatedPosition;
	}

	public void updateLastValidatedPosition() {
		SceneObject par = super.getParent();
		lastValidatedPosition.update(par);
		serverLastMovementStamp.updateToCurrentTime();
	}

	@read
	public unsigned int getAccountID() {
		return accountID;
	}

	@read
	@dirty
	@local
	public native GalaxyAccountInfo getGalaxyAccountInfo() {
		return galaxyAccountInfo;
	}

	@dirty
	public unsigned long getServerMovementTimeDelta() {
		return serverLastMovementStamp.miliDifference();
	}

	@local
	public Time getServerMovementTimeStamp() {
		return serverLastMovementStamp;
	}

	public void setClientLastMovementStamp(unsigned int stamp) {
		clientLastMovementStamp = stamp;
	}

	public void updateServerLastMovementStamp() {
		serverLastMovementStamp.updateToCurrentTime();
	}

	public void setAccountID(unsigned int id) {
		accountID = id;
	}

	@read
	public unsigned int getClientLastMovementStamp() {
		return clientLastMovementStamp;
	}

	public void addHologrindProfession(byte prof) {
		hologrindProfessions.add(prof);
	}

	@local
	@dirty
	public Vector<byte> getHologrindProfessions() {
		return hologrindProfessions;
	}

	public void setMaximumLots(byte lots) {
		maximumLots = lots;
	}

	@read
	public byte getMaximumLots() {
		return maximumLots;
	}

	@read
	public string getStarterProfession() {
		return starterProfession;
	}

	public void setStarterProfession(string profession) {
		starterProfession = profession;
	}

	@read
	public unsigned long getPerformanceBuffTarget() {
		return performanceBuffTarget;
	}

	public void setPerformanceBuffTarget(unsigned long target) {
		performanceBuffTarget = target;
	}

	public void setDebug(boolean value) {
		debugOutput = value;
	}

	@read
	public boolean getDebug() {
		return debugOutput;
	}

	@read
	public float getVisibility() {
		return visibility;
	}

	public void setVisibility(float value) {
		visibility = value;
		lastVisibilityUpdateTimestamp.updateToCurrentTime();
	}

	@dereferenced
	@local
	public native Time getLastVisibilityUpdateTimestamp();
	
	@dereferenced
	@local
	public native Time getLastBhPvpCombatActionTimestamp();

	@dereferenced
	@local
	public native Time getLastGcwPvpCombatActionTimestamp();
	
	public native void updateLastPvpCombatActionTimestamp(boolean updateGcwAction, boolean updateBhAction);

	public native void updateLastBhPvpCombatActionTimestamp();

	public native void updateLastGcwPvpCombatActionTimestamp();

	public native boolean hasPvpTef();
	
	public native boolean hasBhTef();
	
	public native void schedulePvpTefRemovalTask(boolean removeGcwTefNow, boolean removeBhTefNow);

	public native void schedulePvpTefRemovalTask(boolean removeNow = false);

	public void addVendor(SceneObject vendor) {
		ownedVendors.add(vendor.getObjectID());
	}

	public void removeVendor(SceneObject vendor) {
		ownedVendors.removeElement(vendor.getObjectID());
	}

	@dirty
	public native int getVendorCount();

	@local
	public SortedVector<unsigned long> getOwnedVendors() {
		return ownedVendors;
	}

	public native void destroyObjectFromDatabase(boolean destroyContainedObjects = false);

	//Used when character is deleted
	private native void removeAllFriends();
	public native void deleteAllPersistentMessages();
	private native void deleteAllWaypoints();

	@read
	public boolean isJedi() {
		return jediState >= 2; //TODO: Implement jedi constants.
	}

	public boolean isJediLight() {
		return jediState == 4; // Light FRS.
	}

	public boolean isJediDark() {
		return jediState == 8; // Dark FRS.
	}

	@read
	public boolean isMuted() {
		return muted;
	}

	public void setMutedState(boolean mute) {
		muted = mute;
	}

	@read
	public string getMutedReason() {
		return mutedReason;
	}

	public void setMutedReason(string reason) {
		mutedReason = reason;
	}

	@read
	public string getInstalledHoloEmote(){
		return installedHoloEmote;
	}

	public void setInstalledHoloEmote(string holoEmote){
		installedHoloEmote = holoEmote;
		holoEmoteUseCount = 20;
	}

	public void removeInstalledHoloEmote(){
		installedHoloEmote = "";
		holoEmoteUseCount = 0;
	}

	@read
	public int getHoloEmoteUseCount(){
		return holoEmoteUseCount;
	}

	public void decreaseHoloEmoteUseCount(){
		holoEmoteUseCount = holoEmoteUseCount - 1;
		if( holoEmoteUseCount < 0 )
			holoEmoteUseCount = 0;
	}

	@read
	public boolean isMarried(){
		return spouseName != "";
	}

	@read
	public string getSpouseName(){
		return spouseName;
	}

	public void setSpouseName( string firstName ){
		 spouseName = firstName;
	}

	public void removeSpouse(){
		spouseName = "";
	}

	@dirty
	public Account getAccount() {
		return account;
	}

	@dirty
	public string getChosenVeteranReward( unsigned int milestone ) {
		return galaxyAccountInfo.getChosenVeteranReward(milestone);
	}

	@dirty
	public native boolean hasChosenVeteranReward( final string rewardTemplate ) {
		return galaxyAccountInfo.hasChosenVeteranReward(rewardTemplate);
	}

	@dirty
	public void clearVeteranReward( unsigned int milestone ){
		galaxyAccountInfo.clearVeteranReward(milestone);
	}

	public void addEventPerk(SceneObject deed) {
		currentEventPerks.put(deed.getObjectID());
	}

	public void removeEventPerk(SceneObject deed) {
		currentEventPerks.drop(deed.getObjectID());
	}

	public int getEventPerkCount() {
		return currentEventPerks.size();
	}

	public native int getCharacterAgeInDays();

	public void addToReactionFines(int fine) {
		reactionFines = reactionFines + fine;
	}

	public void setReactionFines(int amount) {
		reactionFines = amount;
	}

	public void subtractFromReactionFines(int amount) {
		reactionFines = reactionFines - amount;
	}

	public void updateReactionFineTimestamp() {
		reactionFineTimestamp.updateToCurrentTime();
	}

	public void updateReactionFineMailTimestamp() {
		reactionFineMailTimestamp.updateToCurrentTime();
	}

	@local
	public Time getReactionFineTimestamp() {
		return reactionFineTimestamp;
	}

	@local
	public Time getReactionFineMailTimestamp() {
		return reactionFineMailTimestamp;
	}

	public int getXpCap(final string type) {
		return xpTypeCapList.get(type);
	}

	@dirty
	public native int getSpentJediSkillPoints();

	@dirty
	public native boolean hasSchematic(DraftSchematic schematic) {
		return schematicList.contains(schematic);
	}

	public native boolean hasEventPerk(final string templatePath);

	public native void doFieldFactionChange(int newStatus);

	public void addToKillerList(unsigned int playerID) {
		if (lastPvpRatingUpdate.miliDifference() >= PVP_RESET_TIME && newKillerList.size() > 0)
			newKillerList.removeAll();
		
		newKillerList.add(0, playerID);

		if (newKillerList.size() > 20)
			newKillerList.remove(newKillerList.size() - 1);
		
		lastPvpRatingUpdate.updateToCurrentTime();
	}

	public boolean hasOnKillerList(unsigned int playerID) {
		if (lastPvpRatingUpdate.miliDifference() >= PVP_RESET_TIME && newKillerList.size() > 0) {
			newKillerList.removeAll();
			return false;
		}
		
		return newKillerList.contains(playerID);
	}

	@read
	public int getPvpRating() {
		if (pvpRating == 0)
			return 1200;

		return pvpRating;
	}

	public void setPvpRating(int rating) {
		if (rating < PVP_RATING_FLOOR)
			rating = PVP_RATING_FLOOR;

		pvpRating = rating;
	}
}
