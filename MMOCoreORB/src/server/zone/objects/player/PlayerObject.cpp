/*
 *	server/zone/objects/player/PlayerObject.cpp generated by engine3 IDL compiler 0.60
 */

#include "PlayerObject.h"

#include "server/zone/objects/scene/SceneObject.h"

#include "server/zone/objects/creature/CreatureObject.h"

#include "server/zone/objects/creature/commands/QueueCommand.h"

#include "server/zone/managers/objectcontroller/ObjectController.h"

#include "server/zone/objects/structure/StructureObject.h"

#include "server/zone/ZoneClientSession.h"

#include "server/zone/objects/waypoint/WaypointObject.h"

#include "server/zone/Zone.h"

#include "server/zone/templates/SharedObjectTemplate.h"

#include "server/zone/objects/creature/CreatureObject.h"

#include "server/chat/room/ChatRoom.h"

#include "server/zone/objects/building/BuildingObject.h"

#include "server/zone/objects/tangible/tool/SurveyTool.h"

#include "server/zone/objects/tangible/tool/CraftingTool.h"

#include "server/zone/objects/player/events/PlayerDisconnectEvent.h"

#include "server/zone/objects/player/events/PlayerRecoveryEvent.h"

#include "server/zone/objects/player/sui/SuiBox.h"

/*
 *	PlayerObjectStub
 */

enum {RPC_FINALIZE__ = 6,RPC_NOTIFYLOADFROMDATABASE__,RPC_UNLOAD__,RPC_INITIALIZETRANSIENTMEMBERS__,RPC_SENDBASELINESTO__SCENEOBJECT_,RPC_SENDMESSAGE__BASEPACKET_,RPC_ADDOWNEDSTRUCTURE__STRUCTUREOBJECT_,RPC_REMOVEOWNEDSTRUCTURE__STRUCTUREOBJECT_,RPC_GETTOTALOWNEDSTRUCTURECOUNT__,RPC_ISOWNEDSTRUCTURE__STRUCTUREOBJECT_,RPC_GETOWNEDSTRUCTURE__INT_,RPC_GETLOTSREMAINING__,RPC_HASLOTSREMAINING__INT_,RPC_NOTIFYSCENEREADY__,RPC_ADDEXPERIENCE__STRING_INT_BOOL_,RPC_REMOVEEXPERIENCE__STRING_BOOL_,RPC_ADDWAYPOINT__WAYPOINTOBJECT_BOOL_BOOL_,RPC_SETWAYPOINT__WAYPOINTOBJECT_BOOL_,RPC_ADDWAYPOINT__STRING_FLOAT_FLOAT_BOOL_,RPC_REMOVEWAYPOINT__LONG_BOOL_,RPC_SETLANGUAGEID__BYTE_BOOL_,RPC_ADDFRIEND__STRING_BOOL_,RPC_REMOVEFRIEND__STRING_BOOL_,RPC_ADDIGNORE__STRING_BOOL_,RPC_REMOVEIGNORE__STRING_BOOL_,RPC_SETTITLE__STRING_BOOL_,RPC_SETFOODFILLING__INT_BOOL_,RPC_SETDRINKFILLING__INT_BOOL_,RPC_INCREASEFACTIONSTANDING__STRING_FLOAT_,RPC_DECREASEFACTIONSTANDING__STRING_FLOAT_,RPC_GETFACTIONSTANDING__STRING_,RPC_GETSURVEYWAYPOINT__,RPC_ACTIVATERECOVERY__,RPC_DORECOVERY__,RPC_DISCONNECT__BOOL_BOOL_,RPC_RELOAD__ZONECLIENTSESSION_,RPC_SETOFFLINE__,RPC_SETLINKDEAD__,RPC_SETONLINE__,RPC_SETLOGGINGOUT__,RPC_SENDBADGESRESPONSETO__CREATUREOBJECT_,RPC_LOGOUT__BOOL_,RPC_SETLASTNPCCONVSTR__STRING_,RPC_SETLASTNPCCONVMESSSTR__STRING_,RPC_GETLASTNPCCONVSTR__,RPC_GETLASTNPCCONVMESSSTR__,RPC_GETLASTNPCCONVOPTION__INT_,RPC_ADDLASTNPCCONVOPTIONS__STRING_,RPC_COUNTLASTNPCCONVOPTIONS__,RPC_CLEARLASTNPCCONVOPTIONS__,RPC_SETCONVERSATINGCREATURE__CREATUREOBJECT_,RPC_GETCONVERSATINGCREATURE__,RPC_ADDPERSISTENTMESSAGE__LONG_,RPC_DROPPERSISTENTMESSAGE__LONG_,RPC_UNLOADSPAWNEDCHILDREN__,RPC_ADDTOCONSENTLIST__STRING_,RPC_HASINCONSENTLIST__STRING_,RPC_REMOVEFROMCONSENTLIST__STRING_,RPC_GETCONSENTNAME__INT_,RPC_GETCONSENTLISTSIZE__,RPC_SETCOMMANDMESSAGESTRING__INT_STRING_,RPC_REMOVECOMMANDMESSAGESTRING__INT_,RPC_GETDECLAREDRESIDENCE__,RPC_SETDECLAREDRESIDENCE__BUILDINGOBJECT_,RPC_SETCLONINGFACILITY__BUILDINGOBJECT_,RPC_GETCLONINGFACILITY__,RPC_NOTIFYONLINE__,RPC_DODIGEST__,RPC_ISDIGESTING__,RPC_GETSAVEDTERRAINNAME__,RPC_SETSAVEDPARENTID__LONG_,RPC_SETSAVEDTERRAINNAME__STRING_,RPC_SETFORCEPOWER__INT_BOOL_,RPC_SETFORCEPOWERMAX__INT_BOOL_,RPC_ACTIVATEFORCEREGEN__,RPC_GETSAVEDPARENTID__,RPC_GETNEWSUIBOXID__INT_,RPC_HASSUIBOX__INT_,RPC_GETSUIBOX__INT_,RPC_REMOVESUIBOX__INT_BOOL_,RPC_REMOVESUIBOXTYPE__INT_,RPC_HASSUIBOXWINDOWTYPE__INT_,RPC_CLOSESUIWINDOWTYPE__INT_,RPC_GETSUIBOXFROMWINDOWTYPE__INT_,RPC_ADDSUIBOX__SUIBOX_,RPC_ISFIRSTINCAPACITATIONEXPIRED__,RPC_RESETINCAPACITATIONCOUNTER__,RPC_RESETFIRSTINCAPACITATIONTIME__,RPC_UPDATEINCAPACITATIONCOUNTER__,RPC_ISFIRSTINCAPACITATION__,RPC_GETINCAPACITATIONCOUNTER__,RPC_ADDTODUELLIST__CREATUREOBJECT_,RPC_REMOVEFROMDUELLIST__CREATUREOBJECT_,RPC_GETDUELLISTOBJECT__INT_,RPC_REQUESTEDDUELTO__CREATUREOBJECT_,RPC_ISDUELLISTEMPTY__,RPC_GETDUELLISTSIZE__,RPC_GETBIOGRAPHY__,RPC_NOTIFYOFFLINE__,RPC_SETBADGE__INT_,RPC_AWARDBADGE__INT_,RPC_SETSURVEYTOOL__SURVEYTOOL_,RPC_GETSURVEYTOOL__,RPC_GETLASTCRAFTINGTOOLUSED__,RPC_SETLASTCRAFTINGTOOLUSED__CRAFTINGTOOL_,RPC_SETTELEPORTING__BOOL_,RPC_GETNUMBADGES__,RPC_GETBADGETYPECOUNT__BYTE_,RPC_HASFRIEND__STRING_,RPC_ISIGNORING__STRING_,RPC_ADDREVERSEFRIEND__STRING_,RPC_REMOVEREVERSEFRIEND__STRING_,RPC_SENDFRIENDLISTS__,RPC_HASWAYPOINT__LONG_,RPC_HASCOMMANDMESSAGESTRING__INT_,RPC_GETCHARACTERBITMASK__,RPC_GETTITLE__,RPC_GETADMINLEVEL__,RPC_SETADMINLEVEL__INT_,RPC_SETBIOGRAPHY__UNICODESTRING_,RPC_ISDEVELOPER__,RPC_ISCSR__,RPC_ISPRIVILEGED__,RPC_SETCHARACTERBITMASK__INT_,RPC_SETCHARACTERBIT__INT_BOOL_,RPC_CLEARCHARACTERBIT__INT_BOOL_,RPC_TOGGLECHARACTERBIT__INT_,RPC_GETFORCEPOWER__,RPC_GETFORCEPOWERMAX__,RPC_GETSCHEMATIC__INT_,RPC_GETFOODFILLING__,RPC_GETFOODFILLINGMAX__,RPC_GETDRINKFILLING__,RPC_GETDRINKFILLINGMAX__,RPC_GETJEDISTATE__,RPC_GETLANGUAGEID__,RPC_ISTELEPORTING__,RPC_ADDCHATROOM__CHATROOM_,RPC_REMOVECHATROOM__CHATROOM_,RPC_GETEXPERIENCE__STRING_,RPC_MAXIMIZEEXPERIENCE__,RPC_GETCOMMANDMESSAGESTRING__INT_,RPC_HASBADGE__INT_,RPC_CLEARDISCONNECTEVENT__,RPC_CLEARRECOVERYEVENT__,RPC_ISONLINE__,RPC_ISOFFLINE__,RPC_ISLOADING__,RPC_ISLINKDEAD__,RPC_ISLOGGINGIN__,RPC_ISLOGGINGOUT__,RPC_SETSKILLPOINTS__INT_,RPC_ADDSKILLPOINTS__INT_,RPC_GETSKILLPOINTS__,RPC_UPDATELASTVALIDATEDPOSITION__,RPC_SETSPAWNEDBLUEFROG__,RPC_HASSPAWNEDBLUEFROG__,RPC_GETACCOUNTID__,RPC_GETSERVERMOVEMENTTIMEDELTA__,RPC_SETCLIENTLASTMOVEMENTSTAMP__INT_,RPC_UPDATESERVERLASTMOVEMENTSTAMP__,RPC_SETACCOUNTID__INT_,RPC_GETFACTIONSTATUS__,RPC_GETCLIENTLASTMOVEMENTSTAMP__,RPC_GETCENTEREDBONUS__,RPC_SETCENTEREDBONUS__INT_,RPC_ISINVISIBLE__,RPC_SETINVISIBLE__BOOL_,RPC_SETHOLOGRINDMASK__INT_,RPC_GETHOLOGRINDMASK__,RPC_GETRACEID__,RPC_SETRACEID__BYTE_,RPC_SETMAXIMUMLOTS__BYTE_,RPC_GETMAXIMUMLOTS__};

PlayerObject::PlayerObject() : IntangibleObject(DummyConstructorParameter::instance()) {
	PlayerObjectImplementation* _implementation = new PlayerObjectImplementation();
	_impl = _implementation;
	_impl->_setStub(this);
}

PlayerObject::PlayerObject(DummyConstructorParameter* param) : IntangibleObject(param) {
}

PlayerObject::~PlayerObject() {
}



void PlayerObject::notifyLoadFromDatabase() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYLOADFROMDATABASE__);

		method.executeWithVoidReturn();
	} else
		_implementation->notifyLoadFromDatabase();
}

void PlayerObject::unload() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UNLOAD__);

		method.executeWithVoidReturn();
	} else
		_implementation->unload();
}

void PlayerObject::loadTemplateData(SharedObjectTemplate* templateData) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		_implementation->loadTemplateData(templateData);
}

void PlayerObject::initializeTransientMembers() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INITIALIZETRANSIENTMEMBERS__);

		method.executeWithVoidReturn();
	} else
		_implementation->initializeTransientMembers();
}

void PlayerObject::sendBaselinesTo(SceneObject* player) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDBASELINESTO__SCENEOBJECT_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else
		_implementation->sendBaselinesTo(player);
}

void PlayerObject::sendMessage(BasePacket* msg) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDMESSAGE__BASEPACKET_);
		method.addObjectParameter(msg);

		method.executeWithVoidReturn();
	} else
		_implementation->sendMessage(msg);
}

void PlayerObject::addOwnedStructure(StructureObject* obj) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDOWNEDSTRUCTURE__STRUCTUREOBJECT_);
		method.addObjectParameter(obj);

		method.executeWithVoidReturn();
	} else
		_implementation->addOwnedStructure(obj);
}

void PlayerObject::removeOwnedStructure(StructureObject* obj) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEOWNEDSTRUCTURE__STRUCTUREOBJECT_);
		method.addObjectParameter(obj);

		method.executeWithVoidReturn();
	} else
		_implementation->removeOwnedStructure(obj);
}

int PlayerObject::getTotalOwnedStructureCount() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETTOTALOWNEDSTRUCTURECOUNT__);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getTotalOwnedStructureCount();
}

bool PlayerObject::isOwnedStructure(StructureObject* obj) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISOWNEDSTRUCTURE__STRUCTUREOBJECT_);
		method.addObjectParameter(obj);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isOwnedStructure(obj);
}

StructureObject* PlayerObject::getOwnedStructure(int i) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETOWNEDSTRUCTURE__INT_);
		method.addSignedIntParameter(i);

		return static_cast<StructureObject*>(method.executeWithObjectReturn());
	} else
		return _implementation->getOwnedStructure(i);
}

int PlayerObject::getLotsRemaining() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETLOTSREMAINING__);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getLotsRemaining();
}

bool PlayerObject::hasLotsRemaining(int lots) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASLOTSREMAINING__INT_);
		method.addSignedIntParameter(lots);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->hasLotsRemaining(lots);
}

void PlayerObject::notifySceneReady() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYSCENEREADY__);

		method.executeWithVoidReturn();
	} else
		_implementation->notifySceneReady();
}

int PlayerObject::addExperience(const String& xpType, int xp, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDEXPERIENCE__STRING_INT_BOOL_);
		method.addAsciiParameter(xpType);
		method.addSignedIntParameter(xp);
		method.addBooleanParameter(notifyClient);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->addExperience(xpType, xp, notifyClient);
}

void PlayerObject::removeExperience(const String& xpType, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEEXPERIENCE__STRING_BOOL_);
		method.addAsciiParameter(xpType);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->removeExperience(xpType, notifyClient);
}

void PlayerObject::addWaypoint(WaypointObject* waypoint, bool checkName, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDWAYPOINT__WAYPOINTOBJECT_BOOL_BOOL_);
		method.addObjectParameter(waypoint);
		method.addBooleanParameter(checkName);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->addWaypoint(waypoint, checkName, notifyClient);
}

void PlayerObject::setWaypoint(WaypointObject* waypoint, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETWAYPOINT__WAYPOINTOBJECT_BOOL_);
		method.addObjectParameter(waypoint);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->setWaypoint(waypoint, notifyClient);
}

void PlayerObject::addWaypoint(const String& planet, float positionX, float positionY, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDWAYPOINT__STRING_FLOAT_FLOAT_BOOL_);
		method.addAsciiParameter(planet);
		method.addFloatParameter(positionX);
		method.addFloatParameter(positionY);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->addWaypoint(planet, positionX, positionY, notifyClient);
}

void PlayerObject::removeWaypoint(unsigned long long waypointID, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEWAYPOINT__LONG_BOOL_);
		method.addUnsignedLongParameter(waypointID);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->removeWaypoint(waypointID, notifyClient);
}

void PlayerObject::addAbilities(Vector<Ability*>& abilities, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		_implementation->addAbilities(abilities, notifyClient);
}

void PlayerObject::addAbility(Ability* ability, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		_implementation->addAbility(ability, notifyClient);
}

void PlayerObject::removeAbilities(Vector<Ability*>& abilities, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		_implementation->removeAbilities(abilities, notifyClient);
}

void PlayerObject::removeAbility(Ability* ability, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		_implementation->removeAbility(ability, notifyClient);
}

void PlayerObject::addSchematics(Vector<ManagedReference<DraftSchematic* > >& schematics, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		_implementation->addSchematics(schematics, notifyClient);
}

void PlayerObject::removeSchematics(Vector<ManagedReference<DraftSchematic* > >& schematics, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		_implementation->removeSchematics(schematics, notifyClient);
}

void PlayerObject::addSchematic(DraftSchematic* schematic, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		_implementation->addSchematic(schematic, notifyClient);
}

void PlayerObject::removeSchematic(DraftSchematic* schematic, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		_implementation->removeSchematic(schematic, notifyClient);
}

void PlayerObject::setLanguageID(byte language, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETLANGUAGEID__BYTE_BOOL_);
		method.addByteParameter(language);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->setLanguageID(language, notifyClient);
}

void PlayerObject::addFriend(const String& name, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDFRIEND__STRING_BOOL_);
		method.addAsciiParameter(name);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->addFriend(name, notifyClient);
}

void PlayerObject::removeFriend(const String& name, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEFRIEND__STRING_BOOL_);
		method.addAsciiParameter(name);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->removeFriend(name, notifyClient);
}

void PlayerObject::addIgnore(const String& name, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDIGNORE__STRING_BOOL_);
		method.addAsciiParameter(name);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->addIgnore(name, notifyClient);
}

void PlayerObject::removeIgnore(const String& name, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEIGNORE__STRING_BOOL_);
		method.addAsciiParameter(name);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->removeIgnore(name, notifyClient);
}

void PlayerObject::setTitle(const String& characterTitle, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETTITLE__STRING_BOOL_);
		method.addAsciiParameter(characterTitle);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->setTitle(characterTitle, notifyClient);
}

void PlayerObject::setFoodFilling(int newValue, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETFOODFILLING__INT_BOOL_);
		method.addSignedIntParameter(newValue);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->setFoodFilling(newValue, notifyClient);
}

void PlayerObject::setDrinkFilling(int newValue, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETDRINKFILLING__INT_BOOL_);
		method.addSignedIntParameter(newValue);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->setDrinkFilling(newValue, notifyClient);
}

void PlayerObject::increaseFactionStanding(const String& factionName, float amount) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INCREASEFACTIONSTANDING__STRING_FLOAT_);
		method.addAsciiParameter(factionName);
		method.addFloatParameter(amount);

		method.executeWithVoidReturn();
	} else
		_implementation->increaseFactionStanding(factionName, amount);
}

void PlayerObject::decreaseFactionStanding(const String& factionName, float amount) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DECREASEFACTIONSTANDING__STRING_FLOAT_);
		method.addAsciiParameter(factionName);
		method.addFloatParameter(amount);

		method.executeWithVoidReturn();
	} else
		_implementation->decreaseFactionStanding(factionName, amount);
}

float PlayerObject::getFactionStanding(const String& factionName) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETFACTIONSTANDING__STRING_);
		method.addAsciiParameter(factionName);

		return method.executeWithFloatReturn();
	} else
		return _implementation->getFactionStanding(factionName);
}

WaypointObject* PlayerObject::getSurveyWaypoint() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSURVEYWAYPOINT__);

		return static_cast<WaypointObject*>(method.executeWithObjectReturn());
	} else
		return _implementation->getSurveyWaypoint();
}

void PlayerObject::activateRecovery() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ACTIVATERECOVERY__);

		method.executeWithVoidReturn();
	} else
		_implementation->activateRecovery();
}

void PlayerObject::doRecovery() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DORECOVERY__);

		method.executeWithVoidReturn();
	} else
		_implementation->doRecovery();
}

void PlayerObject::disconnect(bool closeClient, bool doLock) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DISCONNECT__BOOL_BOOL_);
		method.addBooleanParameter(closeClient);
		method.addBooleanParameter(doLock);

		method.executeWithVoidReturn();
	} else
		_implementation->disconnect(closeClient, doLock);
}

void PlayerObject::reload(ZoneClientSession* client) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_RELOAD__ZONECLIENTSESSION_);
		method.addObjectParameter(client);

		method.executeWithVoidReturn();
	} else
		_implementation->reload(client);
}

void PlayerObject::setOffline() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETOFFLINE__);

		method.executeWithVoidReturn();
	} else
		_implementation->setOffline();
}

void PlayerObject::setLinkDead() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETLINKDEAD__);

		method.executeWithVoidReturn();
	} else
		_implementation->setLinkDead();
}

void PlayerObject::setOnline() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETONLINE__);

		method.executeWithVoidReturn();
	} else
		_implementation->setOnline();
}

void PlayerObject::setLoggingOut() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETLOGGINGOUT__);

		method.executeWithVoidReturn();
	} else
		_implementation->setLoggingOut();
}

void PlayerObject::sendBadgesResponseTo(CreatureObject* player) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDBADGESRESPONSETO__CREATUREOBJECT_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else
		_implementation->sendBadgesResponseTo(player);
}

void PlayerObject::logout(bool doLock) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_LOGOUT__BOOL_);
		method.addBooleanParameter(doLock);

		method.executeWithVoidReturn();
	} else
		_implementation->logout(doLock);
}

FactionStandingList* PlayerObject::getFactionStandingList() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		return _implementation->getFactionStandingList();
}

void PlayerObject::setLastNpcConvStr(const String& conv) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETLASTNPCCONVSTR__STRING_);
		method.addAsciiParameter(conv);

		method.executeWithVoidReturn();
	} else
		_implementation->setLastNpcConvStr(conv);
}

void PlayerObject::setLastNpcConvMessStr(const String& mess) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETLASTNPCCONVMESSSTR__STRING_);
		method.addAsciiParameter(mess);

		method.executeWithVoidReturn();
	} else
		_implementation->setLastNpcConvMessStr(mess);
}

String PlayerObject::getLastNpcConvStr() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETLASTNPCCONVSTR__);

		method.executeWithAsciiReturn(_return_getLastNpcConvStr);
		return _return_getLastNpcConvStr;
	} else
		return _implementation->getLastNpcConvStr();
}

String PlayerObject::getLastNpcConvMessStr() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETLASTNPCCONVMESSSTR__);

		method.executeWithAsciiReturn(_return_getLastNpcConvMessStr);
		return _return_getLastNpcConvMessStr;
	} else
		return _implementation->getLastNpcConvMessStr();
}

String PlayerObject::getLastNpcConvOption(int idx) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETLASTNPCCONVOPTION__INT_);
		method.addSignedIntParameter(idx);

		method.executeWithAsciiReturn(_return_getLastNpcConvOption);
		return _return_getLastNpcConvOption;
	} else
		return _implementation->getLastNpcConvOption(idx);
}

void PlayerObject::addLastNpcConvOptions(const String& option) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDLASTNPCCONVOPTIONS__STRING_);
		method.addAsciiParameter(option);

		method.executeWithVoidReturn();
	} else
		_implementation->addLastNpcConvOptions(option);
}

int PlayerObject::countLastNpcConvOptions() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_COUNTLASTNPCCONVOPTIONS__);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->countLastNpcConvOptions();
}

void PlayerObject::clearLastNpcConvOptions() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CLEARLASTNPCCONVOPTIONS__);

		method.executeWithVoidReturn();
	} else
		_implementation->clearLastNpcConvOptions();
}

void PlayerObject::setConversatingCreature(CreatureObject* creature) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCONVERSATINGCREATURE__CREATUREOBJECT_);
		method.addObjectParameter(creature);

		method.executeWithVoidReturn();
	} else
		_implementation->setConversatingCreature(creature);
}

CreatureObject* PlayerObject::getConversatingCreature() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCONVERSATINGCREATURE__);

		return static_cast<CreatureObject*>(method.executeWithObjectReturn());
	} else
		return _implementation->getConversatingCreature();
}

SortedVector<unsigned long long>* PlayerObject::getPersistentMessages() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		return _implementation->getPersistentMessages();
}

void PlayerObject::addPersistentMessage(unsigned long long id) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDPERSISTENTMESSAGE__LONG_);
		method.addUnsignedLongParameter(id);

		method.executeWithVoidReturn();
	} else
		_implementation->addPersistentMessage(id);
}

void PlayerObject::dropPersistentMessage(unsigned long long id) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DROPPERSISTENTMESSAGE__LONG_);
		method.addUnsignedLongParameter(id);

		method.executeWithVoidReturn();
	} else
		_implementation->dropPersistentMessage(id);
}

void PlayerObject::unloadSpawnedChildren() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UNLOADSPAWNEDCHILDREN__);

		method.executeWithVoidReturn();
	} else
		_implementation->unloadSpawnedChildren();
}

void PlayerObject::addToConsentList(const String& name) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDTOCONSENTLIST__STRING_);
		method.addAsciiParameter(name);

		method.executeWithVoidReturn();
	} else
		_implementation->addToConsentList(name);
}

bool PlayerObject::hasInConsentList(const String& name) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASINCONSENTLIST__STRING_);
		method.addAsciiParameter(name);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->hasInConsentList(name);
}

void PlayerObject::removeFromConsentList(const String& name) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEFROMCONSENTLIST__STRING_);
		method.addAsciiParameter(name);

		method.executeWithVoidReturn();
	} else
		_implementation->removeFromConsentList(name);
}

String PlayerObject::getConsentName(int i) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCONSENTNAME__INT_);
		method.addSignedIntParameter(i);

		method.executeWithAsciiReturn(_return_getConsentName);
		return _return_getConsentName;
	} else
		return _implementation->getConsentName(i);
}

int PlayerObject::getConsentListSize() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCONSENTLISTSIZE__);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getConsentListSize();
}

String PlayerObject::getFactionRank() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		return _implementation->getFactionRank();
}

void PlayerObject::setFactionRank(const String& rank) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		_implementation->setFactionRank(rank);
}

void PlayerObject::setCommandMessageString(unsigned int actionCRC, String& message) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCOMMANDMESSAGESTRING__INT_STRING_);
		method.addUnsignedIntParameter(actionCRC);
		method.addAsciiParameter(message);

		method.executeWithVoidReturn();
	} else
		_implementation->setCommandMessageString(actionCRC, message);
}

void PlayerObject::removeCommandMessageString(unsigned int actionCRC) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVECOMMANDMESSAGESTRING__INT_);
		method.addUnsignedIntParameter(actionCRC);

		method.executeWithVoidReturn();
	} else
		_implementation->removeCommandMessageString(actionCRC);
}

BuildingObject* PlayerObject::getDeclaredResidence() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETDECLAREDRESIDENCE__);

		return static_cast<BuildingObject*>(method.executeWithObjectReturn());
	} else
		return _implementation->getDeclaredResidence();
}

void PlayerObject::setDeclaredResidence(BuildingObject* residence) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETDECLAREDRESIDENCE__BUILDINGOBJECT_);
		method.addObjectParameter(residence);

		method.executeWithVoidReturn();
	} else
		_implementation->setDeclaredResidence(residence);
}

void PlayerObject::setCloningFacility(BuildingObject* cloningfac) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCLONINGFACILITY__BUILDINGOBJECT_);
		method.addObjectParameter(cloningfac);

		method.executeWithVoidReturn();
	} else
		_implementation->setCloningFacility(cloningfac);
}

BuildingObject* PlayerObject::getCloningFacility() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCLONINGFACILITY__);

		return static_cast<BuildingObject*>(method.executeWithObjectReturn());
	} else
		return _implementation->getCloningFacility();
}

void PlayerObject::notifyOnline() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYONLINE__);

		method.executeWithVoidReturn();
	} else
		_implementation->notifyOnline();
}

void PlayerObject::doDigest() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DODIGEST__);

		method.executeWithVoidReturn();
	} else
		_implementation->doDigest();
}

bool PlayerObject::isDigesting() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISDIGESTING__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isDigesting();
}

String PlayerObject::getSavedTerrainName() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSAVEDTERRAINNAME__);

		method.executeWithAsciiReturn(_return_getSavedTerrainName);
		return _return_getSavedTerrainName;
	} else
		return _implementation->getSavedTerrainName();
}

void PlayerObject::setSavedParentID(unsigned long long id) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETSAVEDPARENTID__LONG_);
		method.addUnsignedLongParameter(id);

		method.executeWithVoidReturn();
	} else
		_implementation->setSavedParentID(id);
}

void PlayerObject::setSavedTerrainName(const String& name) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETSAVEDTERRAINNAME__STRING_);
		method.addAsciiParameter(name);

		method.executeWithVoidReturn();
	} else
		_implementation->setSavedTerrainName(name);
}

void PlayerObject::setForcePower(int fp, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETFORCEPOWER__INT_BOOL_);
		method.addSignedIntParameter(fp);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->setForcePower(fp, notifyClient);
}

void PlayerObject::setForcePowerMax(int fpm, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETFORCEPOWERMAX__INT_BOOL_);
		method.addSignedIntParameter(fpm);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else
		_implementation->setForcePowerMax(fpm, notifyClient);
}

void PlayerObject::activateForceRegen() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ACTIVATEFORCEREGEN__);

		method.executeWithVoidReturn();
	} else
		_implementation->activateForceRegen();
}

unsigned long long PlayerObject::getSavedParentID() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSAVEDPARENTID__);

		return method.executeWithUnsignedLongReturn();
	} else
		return _implementation->getSavedParentID();
}

unsigned int PlayerObject::getNewSuiBoxID(unsigned int type) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETNEWSUIBOXID__INT_);
		method.addUnsignedIntParameter(type);

		return method.executeWithUnsignedIntReturn();
	} else
		return _implementation->getNewSuiBoxID(type);
}

bool PlayerObject::hasSuiBox(unsigned int boxID) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASSUIBOX__INT_);
		method.addUnsignedIntParameter(boxID);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->hasSuiBox(boxID);
}

SuiBox* PlayerObject::getSuiBox(unsigned int boxID) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSUIBOX__INT_);
		method.addUnsignedIntParameter(boxID);

		return static_cast<SuiBox*>(method.executeWithObjectReturn());
	} else
		return _implementation->getSuiBox(boxID);
}

void PlayerObject::removeSuiBox(unsigned int boxID, bool closeWindowToClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVESUIBOX__INT_BOOL_);
		method.addUnsignedIntParameter(boxID);
		method.addBooleanParameter(closeWindowToClient);

		method.executeWithVoidReturn();
	} else
		_implementation->removeSuiBox(boxID, closeWindowToClient);
}

void PlayerObject::removeSuiBoxType(unsigned int windowType) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVESUIBOXTYPE__INT_);
		method.addUnsignedIntParameter(windowType);

		method.executeWithVoidReturn();
	} else
		_implementation->removeSuiBoxType(windowType);
}

bool PlayerObject::hasSuiBoxWindowType(unsigned int windowType) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASSUIBOXWINDOWTYPE__INT_);
		method.addUnsignedIntParameter(windowType);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->hasSuiBoxWindowType(windowType);
}

void PlayerObject::closeSuiWindowType(unsigned int windowType) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CLOSESUIWINDOWTYPE__INT_);
		method.addUnsignedIntParameter(windowType);

		method.executeWithVoidReturn();
	} else
		_implementation->closeSuiWindowType(windowType);
}

SuiBox* PlayerObject::getSuiBoxFromWindowType(unsigned int windowType) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSUIBOXFROMWINDOWTYPE__INT_);
		method.addUnsignedIntParameter(windowType);

		return static_cast<SuiBox*>(method.executeWithObjectReturn());
	} else
		return _implementation->getSuiBoxFromWindowType(windowType);
}

void PlayerObject::addSuiBox(SuiBox* sui) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDSUIBOX__SUIBOX_);
		method.addObjectParameter(sui);

		method.executeWithVoidReturn();
	} else
		_implementation->addSuiBox(sui);
}

bool PlayerObject::isFirstIncapacitationExpired() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISFIRSTINCAPACITATIONEXPIRED__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isFirstIncapacitationExpired();
}

void PlayerObject::resetIncapacitationCounter() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_RESETINCAPACITATIONCOUNTER__);

		method.executeWithVoidReturn();
	} else
		_implementation->resetIncapacitationCounter();
}

void PlayerObject::resetFirstIncapacitationTime() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_RESETFIRSTINCAPACITATIONTIME__);

		method.executeWithVoidReturn();
	} else
		_implementation->resetFirstIncapacitationTime();
}

void PlayerObject::updateIncapacitationCounter() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATEINCAPACITATIONCOUNTER__);

		method.executeWithVoidReturn();
	} else
		_implementation->updateIncapacitationCounter();
}

bool PlayerObject::isFirstIncapacitation() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISFIRSTINCAPACITATION__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isFirstIncapacitation();
}

byte PlayerObject::getIncapacitationCounter() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETINCAPACITATIONCOUNTER__);

		return method.executeWithByteReturn();
	} else
		return _implementation->getIncapacitationCounter();
}

void PlayerObject::addToDuelList(CreatureObject* targetPlayer) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDTODUELLIST__CREATUREOBJECT_);
		method.addObjectParameter(targetPlayer);

		method.executeWithVoidReturn();
	} else
		_implementation->addToDuelList(targetPlayer);
}

void PlayerObject::removeFromDuelList(CreatureObject* targetPlayer) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEFROMDUELLIST__CREATUREOBJECT_);
		method.addObjectParameter(targetPlayer);

		method.executeWithVoidReturn();
	} else
		_implementation->removeFromDuelList(targetPlayer);
}

CreatureObject* PlayerObject::getDuelListObject(int index) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETDUELLISTOBJECT__INT_);
		method.addSignedIntParameter(index);

		return static_cast<CreatureObject*>(method.executeWithObjectReturn());
	} else
		return _implementation->getDuelListObject(index);
}

bool PlayerObject::requestedDuelTo(CreatureObject* targetPlayer) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REQUESTEDDUELTO__CREATUREOBJECT_);
		method.addObjectParameter(targetPlayer);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->requestedDuelTo(targetPlayer);
}

bool PlayerObject::isDuelListEmpty() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISDUELLISTEMPTY__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isDuelListEmpty();
}

int PlayerObject::getDuelListSize() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETDUELLISTSIZE__);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getDuelListSize();
}

UnicodeString PlayerObject::getBiography() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETBIOGRAPHY__);

		method.executeWithUnicodeReturn(_return_getBiography);
		return _return_getBiography;
	} else
		return _implementation->getBiography();
}

void PlayerObject::notifyOffline() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYOFFLINE__);

		method.executeWithVoidReturn();
	} else
		_implementation->notifyOffline();
}

void PlayerObject::setBadge(unsigned int badge) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETBADGE__INT_);
		method.addUnsignedIntParameter(badge);

		method.executeWithVoidReturn();
	} else
		_implementation->setBadge(badge);
}

void PlayerObject::awardBadge(unsigned int badge) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_AWARDBADGE__INT_);
		method.addUnsignedIntParameter(badge);

		method.executeWithVoidReturn();
	} else
		_implementation->awardBadge(badge);
}

void PlayerObject::setSurveyTool(SurveyTool* tool) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETSURVEYTOOL__SURVEYTOOL_);
		method.addObjectParameter(tool);

		method.executeWithVoidReturn();
	} else
		_implementation->setSurveyTool(tool);
}

SurveyTool* PlayerObject::getSurveyTool() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSURVEYTOOL__);

		return static_cast<SurveyTool*>(method.executeWithObjectReturn());
	} else
		return _implementation->getSurveyTool();
}

CraftingTool* PlayerObject::getLastCraftingToolUsed() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETLASTCRAFTINGTOOLUSED__);

		return static_cast<CraftingTool*>(method.executeWithObjectReturn());
	} else
		return _implementation->getLastCraftingToolUsed();
}

void PlayerObject::setLastCraftingToolUsed(CraftingTool* tool) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETLASTCRAFTINGTOOLUSED__CRAFTINGTOOL_);
		method.addObjectParameter(tool);

		method.executeWithVoidReturn();
	} else
		_implementation->setLastCraftingToolUsed(tool);
}

void PlayerObject::setTeleporting(bool val) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETTELEPORTING__BOOL_);
		method.addBooleanParameter(val);

		method.executeWithVoidReturn();
	} else
		_implementation->setTeleporting(val);
}

int PlayerObject::getNumBadges() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETNUMBADGES__);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getNumBadges();
}

int PlayerObject::getBadgeTypeCount(byte type) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETBADGETYPECOUNT__BYTE_);
		method.addByteParameter(type);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getBadgeTypeCount(type);
}

bool PlayerObject::hasFriend(const String& name) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASFRIEND__STRING_);
		method.addAsciiParameter(name);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->hasFriend(name);
}

bool PlayerObject::isIgnoring(const String& name) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISIGNORING__STRING_);
		method.addAsciiParameter(name);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isIgnoring(name);
}

void PlayerObject::addReverseFriend(const String& name) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDREVERSEFRIEND__STRING_);
		method.addAsciiParameter(name);

		method.executeWithVoidReturn();
	} else
		_implementation->addReverseFriend(name);
}

void PlayerObject::removeReverseFriend(const String& name) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEREVERSEFRIEND__STRING_);
		method.addAsciiParameter(name);

		method.executeWithVoidReturn();
	} else
		_implementation->removeReverseFriend(name);
}

void PlayerObject::sendFriendLists() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDFRIENDLISTS__);

		method.executeWithVoidReturn();
	} else
		_implementation->sendFriendLists();
}

bool PlayerObject::hasWaypoint(unsigned long long objectID) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASWAYPOINT__LONG_);
		method.addUnsignedLongParameter(objectID);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->hasWaypoint(objectID);
}

bool PlayerObject::hasAbility(const String& ability) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		return _implementation->hasAbility(ability);
}

bool PlayerObject::hasCommandMessageString(unsigned int actionCRC) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASCOMMANDMESSAGESTRING__INT_);
		method.addUnsignedIntParameter(actionCRC);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->hasCommandMessageString(actionCRC);
}

unsigned int PlayerObject::getCharacterBitmask() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCHARACTERBITMASK__);

		return method.executeWithUnsignedIntReturn();
	} else
		return _implementation->getCharacterBitmask();
}

String PlayerObject::getTitle() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETTITLE__);

		method.executeWithAsciiReturn(_return_getTitle);
		return _return_getTitle;
	} else
		return _implementation->getTitle();
}

unsigned int PlayerObject::getAdminLevel() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETADMINLEVEL__);

		return method.executeWithUnsignedIntReturn();
	} else
		return _implementation->getAdminLevel();
}

void PlayerObject::setAdminLevel(unsigned int adminlvl) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETADMINLEVEL__INT_);
		method.addUnsignedIntParameter(adminlvl);

		method.executeWithVoidReturn();
	} else
		_implementation->setAdminLevel(adminlvl);
}

void PlayerObject::setBiography(const UnicodeString& bio) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETBIOGRAPHY__UNICODESTRING_);
		method.addUnicodeParameter(bio);

		method.executeWithVoidReturn();
	} else
		_implementation->setBiography(bio);
}

bool PlayerObject::isDeveloper() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISDEVELOPER__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isDeveloper();
}

bool PlayerObject::isCSR() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISCSR__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isCSR();
}

bool PlayerObject::isPrivileged() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISPRIVILEGED__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isPrivileged();
}

void PlayerObject::setCharacterBitmask(unsigned int bitmask) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCHARACTERBITMASK__INT_);
		method.addUnsignedIntParameter(bitmask);

		method.executeWithVoidReturn();
	} else
		_implementation->setCharacterBitmask(bitmask);
}

bool PlayerObject::setCharacterBit(unsigned int bit, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCHARACTERBIT__INT_BOOL_);
		method.addUnsignedIntParameter(bit);
		method.addBooleanParameter(notifyClient);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->setCharacterBit(bit, notifyClient);
}

bool PlayerObject::clearCharacterBit(unsigned int bit, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CLEARCHARACTERBIT__INT_BOOL_);
		method.addUnsignedIntParameter(bit);
		method.addBooleanParameter(notifyClient);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->clearCharacterBit(bit, notifyClient);
}

void PlayerObject::toggleCharacterBit(unsigned int bit) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_TOGGLECHARACTERBIT__INT_);
		method.addUnsignedIntParameter(bit);

		method.executeWithVoidReturn();
	} else
		_implementation->toggleCharacterBit(bit);
}

VectorMap<String, int>* PlayerObject::getXpTypeCapList() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		return _implementation->getXpTypeCapList();
}

DeltaVectorMap<String, int>* PlayerObject::getExperienceList() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		return _implementation->getExperienceList();
}

int PlayerObject::getForcePower() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETFORCEPOWER__);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getForcePower();
}

int PlayerObject::getForcePowerMax() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETFORCEPOWERMAX__);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getForcePowerMax();
}

WaypointList* PlayerObject::getWaypointList() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		return _implementation->getWaypointList();
}

AbilityList* PlayerObject::getAbilityList() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		return _implementation->getAbilityList();
}

SchematicList* PlayerObject::getSchematics() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		return _implementation->getSchematics();
}

DraftSchematic* PlayerObject::getSchematic(int i) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSCHEMATIC__INT_);
		method.addSignedIntParameter(i);

		return static_cast<DraftSchematic*>(method.executeWithObjectReturn());
	} else
		return _implementation->getSchematic(i);
}

Vector<ManagedReference<DraftSchematic* > > PlayerObject::filterSchematicList(CreatureObject* player, Vector<unsigned int>* enabledTabs, int complexityLevel) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		return _implementation->filterSchematicList(player, enabledTabs, complexityLevel);
}

int PlayerObject::getFoodFilling() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETFOODFILLING__);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getFoodFilling();
}

int PlayerObject::getFoodFillingMax() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETFOODFILLINGMAX__);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getFoodFillingMax();
}

int PlayerObject::getDrinkFilling() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETDRINKFILLING__);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getDrinkFilling();
}

int PlayerObject::getDrinkFillingMax() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETDRINKFILLINGMAX__);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getDrinkFillingMax();
}

int PlayerObject::getJediState() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETJEDISTATE__);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getJediState();
}

byte PlayerObject::getLanguageID() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETLANGUAGEID__);

		return method.executeWithByteReturn();
	} else
		return _implementation->getLanguageID();
}

DeltaVector<String>* PlayerObject::getFriendList() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		return _implementation->getFriendList();
}

bool PlayerObject::isTeleporting() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISTELEPORTING__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isTeleporting();
}

void PlayerObject::addChatRoom(ChatRoom* room) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDCHATROOM__CHATROOM_);
		method.addObjectParameter(room);

		method.executeWithVoidReturn();
	} else
		_implementation->addChatRoom(room);
}

void PlayerObject::removeChatRoom(ChatRoom* room) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVECHATROOM__CHATROOM_);
		method.addObjectParameter(room);

		method.executeWithVoidReturn();
	} else
		_implementation->removeChatRoom(room);
}

void PlayerObject::clearTradeContainer() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		_implementation->clearTradeContainer();
}

TradeContainer* PlayerObject::getTradeContainer() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		return _implementation->getTradeContainer();
}

DeltaVector<String>* PlayerObject::getIgnoreList() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		return _implementation->getIgnoreList();
}

int PlayerObject::getExperience(const String& xp) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETEXPERIENCE__STRING_);
		method.addAsciiParameter(xp);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getExperience(xp);
}

void PlayerObject::maximizeExperience() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_MAXIMIZEEXPERIENCE__);

		method.executeWithVoidReturn();
	} else
		_implementation->maximizeExperience();
}

String PlayerObject::getCommandMessageString(unsigned int actionCRC) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCOMMANDMESSAGESTRING__INT_);
		method.addUnsignedIntParameter(actionCRC);

		method.executeWithAsciiReturn(_return_getCommandMessageString);
		return _return_getCommandMessageString;
	} else
		return _implementation->getCommandMessageString(actionCRC);
}

bool PlayerObject::hasBadge(unsigned int badge) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASBADGE__INT_);
		method.addUnsignedIntParameter(badge);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->hasBadge(badge);
}

void PlayerObject::clearDisconnectEvent() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CLEARDISCONNECTEVENT__);

		method.executeWithVoidReturn();
	} else
		_implementation->clearDisconnectEvent();
}

void PlayerObject::clearRecoveryEvent() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CLEARRECOVERYEVENT__);

		method.executeWithVoidReturn();
	} else
		_implementation->clearRecoveryEvent();
}

bool PlayerObject::isOnline() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISONLINE__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isOnline();
}

bool PlayerObject::isOffline() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISOFFLINE__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isOffline();
}

bool PlayerObject::isLoading() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISLOADING__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isLoading();
}

bool PlayerObject::isLinkDead() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISLINKDEAD__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isLinkDead();
}

bool PlayerObject::isLoggingIn() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISLOGGINGIN__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isLoggingIn();
}

bool PlayerObject::isLoggingOut() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISLOGGINGOUT__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isLoggingOut();
}

void PlayerObject::setSkillPoints(int points) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETSKILLPOINTS__INT_);
		method.addSignedIntParameter(points);

		method.executeWithVoidReturn();
	} else
		_implementation->setSkillPoints(points);
}

void PlayerObject::addSkillPoints(int points) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDSKILLPOINTS__INT_);
		method.addSignedIntParameter(points);

		method.executeWithVoidReturn();
	} else
		_implementation->addSkillPoints(points);
}

int PlayerObject::getSkillPoints() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSKILLPOINTS__);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getSkillPoints();
}

ValidatedPosition* PlayerObject::getLastValidatedPosition() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		return _implementation->getLastValidatedPosition();
}

void PlayerObject::updateLastValidatedPosition() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATELASTVALIDATEDPOSITION__);

		method.executeWithVoidReturn();
	} else
		_implementation->updateLastValidatedPosition();
}

void PlayerObject::setSpawnedBlueFrog() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETSPAWNEDBLUEFROG__);

		method.executeWithVoidReturn();
	} else
		_implementation->setSpawnedBlueFrog();
}

bool PlayerObject::hasSpawnedBlueFrog() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASSPAWNEDBLUEFROG__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->hasSpawnedBlueFrog();
}

unsigned int PlayerObject::getAccountID() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETACCOUNTID__);

		return method.executeWithUnsignedIntReturn();
	} else
		return _implementation->getAccountID();
}

unsigned long long PlayerObject::getServerMovementTimeDelta() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSERVERMOVEMENTTIMEDELTA__);

		return method.executeWithUnsignedLongReturn();
	} else
		return _implementation->getServerMovementTimeDelta();
}

Time* PlayerObject::getServerMovementTimeStamp() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		throw ObjectNotLocalException(this);

	} else
		return _implementation->getServerMovementTimeStamp();
}

void PlayerObject::setClientLastMovementStamp(unsigned int stamp) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCLIENTLASTMOVEMENTSTAMP__INT_);
		method.addUnsignedIntParameter(stamp);

		method.executeWithVoidReturn();
	} else
		_implementation->setClientLastMovementStamp(stamp);
}

void PlayerObject::updateServerLastMovementStamp() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATESERVERLASTMOVEMENTSTAMP__);

		method.executeWithVoidReturn();
	} else
		_implementation->updateServerLastMovementStamp();
}

void PlayerObject::setAccountID(unsigned int id) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETACCOUNTID__INT_);
		method.addUnsignedIntParameter(id);

		method.executeWithVoidReturn();
	} else
		_implementation->setAccountID(id);
}

int PlayerObject::getFactionStatus() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETFACTIONSTATUS__);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getFactionStatus();
}

unsigned int PlayerObject::getClientLastMovementStamp() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCLIENTLASTMOVEMENTSTAMP__);

		return method.executeWithUnsignedIntReturn();
	} else
		return _implementation->getClientLastMovementStamp();
}

int PlayerObject::getCenteredBonus() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCENTEREDBONUS__);

		return method.executeWithSignedIntReturn();
	} else
		return _implementation->getCenteredBonus();
}

void PlayerObject::setCenteredBonus(int bonus) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCENTEREDBONUS__INT_);
		method.addSignedIntParameter(bonus);

		method.executeWithVoidReturn();
	} else
		_implementation->setCenteredBonus(bonus);
}

bool PlayerObject::isInvisible() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISINVISIBLE__);

		return method.executeWithBooleanReturn();
	} else
		return _implementation->isInvisible();
}

void PlayerObject::setInvisible(bool invis) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETINVISIBLE__BOOL_);
		method.addBooleanParameter(invis);

		method.executeWithVoidReturn();
	} else
		_implementation->setInvisible(invis);
}

void PlayerObject::setHologrindMask(unsigned int mask) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETHOLOGRINDMASK__INT_);
		method.addUnsignedIntParameter(mask);

		method.executeWithVoidReturn();
	} else
		_implementation->setHologrindMask(mask);
}

unsigned int PlayerObject::getHologrindMask() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETHOLOGRINDMASK__);

		return method.executeWithUnsignedIntReturn();
	} else
		return _implementation->getHologrindMask();
}

byte PlayerObject::getRaceID() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETRACEID__);

		return method.executeWithByteReturn();
	} else
		return _implementation->getRaceID();
}

void PlayerObject::setRaceID(byte race) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETRACEID__BYTE_);
		method.addByteParameter(race);

		method.executeWithVoidReturn();
	} else
		_implementation->setRaceID(race);
}

void PlayerObject::setMaximumLots(byte lots) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETMAXIMUMLOTS__BYTE_);
		method.addByteParameter(lots);

		method.executeWithVoidReturn();
	} else
		_implementation->setMaximumLots(lots);
}

byte PlayerObject::getMaximumLots() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (_implementation == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETMAXIMUMLOTS__);

		return method.executeWithByteReturn();
	} else
		return _implementation->getMaximumLots();
}

DistributedObjectServant* PlayerObject::_getImplementation() {

	_updated = true;
	return _impl;
}

void PlayerObject::_setImplementation(DistributedObjectServant* servant) {
	_impl = servant;
}

/*
 *	PlayerObjectImplementation
 */

PlayerObjectImplementation::PlayerObjectImplementation(DummyConstructorParameter* param) : IntangibleObjectImplementation(param) {
	_initializeImplementation();
}


PlayerObjectImplementation::~PlayerObjectImplementation() {
	PlayerObjectImplementation::finalize();
}


void PlayerObjectImplementation::_initializeImplementation() {
	_setClassHelper(PlayerObjectHelper::instance());

	_this = NULL;

	_serializationHelperMethod();
}

void PlayerObjectImplementation::_setStub(DistributedObjectStub* stub) {
	_this = static_cast<PlayerObject*>(stub);
	IntangibleObjectImplementation::_setStub(stub);
}

DistributedObjectStub* PlayerObjectImplementation::_getStub() {
	return _this;
}

PlayerObjectImplementation::operator const PlayerObject*() {
	return _this;
}

void PlayerObjectImplementation::lock(bool doLock) {
	_this->lock(doLock);
}

void PlayerObjectImplementation::lock(ManagedObject* obj) {
	_this->lock(obj);
}

void PlayerObjectImplementation::rlock(bool doLock) {
	_this->rlock(doLock);
}

void PlayerObjectImplementation::wlock(bool doLock) {
	_this->wlock(doLock);
}

void PlayerObjectImplementation::wlock(ManagedObject* obj) {
	_this->wlock(obj);
}

void PlayerObjectImplementation::unlock(bool doLock) {
	_this->unlock(doLock);
}

void PlayerObjectImplementation::runlock(bool doLock) {
	_this->runlock(doLock);
}

void PlayerObjectImplementation::_serializationHelperMethod() {
	IntangibleObjectImplementation::_serializationHelperMethod();

	_setClassName("PlayerObject");

}

void PlayerObjectImplementation::readObject(ObjectInputStream* stream) {
	uint16 _varCount = stream->readShort();
	for (int i = 0; i < _varCount; ++i) {
		String _name;
		_name.parseFromBinaryStream(stream);

		uint16 _varSize = stream->readShort();

		int _currentOffset = stream->getOffset();

		if(PlayerObjectImplementation::readObjectMember(stream, _name)) {
		}

		stream->setOffset(_currentOffset + _varSize);
	}

	initializeTransientMembers();
}

bool PlayerObjectImplementation::readObjectMember(ObjectInputStream* stream, const String& _name) {
	if (IntangibleObjectImplementation::readObjectMember(stream, _name))
		return true;

	if (_name == "characterBitmask") {
		TypeInfo<unsigned int >::parseFromBinaryStream(&characterBitmask, stream);
		return true;
	}

	if (_name == "title") {
		TypeInfo<String >::parseFromBinaryStream(&title, stream);
		return true;
	}

	if (_name == "savedTerrainName") {
		TypeInfo<String >::parseFromBinaryStream(&savedTerrainName, stream);
		return true;
	}

	if (_name == "savedParentID") {
		TypeInfo<unsigned long long >::parseFromBinaryStream(&savedParentID, stream);
		return true;
	}

	if (_name == "badges") {
		TypeInfo<Badges >::parseFromBinaryStream(&badges, stream);
		return true;
	}

	if (_name == "forcePower") {
		TypeInfo<int >::parseFromBinaryStream(&forcePower, stream);
		return true;
	}

	if (_name == "forcePowerMax") {
		TypeInfo<int >::parseFromBinaryStream(&forcePowerMax, stream);
		return true;
	}

	if (_name == "foodFilling") {
		TypeInfo<int >::parseFromBinaryStream(&foodFilling, stream);
		return true;
	}

	if (_name == "foodFillingMax") {
		TypeInfo<int >::parseFromBinaryStream(&foodFillingMax, stream);
		return true;
	}

	if (_name == "drinkFilling") {
		TypeInfo<int >::parseFromBinaryStream(&drinkFilling, stream);
		return true;
	}

	if (_name == "drinkFillingMax") {
		TypeInfo<int >::parseFromBinaryStream(&drinkFillingMax, stream);
		return true;
	}

	if (_name == "teleporting") {
		TypeInfo<bool >::parseFromBinaryStream(&teleporting, stream);
		return true;
	}

	if (_name == "ownedStructures") {
		TypeInfo<SortedVector<ManagedReference<StructureObject* > > >::parseFromBinaryStream(&ownedStructures, stream);
		return true;
	}

	if (_name == "maximumLots") {
		TypeInfo<byte >::parseFromBinaryStream(&maximumLots, stream);
		return true;
	}

	if (_name == "jediState") {
		TypeInfo<int >::parseFromBinaryStream(&jediState, stream);
		return true;
	}

	if (_name == "adminLevel") {
		TypeInfo<unsigned int >::parseFromBinaryStream(&adminLevel, stream);
		return true;
	}

	if (_name == "languageID") {
		TypeInfo<byte >::parseFromBinaryStream(&languageID, stream);
		return true;
	}

	if (_name == "xpTypeCapList") {
		TypeInfo<VectorMap<String, int> >::parseFromBinaryStream(&xpTypeCapList, stream);
		return true;
	}

	if (_name == "commandMessageStrings") {
		TypeInfo<VectorMap<unsigned int, String> >::parseFromBinaryStream(&commandMessageStrings, stream);
		return true;
	}

	if (_name == "experienceList") {
		TypeInfo<DeltaVectorMap<String, int> >::parseFromBinaryStream(&experienceList, stream);
		return true;
	}

	if (_name == "waypointList") {
		TypeInfo<WaypointList >::parseFromBinaryStream(&waypointList, stream);
		return true;
	}

	if (_name == "abilityList") {
		TypeInfo<AbilityList >::parseFromBinaryStream(&abilityList, stream);
		return true;
	}

	if (_name == "friendList") {
		TypeInfo<FriendList >::parseFromBinaryStream(&friendList, stream);
		return true;
	}

	if (_name == "ignoreList") {
		TypeInfo<IgnoreList >::parseFromBinaryStream(&ignoreList, stream);
		return true;
	}

	if (_name == "factionStandingList") {
		TypeInfo<FactionStandingList >::parseFromBinaryStream(&factionStandingList, stream);
		return true;
	}

	if (_name == "schematicList") {
		TypeInfo<SchematicList >::parseFromBinaryStream(&schematicList, stream);
		return true;
	}

	if (_name == "incapacitationCounter") {
		TypeInfo<byte >::parseFromBinaryStream(&incapacitationCounter, stream);
		return true;
	}

	if (_name == "suiBoxNextID") {
		TypeInfo<unsigned int >::parseFromBinaryStream(&suiBoxNextID, stream);
		return true;
	}

	if (_name == "suiBoxes") {
		TypeInfo<VectorMap<unsigned int, ManagedReference<SuiBox* > > >::parseFromBinaryStream(&suiBoxes, stream);
		return true;
	}

	if (_name == "chatRooms") {
		TypeInfo<SortedVector<ManagedReference<ChatRoom* > > >::parseFromBinaryStream(&chatRooms, stream);
		return true;
	}

	if (_name == "tradeContainer") {
		TypeInfo<TradeContainer >::parseFromBinaryStream(&tradeContainer, stream);
		return true;
	}

	if (_name == "duelList") {
		TypeInfo<SortedVector<ManagedReference<CreatureObject* > > >::parseFromBinaryStream(&duelList, stream);
		return true;
	}

	if (_name == "declaredResidence") {
		TypeInfo<ManagedWeakReference<BuildingObject* > >::parseFromBinaryStream(&declaredResidence, stream);
		return true;
	}

	if (_name == "cloningFacility") {
		TypeInfo<ManagedWeakReference<BuildingObject* > >::parseFromBinaryStream(&cloningFacility, stream);
		return true;
	}

	if (_name == "surveyTool") {
		TypeInfo<ManagedWeakReference<SurveyTool* > >::parseFromBinaryStream(&surveyTool, stream);
		return true;
	}

	if (_name == "persistentMessages") {
		TypeInfo<SortedVector<unsigned long long> >::parseFromBinaryStream(&persistentMessages, stream);
		return true;
	}

	if (_name == "biography") {
		TypeInfo<UnicodeString >::parseFromBinaryStream(&biography, stream);
		return true;
	}

	if (_name == "consentList") {
		TypeInfo<SortedVector<String> >::parseFromBinaryStream(&consentList, stream);
		return true;
	}

	if (_name == "lastNpcConvoMessage") {
		TypeInfo<String >::parseFromBinaryStream(&lastNpcConvoMessage, stream);
		return true;
	}

	if (_name == "lastNpcConvo") {
		TypeInfo<String >::parseFromBinaryStream(&lastNpcConvo, stream);
		return true;
	}

	if (_name == "lastNpcConvoOptions") {
		TypeInfo<Vector<String> >::parseFromBinaryStream(&lastNpcConvoOptions, stream);
		return true;
	}

	if (_name == "conversatingCreature") {
		TypeInfo<ManagedWeakReference<CreatureObject* > >::parseFromBinaryStream(&conversatingCreature, stream);
		return true;
	}

	if (_name == "logoutTimeStamp") {
		TypeInfo<Time >::parseFromBinaryStream(&logoutTimeStamp, stream);
		return true;
	}

	if (_name == "onlineStatus") {
		TypeInfo<int >::parseFromBinaryStream(&onlineStatus, stream);
		return true;
	}

	if (_name == "skillPoints") {
		TypeInfo<int >::parseFromBinaryStream(&skillPoints, stream);
		return true;
	}

	if (_name == "pvpRating") {
		TypeInfo<int >::parseFromBinaryStream(&pvpRating, stream);
		return true;
	}

	if (_name == "factionStatus") {
		TypeInfo<int >::parseFromBinaryStream(&factionStatus, stream);
		return true;
	}

	if (_name == "centeredBonus") {
		TypeInfo<int >::parseFromBinaryStream(&centeredBonus, stream);
		return true;
	}

	if (_name == "invisible") {
		TypeInfo<bool >::parseFromBinaryStream(&invisible, stream);
		return true;
	}

	if (_name == "holoMask") {
		TypeInfo<unsigned int >::parseFromBinaryStream(&holoMask, stream);
		return true;
	}

	if (_name == "clientLastMovementStamp") {
		TypeInfo<unsigned int >::parseFromBinaryStream(&clientLastMovementStamp, stream);
		return true;
	}

	if (_name == "serverLastMovementStamp") {
		TypeInfo<Time >::parseFromBinaryStream(&serverLastMovementStamp, stream);
		return true;
	}

	if (_name == "lastValidatedPosition") {
		TypeInfo<ValidatedPosition >::parseFromBinaryStream(&lastValidatedPosition, stream);
		return true;
	}

	if (_name == "accountID") {
		TypeInfo<unsigned int >::parseFromBinaryStream(&accountID, stream);
		return true;
	}

	if (_name == "raceID") {
		TypeInfo<byte >::parseFromBinaryStream(&raceID, stream);
		return true;
	}


	return false;
}

void PlayerObjectImplementation::writeObject(ObjectOutputStream* stream) {
	int _currentOffset = stream->getOffset();
	stream->writeShort(0);
	int _varCount = PlayerObjectImplementation::writeObjectMembers(stream);
	stream->writeShort(_currentOffset, _varCount);
}

int PlayerObjectImplementation::writeObjectMembers(ObjectOutputStream* stream) {
	String _name;
	int _offset;
	uint16 _totalSize;
	_name = "characterBitmask";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<unsigned int >::toBinaryStream(&characterBitmask, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "title";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<String >::toBinaryStream(&title, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "savedTerrainName";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<String >::toBinaryStream(&savedTerrainName, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "savedParentID";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<unsigned long long >::toBinaryStream(&savedParentID, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "badges";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<Badges >::toBinaryStream(&badges, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "forcePower";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<int >::toBinaryStream(&forcePower, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "forcePowerMax";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<int >::toBinaryStream(&forcePowerMax, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "foodFilling";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<int >::toBinaryStream(&foodFilling, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "foodFillingMax";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<int >::toBinaryStream(&foodFillingMax, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "drinkFilling";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<int >::toBinaryStream(&drinkFilling, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "drinkFillingMax";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<int >::toBinaryStream(&drinkFillingMax, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "teleporting";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<bool >::toBinaryStream(&teleporting, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "ownedStructures";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<SortedVector<ManagedReference<StructureObject* > > >::toBinaryStream(&ownedStructures, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "maximumLots";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<byte >::toBinaryStream(&maximumLots, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "jediState";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<int >::toBinaryStream(&jediState, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "adminLevel";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<unsigned int >::toBinaryStream(&adminLevel, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "languageID";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<byte >::toBinaryStream(&languageID, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "xpTypeCapList";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<VectorMap<String, int> >::toBinaryStream(&xpTypeCapList, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "commandMessageStrings";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<VectorMap<unsigned int, String> >::toBinaryStream(&commandMessageStrings, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "experienceList";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<DeltaVectorMap<String, int> >::toBinaryStream(&experienceList, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "waypointList";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<WaypointList >::toBinaryStream(&waypointList, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "abilityList";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<AbilityList >::toBinaryStream(&abilityList, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "friendList";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<FriendList >::toBinaryStream(&friendList, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "ignoreList";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<IgnoreList >::toBinaryStream(&ignoreList, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "factionStandingList";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<FactionStandingList >::toBinaryStream(&factionStandingList, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "schematicList";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<SchematicList >::toBinaryStream(&schematicList, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "incapacitationCounter";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<byte >::toBinaryStream(&incapacitationCounter, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "suiBoxNextID";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<unsigned int >::toBinaryStream(&suiBoxNextID, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "suiBoxes";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<VectorMap<unsigned int, ManagedReference<SuiBox* > > >::toBinaryStream(&suiBoxes, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "chatRooms";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<SortedVector<ManagedReference<ChatRoom* > > >::toBinaryStream(&chatRooms, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "tradeContainer";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<TradeContainer >::toBinaryStream(&tradeContainer, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "duelList";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<SortedVector<ManagedReference<CreatureObject* > > >::toBinaryStream(&duelList, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "declaredResidence";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<ManagedWeakReference<BuildingObject* > >::toBinaryStream(&declaredResidence, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "cloningFacility";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<ManagedWeakReference<BuildingObject* > >::toBinaryStream(&cloningFacility, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "surveyTool";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<ManagedWeakReference<SurveyTool* > >::toBinaryStream(&surveyTool, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "persistentMessages";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<SortedVector<unsigned long long> >::toBinaryStream(&persistentMessages, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "biography";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<UnicodeString >::toBinaryStream(&biography, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "consentList";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<SortedVector<String> >::toBinaryStream(&consentList, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "lastNpcConvoMessage";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<String >::toBinaryStream(&lastNpcConvoMessage, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "lastNpcConvo";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<String >::toBinaryStream(&lastNpcConvo, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "lastNpcConvoOptions";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<Vector<String> >::toBinaryStream(&lastNpcConvoOptions, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "conversatingCreature";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<ManagedWeakReference<CreatureObject* > >::toBinaryStream(&conversatingCreature, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "logoutTimeStamp";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<Time >::toBinaryStream(&logoutTimeStamp, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "onlineStatus";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<int >::toBinaryStream(&onlineStatus, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "skillPoints";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<int >::toBinaryStream(&skillPoints, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "pvpRating";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<int >::toBinaryStream(&pvpRating, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "factionStatus";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<int >::toBinaryStream(&factionStatus, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "centeredBonus";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<int >::toBinaryStream(&centeredBonus, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "invisible";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<bool >::toBinaryStream(&invisible, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "holoMask";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<unsigned int >::toBinaryStream(&holoMask, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "clientLastMovementStamp";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<unsigned int >::toBinaryStream(&clientLastMovementStamp, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "serverLastMovementStamp";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<Time >::toBinaryStream(&serverLastMovementStamp, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "lastValidatedPosition";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<ValidatedPosition >::toBinaryStream(&lastValidatedPosition, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "accountID";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<unsigned int >::toBinaryStream(&accountID, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);

	_name = "raceID";
	_name.toBinaryStream(stream);
	_offset = stream->getOffset();
	stream->writeShort(0);
	TypeInfo<byte >::toBinaryStream(&raceID, stream);
	_totalSize = (uint16) (stream->getOffset() - (_offset + 2));
	stream->writeShort(_offset, _totalSize);


	return 55 + IntangibleObjectImplementation::writeObjectMembers(stream);
}

PlayerObjectImplementation::PlayerObjectImplementation() {
	_initializeImplementation();
	// server/zone/objects/player/PlayerObject.idl():  		commandMessageStrings.setNoDuplicateInsertPlan();
	(&commandMessageStrings)->setNoDuplicateInsertPlan();
	// server/zone/objects/player/PlayerObject.idl():  		teleporting = false;
	teleporting = false;
	// server/zone/objects/player/PlayerObject.idl():  		suiBoxNextID = 0;
	suiBoxNextID = 0;
	// server/zone/objects/player/PlayerObject.idl():  		savedParentID = 0;
	savedParentID = 0;
	// server/zone/objects/player/PlayerObject.idl():  		skillPoints = 0;
	skillPoints = 0;
	// server/zone/objects/player/PlayerObject.idl():  		forcePower = 0;
	forcePower = 0;
	// server/zone/objects/player/PlayerObject.idl():  		forcePowerMax = 0;
	forcePowerMax = 0;
	// server/zone/objects/player/PlayerObject.idl():  		duelList.setNoDuplicateInsertPlan();
	(&duelList)->setNoDuplicateInsertPlan();
	// server/zone/objects/player/PlayerObject.idl():  		persistentMessages.setNoDuplicateInsertPlan();
	(&persistentMessages)->setNoDuplicateInsertPlan();
	// server/zone/objects/player/PlayerObject.idl():  		consentList.setNoDuplicateInsertPlan();
	(&consentList)->setNoDuplicateInsertPlan();
	// server/zone/objects/player/PlayerObject.idl():  		holoMask = 0;
	holoMask = 0;
	// server/zone/objects/player/PlayerObject.idl():  		accountID = 0;
	accountID = 0;
	// server/zone/objects/player/PlayerObject.idl():  		teachingOrLearning = false;
	teachingOrLearning = false;
	// server/zone/objects/player/PlayerObject.idl():  		invisible = false;
	invisible = false;
	// server/zone/objects/player/PlayerObject.idl():  		factionStatus = 0;
	factionStatus = 0;
	// server/zone/objects/player/PlayerObject.idl():  		centeredBonus = 0;
	centeredBonus = 0;
	// server/zone/objects/player/PlayerObject.idl():  		raceID = 0;
	raceID = 0;
	// server/zone/objects/player/PlayerObject.idl():  		clientLastMovementStamp = 0;
	clientLastMovementStamp = 0;
	// server/zone/objects/player/PlayerObject.idl():  		maximumLots = 10;
	maximumLots = 10;
	// server/zone/objects/player/PlayerObject.idl():  		spawnedBlueFrog = false;
	spawnedBlueFrog = false;
	// server/zone/objects/player/PlayerObject.idl():  		setOffline();
	setOffline();
	// server/zone/objects/player/PlayerObject.idl():  		Logger.setLoggingName("PlayerObject");
	Logger::setLoggingName("PlayerObject");
}

void PlayerObjectImplementation::finalize() {
}

void PlayerObjectImplementation::addOwnedStructure(StructureObject* obj) {
	Locker _locker(_this);
	// server/zone/objects/player/PlayerObject.idl():  		ownedStructures.put(obj);
	(&ownedStructures)->put(obj);
}

void PlayerObjectImplementation::removeOwnedStructure(StructureObject* obj) {
	Locker _locker(_this);
	// server/zone/objects/player/PlayerObject.idl():  		ownedStructures.drop(obj);
	(&ownedStructures)->drop(obj);
}

int PlayerObjectImplementation::getTotalOwnedStructureCount() {
	Locker _locker(_this);
	// server/zone/objects/player/PlayerObject.idl():  		return ownedStructures.size();
	return (&ownedStructures)->size();
}

bool PlayerObjectImplementation::isOwnedStructure(StructureObject* obj) {
	Locker _locker(_this);
	// server/zone/objects/player/PlayerObject.idl():  		return ownedStructures.contains(obj);
	return (&ownedStructures)->contains(obj);
}

StructureObject* PlayerObjectImplementation::getOwnedStructure(int i) {
	Locker _locker(_this);
	// server/zone/objects/player/PlayerObject.idl():  		return ownedStructures.get(i);
	return (&ownedStructures)->get(i);
}

int PlayerObjectImplementation::getLotsRemaining() {
	Locker _locker(_this);
	// server/zone/objects/player/PlayerObject.idl():  		int lotsRemaining = maximumLots;
	int lotsRemaining = maximumLots;
	// server/zone/objects/player/PlayerObject.idl():  		}
	for (	// server/zone/objects/player/PlayerObject.idl():  		for (int i = 0;
	int i = 0;
	i < (&ownedStructures)->size();
 ++i) {
	// server/zone/objects/player/PlayerObject.idl():  			StructureObject structure = ownedStructures.get(i);
	StructureObject* structure = (&ownedStructures)->get(i);
	// server/zone/objects/player/PlayerObject.idl():  			lotsRemaining = lotsRemaining - structure.getLotSize();
	lotsRemaining = lotsRemaining - structure->getLotSize();
}
	// server/zone/objects/player/PlayerObject.idl():  		return lotsRemaining;
	return lotsRemaining;
}

bool PlayerObjectImplementation::hasLotsRemaining(int lots) {
	Locker _locker(_this);
	// server/zone/objects/player/PlayerObject.idl():  		return lots <= getLotsRemaining();
	return lots <= getLotsRemaining();
}

void PlayerObjectImplementation::setOffline() {
	// server/zone/objects/player/PlayerObject.idl():  		onlineStatus 
	if (isLinkDead()){
}
	// server/zone/objects/player/PlayerObject.idl():  		onlineStatus = OFFLINE;
	onlineStatus = OFFLINE;
}

void PlayerObjectImplementation::setLoggingOut() {
	// server/zone/objects/player/PlayerObject.idl():  		onlineStatus = LOGGINGOUT;
	onlineStatus = LOGGINGOUT;
}

FactionStandingList* PlayerObjectImplementation::getFactionStandingList() {
	// server/zone/objects/player/PlayerObject.idl():  		return factionStandingList;
	return (&factionStandingList);
}

void PlayerObjectImplementation::setLastNpcConvStr(const String& conv) {
	// server/zone/objects/player/PlayerObject.idl():  		lastNpcConvo = conv;
	lastNpcConvo = conv;
}

void PlayerObjectImplementation::setLastNpcConvMessStr(const String& mess) {
	// server/zone/objects/player/PlayerObject.idl():  		lastNpcConvoMessage = mess;
	lastNpcConvoMessage = mess;
}

String PlayerObjectImplementation::getLastNpcConvStr() {
	// server/zone/objects/player/PlayerObject.idl():  		return lastNpcConvo;
	return lastNpcConvo;
}

String PlayerObjectImplementation::getLastNpcConvMessStr() {
	// server/zone/objects/player/PlayerObject.idl():  		return lastNpcConvoMessage;
	return lastNpcConvoMessage;
}

String PlayerObjectImplementation::getLastNpcConvOption(int idx) {
	// server/zone/objects/player/PlayerObject.idl():  		return lastNpcConvoOptions.get(idx);
	return (&lastNpcConvoOptions)->get(idx);
}

void PlayerObjectImplementation::addLastNpcConvOptions(const String& option) {
	// server/zone/objects/player/PlayerObject.idl():  		lastNpcConvoOptions.add(option);
	(&lastNpcConvoOptions)->add(option);
}

int PlayerObjectImplementation::countLastNpcConvOptions() {
	// server/zone/objects/player/PlayerObject.idl():  		return lastNpcConvoOptions.size();
	return (&lastNpcConvoOptions)->size();
}

void PlayerObjectImplementation::clearLastNpcConvOptions() {
	// server/zone/objects/player/PlayerObject.idl():  		lastNpcConvoOptions.removeAll();
	(&lastNpcConvoOptions)->removeAll();
}

void PlayerObjectImplementation::setConversatingCreature(CreatureObject* creature) {
	// server/zone/objects/player/PlayerObject.idl():  		conversatingCreature = creature;
	conversatingCreature = creature;
}

CreatureObject* PlayerObjectImplementation::getConversatingCreature() {
	// server/zone/objects/player/PlayerObject.idl():  		return conversatingCreature;
	return conversatingCreature;
}

SortedVector<unsigned long long>* PlayerObjectImplementation::getPersistentMessages() {
	// server/zone/objects/player/PlayerObject.idl():  		return persistentMessages;
	return (&persistentMessages);
}

void PlayerObjectImplementation::addPersistentMessage(unsigned long long id) {
	// server/zone/objects/player/PlayerObject.idl():  		persistentMessages.put(id);
	(&persistentMessages)->put(id);
}

void PlayerObjectImplementation::dropPersistentMessage(unsigned long long id) {
	// server/zone/objects/player/PlayerObject.idl():  		persistentMessages.drop(id);
	(&persistentMessages)->drop(id);
}

void PlayerObjectImplementation::addToConsentList(const String& name) {
	// server/zone/objects/player/PlayerObject.idl():  		consentList.put(name);
	(&consentList)->put(name);
}

bool PlayerObjectImplementation::hasInConsentList(const String& name) {
	// server/zone/objects/player/PlayerObject.idl():  		return consentList.contains(name);
	return (&consentList)->contains(name);
}

void PlayerObjectImplementation::removeFromConsentList(const String& name) {
	// server/zone/objects/player/PlayerObject.idl():  		consentList.drop(name);
	(&consentList)->drop(name);
}

String PlayerObjectImplementation::getConsentName(int i) {
	// server/zone/objects/player/PlayerObject.idl():  		return consentList.get(i);
	return (&consentList)->get(i);
}

int PlayerObjectImplementation::getConsentListSize() {
	// server/zone/objects/player/PlayerObject.idl():  		return consentList.size();
	return (&consentList)->size();
}

String PlayerObjectImplementation::getFactionRank() {
	// server/zone/objects/player/PlayerObject.idl():  		return factionStandingList.getFactionRank();
	return (&factionStandingList)->getFactionRank();
}

void PlayerObjectImplementation::setFactionRank(const String& rank) {
	// server/zone/objects/player/PlayerObject.idl():  		factionStandingList.setFactionRank(rank);
	(&factionStandingList)->setFactionRank(rank);
}

void PlayerObjectImplementation::setCommandMessageString(unsigned int actionCRC, String& message) {
	// server/zone/objects/player/PlayerObject.idl():  		commandMessageStrings.put(actionCRC, message);
	(&commandMessageStrings)->put(actionCRC, message);
}

void PlayerObjectImplementation::removeCommandMessageString(unsigned int actionCRC) {
	// server/zone/objects/player/PlayerObject.idl():  		commandMessageStrings.drop(actionCRC);
	(&commandMessageStrings)->drop(actionCRC);
}

BuildingObject* PlayerObjectImplementation::getDeclaredResidence() {
	// server/zone/objects/player/PlayerObject.idl():  		return declaredResidence;
	return declaredResidence;
}

void PlayerObjectImplementation::setDeclaredResidence(BuildingObject* residence) {
	// server/zone/objects/player/PlayerObject.idl():  		declaredResidence = residence;
	declaredResidence = residence;
}

void PlayerObjectImplementation::setCloningFacility(BuildingObject* cloningfac) {
	// server/zone/objects/player/PlayerObject.idl():  		cloningFacility = cloningfac;
	cloningFacility = cloningfac;
}

BuildingObject* PlayerObjectImplementation::getCloningFacility() {
	// server/zone/objects/player/PlayerObject.idl():  		return cloningFacility;
	return cloningFacility;
}

bool PlayerObjectImplementation::isDigesting() {
	// server/zone/objects/player/PlayerObject.idl():  		}
	if (getDrinkFilling() > 0 || getFoodFilling() > 0){
	// server/zone/objects/player/PlayerObject.idl():  			return true;
	return true;
}

	else {
	// server/zone/objects/player/PlayerObject.idl():  			return false;
	return false;
}
}

String PlayerObjectImplementation::getSavedTerrainName() {
	// server/zone/objects/player/PlayerObject.idl():  		return savedTerrainName;
	return savedTerrainName;
}

void PlayerObjectImplementation::setSavedParentID(unsigned long long id) {
	// server/zone/objects/player/PlayerObject.idl():  		savedParentID = id;
	savedParentID = id;
}

void PlayerObjectImplementation::setSavedTerrainName(const String& name) {
	// server/zone/objects/player/PlayerObject.idl():  		savedTerrainName = name;
	savedTerrainName = name;
}

unsigned long long PlayerObjectImplementation::getSavedParentID() {
	// server/zone/objects/player/PlayerObject.idl():  		return savedParentID;
	return savedParentID;
}

bool PlayerObjectImplementation::hasSuiBox(unsigned int boxID) {
	// server/zone/objects/player/PlayerObject.idl():  		return suiBoxes.contains(boxID);
	return (&suiBoxes)->contains(boxID);
}

SuiBox* PlayerObjectImplementation::getSuiBox(unsigned int boxID) {
	// server/zone/objects/player/PlayerObject.idl():  		return suiBoxes.get(boxID);
	return (&suiBoxes)->get(boxID);
}

bool PlayerObjectImplementation::hasSuiBoxWindowType(unsigned int windowType) {
	// server/zone/objects/player/PlayerObject.idl():  		unsigned int type = 0;
	unsigned int type = 0;
	// server/zone/objects/player/PlayerObject.idl():  		}
	for (	// server/zone/objects/player/PlayerObject.idl():  		for (int i = 0;
	int i = 0;
	i < (&suiBoxes)->size();
 ++i) {
	// server/zone/objects/player/PlayerObject.idl():  			SuiBox sui = suiBoxes.get(i);
	SuiBox* sui = (&suiBoxes)->get(i);
	// server/zone/objects/player/PlayerObject.idl():  			type = sui.getWindowType();
	type = sui->getWindowType();
	// server/zone/objects/player/PlayerObject.idl():  		}
	if (windowType == type)	// server/zone/objects/player/PlayerObject.idl():  				return true;
	return true;
}
	// server/zone/objects/player/PlayerObject.idl():  		return false;
	return false;
}

void PlayerObjectImplementation::closeSuiWindowType(unsigned int windowType) {
	// server/zone/objects/player/PlayerObject.idl():  	}
	if (hasSuiBoxWindowType(windowType)){
	// server/zone/objects/player/PlayerObject.idl():  			SuiBox sui = getSuiBoxFromWindowType(windowType);
	SuiBox* sui = getSuiBoxFromWindowType(windowType);
	// server/zone/objects/player/PlayerObject.idl():  		}
	if (sui != NULL){
	// server/zone/objects/player/PlayerObject.idl():  				sendMessage(sui.generateCloseMessage());
	sendMessage(sui->generateCloseMessage());
	// server/zone/objects/player/PlayerObject.idl():  				removeSuiBox(sui.getBoxID());
	removeSuiBox(sui->getBoxID());
}
}
}

SuiBox* PlayerObjectImplementation::getSuiBoxFromWindowType(unsigned int windowType) {
	// server/zone/objects/player/PlayerObject.idl():  		unsigned int type = 0;
	unsigned int type = 0;
	// server/zone/objects/player/PlayerObject.idl():  		}
	for (	// server/zone/objects/player/PlayerObject.idl():  		for (int i = 0;
	int i = 0;
	i < (&suiBoxes)->size();
 ++i) {
	// server/zone/objects/player/PlayerObject.idl():  			SuiBox sui = suiBoxes.get(i);
	SuiBox* sui = (&suiBoxes)->get(i);
	// server/zone/objects/player/PlayerObject.idl():  		}
	if (windowType == sui->getWindowType())	// server/zone/objects/player/PlayerObject.idl():  				return sui;
	return sui;
}
	// server/zone/objects/player/PlayerObject.idl():  		return null;
	return NULL;
}

void PlayerObjectImplementation::addSuiBox(SuiBox* sui) {
	// server/zone/objects/player/PlayerObject.idl():  		unsigned int key = sui.getBoxID();
	unsigned int key = sui->getBoxID();
	// server/zone/objects/player/PlayerObject.idl():  		suiBoxes.put(key, sui);
	(&suiBoxes)->put(key, sui);
}

void PlayerObjectImplementation::resetIncapacitationCounter() {
	// server/zone/objects/player/PlayerObject.idl():  		incapacitationCounter = 0;
	incapacitationCounter = 0;
}

void PlayerObjectImplementation::updateIncapacitationCounter() {
	// server/zone/objects/player/PlayerObject.idl():  		incapacitationCounter++;
	incapacitationCounter ++;
	// server/zone/objects/player/PlayerObject.idl():  	}
	if (isFirstIncapacitation() || isFirstIncapacitationExpired())	// server/zone/objects/player/PlayerObject.idl():  			resetFirstIncapacitationTime();
	resetFirstIncapacitationTime();
}

bool PlayerObjectImplementation::isFirstIncapacitation() {
	// server/zone/objects/player/PlayerObject.idl():  		return incapacitationCounter == 1;
	return incapacitationCounter == 1;
}

byte PlayerObjectImplementation::getIncapacitationCounter() {
	// server/zone/objects/player/PlayerObject.idl():  		return incapacitationCounter;
	return incapacitationCounter;
}

void PlayerObjectImplementation::addToDuelList(CreatureObject* targetPlayer) {
	// server/zone/objects/player/PlayerObject.idl():  		duelList.put(targetPlayer);
	(&duelList)->put(targetPlayer);
}

void PlayerObjectImplementation::removeFromDuelList(CreatureObject* targetPlayer) {
	// server/zone/objects/player/PlayerObject.idl():  		duelList.drop(targetPlayer);
	(&duelList)->drop(targetPlayer);
}

CreatureObject* PlayerObjectImplementation::getDuelListObject(int index) {
	// server/zone/objects/player/PlayerObject.idl():  		return duelList.get(index);
	return (&duelList)->get(index);
}

bool PlayerObjectImplementation::requestedDuelTo(CreatureObject* targetPlayer) {
	// server/zone/objects/player/PlayerObject.idl():  		return duelList.contains(targetPlayer);
	return (&duelList)->contains(targetPlayer);
}

bool PlayerObjectImplementation::isDuelListEmpty() {
	// server/zone/objects/player/PlayerObject.idl():  		return duelList.isEmpty();
	return (&duelList)->isEmpty();
}

int PlayerObjectImplementation::getDuelListSize() {
	// server/zone/objects/player/PlayerObject.idl():  		return duelList.size();
	return (&duelList)->size();
}

UnicodeString PlayerObjectImplementation::getBiography() {
	// server/zone/objects/player/PlayerObject.idl():  		return biography;
	return biography;
}

void PlayerObjectImplementation::setBadge(unsigned int badge) {
	// server/zone/objects/player/PlayerObject.idl():  		badges.setBadge(badge);
	(&badges)->setBadge(badge);
}

void PlayerObjectImplementation::setSurveyTool(SurveyTool* tool) {
	// server/zone/objects/player/PlayerObject.idl():  		surveyTool = tool;
	surveyTool = tool;
}

SurveyTool* PlayerObjectImplementation::getSurveyTool() {
	// server/zone/objects/player/PlayerObject.idl():  		return surveyTool;
	return surveyTool;
}

CraftingTool* PlayerObjectImplementation::getLastCraftingToolUsed() {
	// server/zone/objects/player/PlayerObject.idl():  		return lastCraftingToolUsed;
	return lastCraftingToolUsed;
}

void PlayerObjectImplementation::setLastCraftingToolUsed(CraftingTool* tool) {
	// server/zone/objects/player/PlayerObject.idl():  		lastCraftingToolUsed = tool;
	lastCraftingToolUsed = tool;
}

void PlayerObjectImplementation::setTeleporting(bool val) {
	// server/zone/objects/player/PlayerObject.idl():  		teleporting = val;
	teleporting = val;
}

int PlayerObjectImplementation::getNumBadges() {
	// server/zone/objects/player/PlayerObject.idl():  		return badges.getNumBadges();
	return (&badges)->getNumBadges();
}

int PlayerObjectImplementation::getBadgeTypeCount(byte type) {
	// server/zone/objects/player/PlayerObject.idl():  		return badges.getTypeCount(type);
	return (&badges)->getTypeCount(type);
}

bool PlayerObjectImplementation::hasFriend(const String& name) {
	// server/zone/objects/player/PlayerObject.idl():  		return friendList.contains(name);
	return (&friendList)->contains(name);
}

bool PlayerObjectImplementation::isIgnoring(const String& name) {
	// server/zone/objects/player/PlayerObject.idl():  		return ignoreList.contains(name);
	return (&ignoreList)->contains(name);
}

void PlayerObjectImplementation::addReverseFriend(const String& name) {
	// server/zone/objects/player/PlayerObject.idl():  		friendList.addReversePlayer(name);
	(&friendList)->addReversePlayer(name);
}

void PlayerObjectImplementation::removeReverseFriend(const String& name) {
	// server/zone/objects/player/PlayerObject.idl():  		friendList.removeReversePlayer(name);
	(&friendList)->removeReversePlayer(name);
}

bool PlayerObjectImplementation::hasWaypoint(unsigned long long objectID) {
	// server/zone/objects/player/PlayerObject.idl():  		return waypointList.contains(objectID);
	return (&waypointList)->contains(objectID);
}

bool PlayerObjectImplementation::hasAbility(const String& ability) {
	// server/zone/objects/player/PlayerObject.idl():  		return abilityList.contains(ability);
	return (&abilityList)->contains(ability);
}

bool PlayerObjectImplementation::hasCommandMessageString(unsigned int actionCRC) {
	// server/zone/objects/player/PlayerObject.idl():  		return commandMessageStrings.contains(actionCRC);
	return (&commandMessageStrings)->contains(actionCRC);
}

unsigned int PlayerObjectImplementation::getCharacterBitmask() {
	// server/zone/objects/player/PlayerObject.idl():  		return characterBitmask;
	return characterBitmask;
}

String PlayerObjectImplementation::getTitle() {
	// server/zone/objects/player/PlayerObject.idl():  		return title;
	return title;
}

unsigned int PlayerObjectImplementation::getAdminLevel() {
	// server/zone/objects/player/PlayerObject.idl():  		return adminLevel;
	return adminLevel;
}

void PlayerObjectImplementation::setAdminLevel(unsigned int adminlvl) {
	// server/zone/objects/player/PlayerObject.idl():  		adminLevel = adminlvl;
	adminLevel = adminlvl;
}

void PlayerObjectImplementation::setBiography(const UnicodeString& bio) {
	// server/zone/objects/player/PlayerObject.idl():  		biography = bio;
	biography = bio;
}

bool PlayerObjectImplementation::isDeveloper() {
	// server/zone/objects/player/PlayerObject.idl():  		return adminLevel == DEV;
	return adminLevel == DEV;
}

bool PlayerObjectImplementation::isCSR() {
	// server/zone/objects/player/PlayerObject.idl():  		return adminLevel == CSR;
	return adminLevel == CSR;
}

bool PlayerObjectImplementation::isPrivileged() {
	// server/zone/objects/player/PlayerObject.idl():  		return adminLevel > 0;
	return adminLevel > 0;
}

void PlayerObjectImplementation::setCharacterBitmask(unsigned int bitmask) {
	// server/zone/objects/player/PlayerObject.idl():  		characterBitmask = bitmask;
	characterBitmask = bitmask;
}

VectorMap<String, int>* PlayerObjectImplementation::getXpTypeCapList() {
	// server/zone/objects/player/PlayerObject.idl():  	 return xpTypeCapList;
	return (&xpTypeCapList);
}

DeltaVectorMap<String, int>* PlayerObjectImplementation::getExperienceList() {
	// server/zone/objects/player/PlayerObject.idl():  		return experienceList;
	return (&experienceList);
}

int PlayerObjectImplementation::getForcePower() {
	// server/zone/objects/player/PlayerObject.idl():  		return forcePower;
	return forcePower;
}

int PlayerObjectImplementation::getForcePowerMax() {
	// server/zone/objects/player/PlayerObject.idl():  		return forcePowerMax;
	return forcePowerMax;
}

WaypointList* PlayerObjectImplementation::getWaypointList() {
	// server/zone/objects/player/PlayerObject.idl():  		return waypointList;
	return (&waypointList);
}

AbilityList* PlayerObjectImplementation::getAbilityList() {
	// server/zone/objects/player/PlayerObject.idl():  		return abilityList;
	return (&abilityList);
}

SchematicList* PlayerObjectImplementation::getSchematics() {
	// server/zone/objects/player/PlayerObject.idl():  		return schematicList;
	return (&schematicList);
}

DraftSchematic* PlayerObjectImplementation::getSchematic(int i) {
	// server/zone/objects/player/PlayerObject.idl():  		return schematicList.get(i);
	return (&schematicList)->get(i);
}

int PlayerObjectImplementation::getFoodFilling() {
	// server/zone/objects/player/PlayerObject.idl():  		return foodFilling;
	return foodFilling;
}

int PlayerObjectImplementation::getFoodFillingMax() {
	// server/zone/objects/player/PlayerObject.idl():  		return foodFillingMax;
	return foodFillingMax;
}

int PlayerObjectImplementation::getDrinkFilling() {
	// server/zone/objects/player/PlayerObject.idl():  		return drinkFilling;
	return drinkFilling;
}

int PlayerObjectImplementation::getDrinkFillingMax() {
	// server/zone/objects/player/PlayerObject.idl():  		return drinkFillingMax;
	return drinkFillingMax;
}

int PlayerObjectImplementation::getJediState() {
	// server/zone/objects/player/PlayerObject.idl():  		return jediState;
	return jediState;
}

byte PlayerObjectImplementation::getLanguageID() {
	// server/zone/objects/player/PlayerObject.idl():  		return languageID;
	return languageID;
}

DeltaVector<String>* PlayerObjectImplementation::getFriendList() {
	// server/zone/objects/player/PlayerObject.idl():  		return friendList;
	return (&friendList);
}

bool PlayerObjectImplementation::isTeleporting() {
	// server/zone/objects/player/PlayerObject.idl():  		return teleporting;
	return teleporting;
}

void PlayerObjectImplementation::addChatRoom(ChatRoom* room) {
	// server/zone/objects/player/PlayerObject.idl():  		chatRooms.put(room);
	(&chatRooms)->put(room);
}

void PlayerObjectImplementation::removeChatRoom(ChatRoom* room) {
	// server/zone/objects/player/PlayerObject.idl():  		chatRooms.drop(room);
	(&chatRooms)->drop(room);
}

void PlayerObjectImplementation::clearTradeContainer() {
	// server/zone/objects/player/PlayerObject.idl():  		tradeContainer.clear();
	(&tradeContainer)->clear();
}

TradeContainer* PlayerObjectImplementation::getTradeContainer() {
	// server/zone/objects/player/PlayerObject.idl():  		return tradeContainer;
	return (&tradeContainer);
}

DeltaVector<String>* PlayerObjectImplementation::getIgnoreList() {
	// server/zone/objects/player/PlayerObject.idl():  		return ignoreList;
	return (&ignoreList);
}

int PlayerObjectImplementation::getExperience(const String& xp) {
	// server/zone/objects/player/PlayerObject.idl():  		}
	if ((&experienceList)->contains(xp)){
	// server/zone/objects/player/PlayerObject.idl():  			return experienceList.get(xp);
	return (&experienceList)->get(xp);
}

	else {
	// server/zone/objects/player/PlayerObject.idl():  			return 0;
	return 0;
}
}

String PlayerObjectImplementation::getCommandMessageString(unsigned int actionCRC) {
	// server/zone/objects/player/PlayerObject.idl():  		return commandMessageStrings.get(actionCRC);
	return (&commandMessageStrings)->get(actionCRC);
}

bool PlayerObjectImplementation::hasBadge(unsigned int badge) {
	// server/zone/objects/player/PlayerObject.idl():  		return badges.hasBadge(badge);
	return (&badges)->hasBadge(badge);
}

bool PlayerObjectImplementation::isOnline() {
	// server/zone/objects/player/PlayerObject.idl():  		return onlineStatus != OFFLINE && onlineStatus != LINKDEAD;
	return onlineStatus != OFFLINE && onlineStatus != LINKDEAD;
}

bool PlayerObjectImplementation::isOffline() {
	// server/zone/objects/player/PlayerObject.idl():  		return onlineStatus == OFFLINE;
	return onlineStatus == OFFLINE;
}

bool PlayerObjectImplementation::isLoading() {
	// server/zone/objects/player/PlayerObject.idl():  		return onlineStatus == LOADING || onlineStatus == LOGGINGOUT;
	return onlineStatus == LOADING || onlineStatus == LOGGINGOUT;
}

bool PlayerObjectImplementation::isLinkDead() {
	// server/zone/objects/player/PlayerObject.idl():  		return onlineStatus == LINKDEAD;
	return onlineStatus == LINKDEAD;
}

bool PlayerObjectImplementation::isLoggingIn() {
	// server/zone/objects/player/PlayerObject.idl():  		return onlineStatus == LOGGINGIN;
	return onlineStatus == LOGGINGIN;
}

bool PlayerObjectImplementation::isLoggingOut() {
	// server/zone/objects/player/PlayerObject.idl():  		return onlineStatus == LOGGINGOUT;
	return onlineStatus == LOGGINGOUT;
}

void PlayerObjectImplementation::setSkillPoints(int points) {
	// server/zone/objects/player/PlayerObject.idl():  		skillPoints = points;
	skillPoints = points;
}

void PlayerObjectImplementation::addSkillPoints(int points) {
	// server/zone/objects/player/PlayerObject.idl():  		skillPoints += points;
	skillPoints += points;
}

int PlayerObjectImplementation::getSkillPoints() {
	// server/zone/objects/player/PlayerObject.idl():  		return skillPoints;
	return skillPoints;
}

ValidatedPosition* PlayerObjectImplementation::getLastValidatedPosition() {
	// server/zone/objects/player/PlayerObject.idl():  		return lastValidatedPosition;
	return (&lastValidatedPosition);
}

void PlayerObjectImplementation::updateLastValidatedPosition() {
	// server/zone/objects/player/PlayerObject.idl():  		lastValidatedPosition.update(super.getParent());
	(&lastValidatedPosition)->update(IntangibleObjectImplementation::getParent());
	// server/zone/objects/player/PlayerObject.idl():  		serverLastMovementStamp.updateToCurrentTime();
	(&serverLastMovementStamp)->updateToCurrentTime();
}

void PlayerObjectImplementation::setSpawnedBlueFrog() {
	// server/zone/objects/player/PlayerObject.idl():  		spawnedBlueFrog = true;
	spawnedBlueFrog = true;
}

bool PlayerObjectImplementation::hasSpawnedBlueFrog() {
	// server/zone/objects/player/PlayerObject.idl():  		return spawnedBlueFrog;
	return spawnedBlueFrog;
}

unsigned int PlayerObjectImplementation::getAccountID() {
	// server/zone/objects/player/PlayerObject.idl():  		return accountID;
	return accountID;
}

unsigned long long PlayerObjectImplementation::getServerMovementTimeDelta() {
	// server/zone/objects/player/PlayerObject.idl():  		return serverLastMovementStamp.miliDifference();
	return (&serverLastMovementStamp)->miliDifference();
}

Time* PlayerObjectImplementation::getServerMovementTimeStamp() {
	// server/zone/objects/player/PlayerObject.idl():  		return serverLastMovementStamp;
	return (&serverLastMovementStamp);
}

void PlayerObjectImplementation::setClientLastMovementStamp(unsigned int stamp) {
	// server/zone/objects/player/PlayerObject.idl():  		clientLastMovementStamp = stamp;
	clientLastMovementStamp = stamp;
}

void PlayerObjectImplementation::updateServerLastMovementStamp() {
	// server/zone/objects/player/PlayerObject.idl():  		serverLastMovementStamp.updateToCurrentTime();
	(&serverLastMovementStamp)->updateToCurrentTime();
}

void PlayerObjectImplementation::setAccountID(unsigned int id) {
	// server/zone/objects/player/PlayerObject.idl():  		accountID = id;
	accountID = id;
}

int PlayerObjectImplementation::getFactionStatus() {
	// server/zone/objects/player/PlayerObject.idl():  		return factionStatus;
	return factionStatus;
}

unsigned int PlayerObjectImplementation::getClientLastMovementStamp() {
	// server/zone/objects/player/PlayerObject.idl():  		return clientLastMovementStamp;
	return clientLastMovementStamp;
}

int PlayerObjectImplementation::getCenteredBonus() {
	// server/zone/objects/player/PlayerObject.idl():  		return centeredBonus;
	return centeredBonus;
}

void PlayerObjectImplementation::setCenteredBonus(int bonus) {
	// server/zone/objects/player/PlayerObject.idl():  		centeredBonus = bonus;
	centeredBonus = bonus;
}

bool PlayerObjectImplementation::isInvisible() {
	// server/zone/objects/player/PlayerObject.idl():  		return invisible;
	return invisible;
}

void PlayerObjectImplementation::setInvisible(bool invis) {
	// server/zone/objects/player/PlayerObject.idl():  		invisible = invis;
	invisible = invis;
}

void PlayerObjectImplementation::setHologrindMask(unsigned int mask) {
	// server/zone/objects/player/PlayerObject.idl():  		holoMask = mask;
	holoMask = mask;
}

unsigned int PlayerObjectImplementation::getHologrindMask() {
	// server/zone/objects/player/PlayerObject.idl():  		return holoMask;
	return holoMask;
}

byte PlayerObjectImplementation::getRaceID() {
	// server/zone/objects/player/PlayerObject.idl():  		return raceID;
	return raceID;
}

void PlayerObjectImplementation::setRaceID(byte race) {
	// server/zone/objects/player/PlayerObject.idl():  		raceID = race;
	raceID = race;
}

void PlayerObjectImplementation::setMaximumLots(byte lots) {
	// server/zone/objects/player/PlayerObject.idl():  		maximumLots = lots;
	maximumLots = lots;
}

byte PlayerObjectImplementation::getMaximumLots() {
	// server/zone/objects/player/PlayerObject.idl():  		return maximumLots;
	return maximumLots;
}

/*
 *	PlayerObjectAdapter
 */

PlayerObjectAdapter::PlayerObjectAdapter(PlayerObject* obj) : IntangibleObjectAdapter(obj) {
}

Packet* PlayerObjectAdapter::invokeMethod(uint32 methid, DistributedMethod* inv) {
	Packet* resp = new MethodReturnMessage(0);

	switch (methid) {
	case RPC_FINALIZE__:
		finalize();
		break;
	case RPC_NOTIFYLOADFROMDATABASE__:
		notifyLoadFromDatabase();
		break;
	case RPC_UNLOAD__:
		unload();
		break;
	case RPC_INITIALIZETRANSIENTMEMBERS__:
		initializeTransientMembers();
		break;
	case RPC_SENDBASELINESTO__SCENEOBJECT_:
		sendBaselinesTo(static_cast<SceneObject*>(inv->getObjectParameter()));
		break;
	case RPC_SENDMESSAGE__BASEPACKET_:
		sendMessage(static_cast<BasePacket*>(inv->getObjectParameter()));
		break;
	case RPC_ADDOWNEDSTRUCTURE__STRUCTUREOBJECT_:
		addOwnedStructure(static_cast<StructureObject*>(inv->getObjectParameter()));
		break;
	case RPC_REMOVEOWNEDSTRUCTURE__STRUCTUREOBJECT_:
		removeOwnedStructure(static_cast<StructureObject*>(inv->getObjectParameter()));
		break;
	case RPC_GETTOTALOWNEDSTRUCTURECOUNT__:
		resp->insertSignedInt(getTotalOwnedStructureCount());
		break;
	case RPC_ISOWNEDSTRUCTURE__STRUCTUREOBJECT_:
		resp->insertBoolean(isOwnedStructure(static_cast<StructureObject*>(inv->getObjectParameter())));
		break;
	case RPC_GETOWNEDSTRUCTURE__INT_:
		resp->insertLong(getOwnedStructure(inv->getSignedIntParameter())->_getObjectID());
		break;
	case RPC_GETLOTSREMAINING__:
		resp->insertSignedInt(getLotsRemaining());
		break;
	case RPC_HASLOTSREMAINING__INT_:
		resp->insertBoolean(hasLotsRemaining(inv->getSignedIntParameter()));
		break;
	case RPC_NOTIFYSCENEREADY__:
		notifySceneReady();
		break;
	case RPC_ADDEXPERIENCE__STRING_INT_BOOL_:
		resp->insertSignedInt(addExperience(inv->getAsciiParameter(_param0_addExperience__String_int_bool_), inv->getSignedIntParameter(), inv->getBooleanParameter()));
		break;
	case RPC_REMOVEEXPERIENCE__STRING_BOOL_:
		removeExperience(inv->getAsciiParameter(_param0_removeExperience__String_bool_), inv->getBooleanParameter());
		break;
	case RPC_ADDWAYPOINT__WAYPOINTOBJECT_BOOL_BOOL_:
		addWaypoint(static_cast<WaypointObject*>(inv->getObjectParameter()), inv->getBooleanParameter(), inv->getBooleanParameter());
		break;
	case RPC_SETWAYPOINT__WAYPOINTOBJECT_BOOL_:
		setWaypoint(static_cast<WaypointObject*>(inv->getObjectParameter()), inv->getBooleanParameter());
		break;
	case RPC_ADDWAYPOINT__STRING_FLOAT_FLOAT_BOOL_:
		addWaypoint(inv->getAsciiParameter(_param0_addWaypoint__String_float_float_bool_), inv->getFloatParameter(), inv->getFloatParameter(), inv->getBooleanParameter());
		break;
	case RPC_REMOVEWAYPOINT__LONG_BOOL_:
		removeWaypoint(inv->getUnsignedLongParameter(), inv->getBooleanParameter());
		break;
	case RPC_SETLANGUAGEID__BYTE_BOOL_:
		setLanguageID(inv->getByteParameter(), inv->getBooleanParameter());
		break;
	case RPC_ADDFRIEND__STRING_BOOL_:
		addFriend(inv->getAsciiParameter(_param0_addFriend__String_bool_), inv->getBooleanParameter());
		break;
	case RPC_REMOVEFRIEND__STRING_BOOL_:
		removeFriend(inv->getAsciiParameter(_param0_removeFriend__String_bool_), inv->getBooleanParameter());
		break;
	case RPC_ADDIGNORE__STRING_BOOL_:
		addIgnore(inv->getAsciiParameter(_param0_addIgnore__String_bool_), inv->getBooleanParameter());
		break;
	case RPC_REMOVEIGNORE__STRING_BOOL_:
		removeIgnore(inv->getAsciiParameter(_param0_removeIgnore__String_bool_), inv->getBooleanParameter());
		break;
	case RPC_SETTITLE__STRING_BOOL_:
		setTitle(inv->getAsciiParameter(_param0_setTitle__String_bool_), inv->getBooleanParameter());
		break;
	case RPC_SETFOODFILLING__INT_BOOL_:
		setFoodFilling(inv->getSignedIntParameter(), inv->getBooleanParameter());
		break;
	case RPC_SETDRINKFILLING__INT_BOOL_:
		setDrinkFilling(inv->getSignedIntParameter(), inv->getBooleanParameter());
		break;
	case RPC_INCREASEFACTIONSTANDING__STRING_FLOAT_:
		increaseFactionStanding(inv->getAsciiParameter(_param0_increaseFactionStanding__String_float_), inv->getFloatParameter());
		break;
	case RPC_DECREASEFACTIONSTANDING__STRING_FLOAT_:
		decreaseFactionStanding(inv->getAsciiParameter(_param0_decreaseFactionStanding__String_float_), inv->getFloatParameter());
		break;
	case RPC_GETFACTIONSTANDING__STRING_:
		resp->insertFloat(getFactionStanding(inv->getAsciiParameter(_param0_getFactionStanding__String_)));
		break;
	case RPC_GETSURVEYWAYPOINT__:
		resp->insertLong(getSurveyWaypoint()->_getObjectID());
		break;
	case RPC_ACTIVATERECOVERY__:
		activateRecovery();
		break;
	case RPC_DORECOVERY__:
		doRecovery();
		break;
	case RPC_DISCONNECT__BOOL_BOOL_:
		disconnect(inv->getBooleanParameter(), inv->getBooleanParameter());
		break;
	case RPC_RELOAD__ZONECLIENTSESSION_:
		reload(static_cast<ZoneClientSession*>(inv->getObjectParameter()));
		break;
	case RPC_SETOFFLINE__:
		setOffline();
		break;
	case RPC_SETLINKDEAD__:
		setLinkDead();
		break;
	case RPC_SETONLINE__:
		setOnline();
		break;
	case RPC_SETLOGGINGOUT__:
		setLoggingOut();
		break;
	case RPC_SENDBADGESRESPONSETO__CREATUREOBJECT_:
		sendBadgesResponseTo(static_cast<CreatureObject*>(inv->getObjectParameter()));
		break;
	case RPC_LOGOUT__BOOL_:
		logout(inv->getBooleanParameter());
		break;
	case RPC_SETLASTNPCCONVSTR__STRING_:
		setLastNpcConvStr(inv->getAsciiParameter(_param0_setLastNpcConvStr__String_));
		break;
	case RPC_SETLASTNPCCONVMESSSTR__STRING_:
		setLastNpcConvMessStr(inv->getAsciiParameter(_param0_setLastNpcConvMessStr__String_));
		break;
	case RPC_GETLASTNPCCONVSTR__:
		resp->insertAscii(getLastNpcConvStr());
		break;
	case RPC_GETLASTNPCCONVMESSSTR__:
		resp->insertAscii(getLastNpcConvMessStr());
		break;
	case RPC_GETLASTNPCCONVOPTION__INT_:
		resp->insertAscii(getLastNpcConvOption(inv->getSignedIntParameter()));
		break;
	case RPC_ADDLASTNPCCONVOPTIONS__STRING_:
		addLastNpcConvOptions(inv->getAsciiParameter(_param0_addLastNpcConvOptions__String_));
		break;
	case RPC_COUNTLASTNPCCONVOPTIONS__:
		resp->insertSignedInt(countLastNpcConvOptions());
		break;
	case RPC_CLEARLASTNPCCONVOPTIONS__:
		clearLastNpcConvOptions();
		break;
	case RPC_SETCONVERSATINGCREATURE__CREATUREOBJECT_:
		setConversatingCreature(static_cast<CreatureObject*>(inv->getObjectParameter()));
		break;
	case RPC_GETCONVERSATINGCREATURE__:
		resp->insertLong(getConversatingCreature()->_getObjectID());
		break;
	case RPC_ADDPERSISTENTMESSAGE__LONG_:
		addPersistentMessage(inv->getUnsignedLongParameter());
		break;
	case RPC_DROPPERSISTENTMESSAGE__LONG_:
		dropPersistentMessage(inv->getUnsignedLongParameter());
		break;
	case RPC_UNLOADSPAWNEDCHILDREN__:
		unloadSpawnedChildren();
		break;
	case RPC_ADDTOCONSENTLIST__STRING_:
		addToConsentList(inv->getAsciiParameter(_param0_addToConsentList__String_));
		break;
	case RPC_HASINCONSENTLIST__STRING_:
		resp->insertBoolean(hasInConsentList(inv->getAsciiParameter(_param0_hasInConsentList__String_)));
		break;
	case RPC_REMOVEFROMCONSENTLIST__STRING_:
		removeFromConsentList(inv->getAsciiParameter(_param0_removeFromConsentList__String_));
		break;
	case RPC_GETCONSENTNAME__INT_:
		resp->insertAscii(getConsentName(inv->getSignedIntParameter()));
		break;
	case RPC_GETCONSENTLISTSIZE__:
		resp->insertSignedInt(getConsentListSize());
		break;
	case RPC_SETCOMMANDMESSAGESTRING__INT_STRING_:
		setCommandMessageString(inv->getUnsignedIntParameter(), inv->getAsciiParameter(_param1_setCommandMessageString__int_String_));
		break;
	case RPC_REMOVECOMMANDMESSAGESTRING__INT_:
		removeCommandMessageString(inv->getUnsignedIntParameter());
		break;
	case RPC_GETDECLAREDRESIDENCE__:
		resp->insertLong(getDeclaredResidence()->_getObjectID());
		break;
	case RPC_SETDECLAREDRESIDENCE__BUILDINGOBJECT_:
		setDeclaredResidence(static_cast<BuildingObject*>(inv->getObjectParameter()));
		break;
	case RPC_SETCLONINGFACILITY__BUILDINGOBJECT_:
		setCloningFacility(static_cast<BuildingObject*>(inv->getObjectParameter()));
		break;
	case RPC_GETCLONINGFACILITY__:
		resp->insertLong(getCloningFacility()->_getObjectID());
		break;
	case RPC_NOTIFYONLINE__:
		notifyOnline();
		break;
	case RPC_DODIGEST__:
		doDigest();
		break;
	case RPC_ISDIGESTING__:
		resp->insertBoolean(isDigesting());
		break;
	case RPC_GETSAVEDTERRAINNAME__:
		resp->insertAscii(getSavedTerrainName());
		break;
	case RPC_SETSAVEDPARENTID__LONG_:
		setSavedParentID(inv->getUnsignedLongParameter());
		break;
	case RPC_SETSAVEDTERRAINNAME__STRING_:
		setSavedTerrainName(inv->getAsciiParameter(_param0_setSavedTerrainName__String_));
		break;
	case RPC_SETFORCEPOWER__INT_BOOL_:
		setForcePower(inv->getSignedIntParameter(), inv->getBooleanParameter());
		break;
	case RPC_SETFORCEPOWERMAX__INT_BOOL_:
		setForcePowerMax(inv->getSignedIntParameter(), inv->getBooleanParameter());
		break;
	case RPC_ACTIVATEFORCEREGEN__:
		activateForceRegen();
		break;
	case RPC_GETSAVEDPARENTID__:
		resp->insertLong(getSavedParentID());
		break;
	case RPC_GETNEWSUIBOXID__INT_:
		resp->insertInt(getNewSuiBoxID(inv->getUnsignedIntParameter()));
		break;
	case RPC_HASSUIBOX__INT_:
		resp->insertBoolean(hasSuiBox(inv->getUnsignedIntParameter()));
		break;
	case RPC_GETSUIBOX__INT_:
		resp->insertLong(getSuiBox(inv->getUnsignedIntParameter())->_getObjectID());
		break;
	case RPC_REMOVESUIBOX__INT_BOOL_:
		removeSuiBox(inv->getUnsignedIntParameter(), inv->getBooleanParameter());
		break;
	case RPC_REMOVESUIBOXTYPE__INT_:
		removeSuiBoxType(inv->getUnsignedIntParameter());
		break;
	case RPC_HASSUIBOXWINDOWTYPE__INT_:
		resp->insertBoolean(hasSuiBoxWindowType(inv->getUnsignedIntParameter()));
		break;
	case RPC_CLOSESUIWINDOWTYPE__INT_:
		closeSuiWindowType(inv->getUnsignedIntParameter());
		break;
	case RPC_GETSUIBOXFROMWINDOWTYPE__INT_:
		resp->insertLong(getSuiBoxFromWindowType(inv->getUnsignedIntParameter())->_getObjectID());
		break;
	case RPC_ADDSUIBOX__SUIBOX_:
		addSuiBox(static_cast<SuiBox*>(inv->getObjectParameter()));
		break;
	case RPC_ISFIRSTINCAPACITATIONEXPIRED__:
		resp->insertBoolean(isFirstIncapacitationExpired());
		break;
	case RPC_RESETINCAPACITATIONCOUNTER__:
		resetIncapacitationCounter();
		break;
	case RPC_RESETFIRSTINCAPACITATIONTIME__:
		resetFirstIncapacitationTime();
		break;
	case RPC_UPDATEINCAPACITATIONCOUNTER__:
		updateIncapacitationCounter();
		break;
	case RPC_ISFIRSTINCAPACITATION__:
		resp->insertBoolean(isFirstIncapacitation());
		break;
	case RPC_GETINCAPACITATIONCOUNTER__:
		resp->insertByte(getIncapacitationCounter());
		break;
	case RPC_ADDTODUELLIST__CREATUREOBJECT_:
		addToDuelList(static_cast<CreatureObject*>(inv->getObjectParameter()));
		break;
	case RPC_REMOVEFROMDUELLIST__CREATUREOBJECT_:
		removeFromDuelList(static_cast<CreatureObject*>(inv->getObjectParameter()));
		break;
	case RPC_GETDUELLISTOBJECT__INT_:
		resp->insertLong(getDuelListObject(inv->getSignedIntParameter())->_getObjectID());
		break;
	case RPC_REQUESTEDDUELTO__CREATUREOBJECT_:
		resp->insertBoolean(requestedDuelTo(static_cast<CreatureObject*>(inv->getObjectParameter())));
		break;
	case RPC_ISDUELLISTEMPTY__:
		resp->insertBoolean(isDuelListEmpty());
		break;
	case RPC_GETDUELLISTSIZE__:
		resp->insertSignedInt(getDuelListSize());
		break;
	case RPC_GETBIOGRAPHY__:
		resp->insertUnicode(getBiography());
		break;
	case RPC_NOTIFYOFFLINE__:
		notifyOffline();
		break;
	case RPC_SETBADGE__INT_:
		setBadge(inv->getUnsignedIntParameter());
		break;
	case RPC_AWARDBADGE__INT_:
		awardBadge(inv->getUnsignedIntParameter());
		break;
	case RPC_SETSURVEYTOOL__SURVEYTOOL_:
		setSurveyTool(static_cast<SurveyTool*>(inv->getObjectParameter()));
		break;
	case RPC_GETSURVEYTOOL__:
		resp->insertLong(getSurveyTool()->_getObjectID());
		break;
	case RPC_GETLASTCRAFTINGTOOLUSED__:
		resp->insertLong(getLastCraftingToolUsed()->_getObjectID());
		break;
	case RPC_SETLASTCRAFTINGTOOLUSED__CRAFTINGTOOL_:
		setLastCraftingToolUsed(static_cast<CraftingTool*>(inv->getObjectParameter()));
		break;
	case RPC_SETTELEPORTING__BOOL_:
		setTeleporting(inv->getBooleanParameter());
		break;
	case RPC_GETNUMBADGES__:
		resp->insertSignedInt(getNumBadges());
		break;
	case RPC_GETBADGETYPECOUNT__BYTE_:
		resp->insertSignedInt(getBadgeTypeCount(inv->getByteParameter()));
		break;
	case RPC_HASFRIEND__STRING_:
		resp->insertBoolean(hasFriend(inv->getAsciiParameter(_param0_hasFriend__String_)));
		break;
	case RPC_ISIGNORING__STRING_:
		resp->insertBoolean(isIgnoring(inv->getAsciiParameter(_param0_isIgnoring__String_)));
		break;
	case RPC_ADDREVERSEFRIEND__STRING_:
		addReverseFriend(inv->getAsciiParameter(_param0_addReverseFriend__String_));
		break;
	case RPC_REMOVEREVERSEFRIEND__STRING_:
		removeReverseFriend(inv->getAsciiParameter(_param0_removeReverseFriend__String_));
		break;
	case RPC_SENDFRIENDLISTS__:
		sendFriendLists();
		break;
	case RPC_HASWAYPOINT__LONG_:
		resp->insertBoolean(hasWaypoint(inv->getUnsignedLongParameter()));
		break;
	case RPC_HASCOMMANDMESSAGESTRING__INT_:
		resp->insertBoolean(hasCommandMessageString(inv->getUnsignedIntParameter()));
		break;
	case RPC_GETCHARACTERBITMASK__:
		resp->insertInt(getCharacterBitmask());
		break;
	case RPC_GETTITLE__:
		resp->insertAscii(getTitle());
		break;
	case RPC_GETADMINLEVEL__:
		resp->insertInt(getAdminLevel());
		break;
	case RPC_SETADMINLEVEL__INT_:
		setAdminLevel(inv->getUnsignedIntParameter());
		break;
	case RPC_SETBIOGRAPHY__UNICODESTRING_:
		setBiography(inv->getUnicodeParameter(_param0_setBiography__UnicodeString_));
		break;
	case RPC_ISDEVELOPER__:
		resp->insertBoolean(isDeveloper());
		break;
	case RPC_ISCSR__:
		resp->insertBoolean(isCSR());
		break;
	case RPC_ISPRIVILEGED__:
		resp->insertBoolean(isPrivileged());
		break;
	case RPC_SETCHARACTERBITMASK__INT_:
		setCharacterBitmask(inv->getUnsignedIntParameter());
		break;
	case RPC_SETCHARACTERBIT__INT_BOOL_:
		resp->insertBoolean(setCharacterBit(inv->getUnsignedIntParameter(), inv->getBooleanParameter()));
		break;
	case RPC_CLEARCHARACTERBIT__INT_BOOL_:
		resp->insertBoolean(clearCharacterBit(inv->getUnsignedIntParameter(), inv->getBooleanParameter()));
		break;
	case RPC_TOGGLECHARACTERBIT__INT_:
		toggleCharacterBit(inv->getUnsignedIntParameter());
		break;
	case RPC_GETFORCEPOWER__:
		resp->insertSignedInt(getForcePower());
		break;
	case RPC_GETFORCEPOWERMAX__:
		resp->insertSignedInt(getForcePowerMax());
		break;
	case RPC_GETSCHEMATIC__INT_:
		resp->insertLong(getSchematic(inv->getSignedIntParameter())->_getObjectID());
		break;
	case RPC_GETFOODFILLING__:
		resp->insertSignedInt(getFoodFilling());
		break;
	case RPC_GETFOODFILLINGMAX__:
		resp->insertSignedInt(getFoodFillingMax());
		break;
	case RPC_GETDRINKFILLING__:
		resp->insertSignedInt(getDrinkFilling());
		break;
	case RPC_GETDRINKFILLINGMAX__:
		resp->insertSignedInt(getDrinkFillingMax());
		break;
	case RPC_GETJEDISTATE__:
		resp->insertSignedInt(getJediState());
		break;
	case RPC_GETLANGUAGEID__:
		resp->insertByte(getLanguageID());
		break;
	case RPC_ISTELEPORTING__:
		resp->insertBoolean(isTeleporting());
		break;
	case RPC_ADDCHATROOM__CHATROOM_:
		addChatRoom(static_cast<ChatRoom*>(inv->getObjectParameter()));
		break;
	case RPC_REMOVECHATROOM__CHATROOM_:
		removeChatRoom(static_cast<ChatRoom*>(inv->getObjectParameter()));
		break;
	case RPC_GETEXPERIENCE__STRING_:
		resp->insertSignedInt(getExperience(inv->getAsciiParameter(_param0_getExperience__String_)));
		break;
	case RPC_MAXIMIZEEXPERIENCE__:
		maximizeExperience();
		break;
	case RPC_GETCOMMANDMESSAGESTRING__INT_:
		resp->insertAscii(getCommandMessageString(inv->getUnsignedIntParameter()));
		break;
	case RPC_HASBADGE__INT_:
		resp->insertBoolean(hasBadge(inv->getUnsignedIntParameter()));
		break;
	case RPC_CLEARDISCONNECTEVENT__:
		clearDisconnectEvent();
		break;
	case RPC_CLEARRECOVERYEVENT__:
		clearRecoveryEvent();
		break;
	case RPC_ISONLINE__:
		resp->insertBoolean(isOnline());
		break;
	case RPC_ISOFFLINE__:
		resp->insertBoolean(isOffline());
		break;
	case RPC_ISLOADING__:
		resp->insertBoolean(isLoading());
		break;
	case RPC_ISLINKDEAD__:
		resp->insertBoolean(isLinkDead());
		break;
	case RPC_ISLOGGINGIN__:
		resp->insertBoolean(isLoggingIn());
		break;
	case RPC_ISLOGGINGOUT__:
		resp->insertBoolean(isLoggingOut());
		break;
	case RPC_SETSKILLPOINTS__INT_:
		setSkillPoints(inv->getSignedIntParameter());
		break;
	case RPC_ADDSKILLPOINTS__INT_:
		addSkillPoints(inv->getSignedIntParameter());
		break;
	case RPC_GETSKILLPOINTS__:
		resp->insertSignedInt(getSkillPoints());
		break;
	case RPC_UPDATELASTVALIDATEDPOSITION__:
		updateLastValidatedPosition();
		break;
	case RPC_SETSPAWNEDBLUEFROG__:
		setSpawnedBlueFrog();
		break;
	case RPC_HASSPAWNEDBLUEFROG__:
		resp->insertBoolean(hasSpawnedBlueFrog());
		break;
	case RPC_GETACCOUNTID__:
		resp->insertInt(getAccountID());
		break;
	case RPC_GETSERVERMOVEMENTTIMEDELTA__:
		resp->insertLong(getServerMovementTimeDelta());
		break;
	case RPC_SETCLIENTLASTMOVEMENTSTAMP__INT_:
		setClientLastMovementStamp(inv->getUnsignedIntParameter());
		break;
	case RPC_UPDATESERVERLASTMOVEMENTSTAMP__:
		updateServerLastMovementStamp();
		break;
	case RPC_SETACCOUNTID__INT_:
		setAccountID(inv->getUnsignedIntParameter());
		break;
	case RPC_GETFACTIONSTATUS__:
		resp->insertSignedInt(getFactionStatus());
		break;
	case RPC_GETCLIENTLASTMOVEMENTSTAMP__:
		resp->insertInt(getClientLastMovementStamp());
		break;
	case RPC_GETCENTEREDBONUS__:
		resp->insertSignedInt(getCenteredBonus());
		break;
	case RPC_SETCENTEREDBONUS__INT_:
		setCenteredBonus(inv->getSignedIntParameter());
		break;
	case RPC_ISINVISIBLE__:
		resp->insertBoolean(isInvisible());
		break;
	case RPC_SETINVISIBLE__BOOL_:
		setInvisible(inv->getBooleanParameter());
		break;
	case RPC_SETHOLOGRINDMASK__INT_:
		setHologrindMask(inv->getUnsignedIntParameter());
		break;
	case RPC_GETHOLOGRINDMASK__:
		resp->insertInt(getHologrindMask());
		break;
	case RPC_GETRACEID__:
		resp->insertByte(getRaceID());
		break;
	case RPC_SETRACEID__BYTE_:
		setRaceID(inv->getByteParameter());
		break;
	case RPC_SETMAXIMUMLOTS__BYTE_:
		setMaximumLots(inv->getByteParameter());
		break;
	case RPC_GETMAXIMUMLOTS__:
		resp->insertByte(getMaximumLots());
		break;
	default:
		return NULL;
	}

	return resp;
}

void PlayerObjectAdapter::finalize() {
	(static_cast<PlayerObject*>(stub))->finalize();
}

void PlayerObjectAdapter::notifyLoadFromDatabase() {
	(static_cast<PlayerObject*>(stub))->notifyLoadFromDatabase();
}

void PlayerObjectAdapter::unload() {
	(static_cast<PlayerObject*>(stub))->unload();
}

void PlayerObjectAdapter::initializeTransientMembers() {
	(static_cast<PlayerObject*>(stub))->initializeTransientMembers();
}

void PlayerObjectAdapter::sendBaselinesTo(SceneObject* player) {
	(static_cast<PlayerObject*>(stub))->sendBaselinesTo(player);
}

void PlayerObjectAdapter::sendMessage(BasePacket* msg) {
	(static_cast<PlayerObject*>(stub))->sendMessage(msg);
}

void PlayerObjectAdapter::addOwnedStructure(StructureObject* obj) {
	(static_cast<PlayerObject*>(stub))->addOwnedStructure(obj);
}

void PlayerObjectAdapter::removeOwnedStructure(StructureObject* obj) {
	(static_cast<PlayerObject*>(stub))->removeOwnedStructure(obj);
}

int PlayerObjectAdapter::getTotalOwnedStructureCount() {
	return (static_cast<PlayerObject*>(stub))->getTotalOwnedStructureCount();
}

bool PlayerObjectAdapter::isOwnedStructure(StructureObject* obj) {
	return (static_cast<PlayerObject*>(stub))->isOwnedStructure(obj);
}

StructureObject* PlayerObjectAdapter::getOwnedStructure(int i) {
	return (static_cast<PlayerObject*>(stub))->getOwnedStructure(i);
}

int PlayerObjectAdapter::getLotsRemaining() {
	return (static_cast<PlayerObject*>(stub))->getLotsRemaining();
}

bool PlayerObjectAdapter::hasLotsRemaining(int lots) {
	return (static_cast<PlayerObject*>(stub))->hasLotsRemaining(lots);
}

void PlayerObjectAdapter::notifySceneReady() {
	(static_cast<PlayerObject*>(stub))->notifySceneReady();
}

int PlayerObjectAdapter::addExperience(const String& xpType, int xp, bool notifyClient) {
	return (static_cast<PlayerObject*>(stub))->addExperience(xpType, xp, notifyClient);
}

void PlayerObjectAdapter::removeExperience(const String& xpType, bool notifyClient) {
	(static_cast<PlayerObject*>(stub))->removeExperience(xpType, notifyClient);
}

void PlayerObjectAdapter::addWaypoint(WaypointObject* waypoint, bool checkName, bool notifyClient) {
	(static_cast<PlayerObject*>(stub))->addWaypoint(waypoint, checkName, notifyClient);
}

void PlayerObjectAdapter::setWaypoint(WaypointObject* waypoint, bool notifyClient) {
	(static_cast<PlayerObject*>(stub))->setWaypoint(waypoint, notifyClient);
}

void PlayerObjectAdapter::addWaypoint(const String& planet, float positionX, float positionY, bool notifyClient) {
	(static_cast<PlayerObject*>(stub))->addWaypoint(planet, positionX, positionY, notifyClient);
}

void PlayerObjectAdapter::removeWaypoint(unsigned long long waypointID, bool notifyClient) {
	(static_cast<PlayerObject*>(stub))->removeWaypoint(waypointID, notifyClient);
}

void PlayerObjectAdapter::setLanguageID(byte language, bool notifyClient) {
	(static_cast<PlayerObject*>(stub))->setLanguageID(language, notifyClient);
}

void PlayerObjectAdapter::addFriend(const String& name, bool notifyClient) {
	(static_cast<PlayerObject*>(stub))->addFriend(name, notifyClient);
}

void PlayerObjectAdapter::removeFriend(const String& name, bool notifyClient) {
	(static_cast<PlayerObject*>(stub))->removeFriend(name, notifyClient);
}

void PlayerObjectAdapter::addIgnore(const String& name, bool notifyClient) {
	(static_cast<PlayerObject*>(stub))->addIgnore(name, notifyClient);
}

void PlayerObjectAdapter::removeIgnore(const String& name, bool notifyClient) {
	(static_cast<PlayerObject*>(stub))->removeIgnore(name, notifyClient);
}

void PlayerObjectAdapter::setTitle(const String& characterTitle, bool notifyClient) {
	(static_cast<PlayerObject*>(stub))->setTitle(characterTitle, notifyClient);
}

void PlayerObjectAdapter::setFoodFilling(int newValue, bool notifyClient) {
	(static_cast<PlayerObject*>(stub))->setFoodFilling(newValue, notifyClient);
}

void PlayerObjectAdapter::setDrinkFilling(int newValue, bool notifyClient) {
	(static_cast<PlayerObject*>(stub))->setDrinkFilling(newValue, notifyClient);
}

void PlayerObjectAdapter::increaseFactionStanding(const String& factionName, float amount) {
	(static_cast<PlayerObject*>(stub))->increaseFactionStanding(factionName, amount);
}

void PlayerObjectAdapter::decreaseFactionStanding(const String& factionName, float amount) {
	(static_cast<PlayerObject*>(stub))->decreaseFactionStanding(factionName, amount);
}

float PlayerObjectAdapter::getFactionStanding(const String& factionName) {
	return (static_cast<PlayerObject*>(stub))->getFactionStanding(factionName);
}

WaypointObject* PlayerObjectAdapter::getSurveyWaypoint() {
	return (static_cast<PlayerObject*>(stub))->getSurveyWaypoint();
}

void PlayerObjectAdapter::activateRecovery() {
	(static_cast<PlayerObject*>(stub))->activateRecovery();
}

void PlayerObjectAdapter::doRecovery() {
	(static_cast<PlayerObject*>(stub))->doRecovery();
}

void PlayerObjectAdapter::disconnect(bool closeClient, bool doLock) {
	(static_cast<PlayerObject*>(stub))->disconnect(closeClient, doLock);
}

void PlayerObjectAdapter::reload(ZoneClientSession* client) {
	(static_cast<PlayerObject*>(stub))->reload(client);
}

void PlayerObjectAdapter::setOffline() {
	(static_cast<PlayerObject*>(stub))->setOffline();
}

void PlayerObjectAdapter::setLinkDead() {
	(static_cast<PlayerObject*>(stub))->setLinkDead();
}

void PlayerObjectAdapter::setOnline() {
	(static_cast<PlayerObject*>(stub))->setOnline();
}

void PlayerObjectAdapter::setLoggingOut() {
	(static_cast<PlayerObject*>(stub))->setLoggingOut();
}

void PlayerObjectAdapter::sendBadgesResponseTo(CreatureObject* player) {
	(static_cast<PlayerObject*>(stub))->sendBadgesResponseTo(player);
}

void PlayerObjectAdapter::logout(bool doLock) {
	(static_cast<PlayerObject*>(stub))->logout(doLock);
}

void PlayerObjectAdapter::setLastNpcConvStr(const String& conv) {
	(static_cast<PlayerObject*>(stub))->setLastNpcConvStr(conv);
}

void PlayerObjectAdapter::setLastNpcConvMessStr(const String& mess) {
	(static_cast<PlayerObject*>(stub))->setLastNpcConvMessStr(mess);
}

String PlayerObjectAdapter::getLastNpcConvStr() {
	return (static_cast<PlayerObject*>(stub))->getLastNpcConvStr();
}

String PlayerObjectAdapter::getLastNpcConvMessStr() {
	return (static_cast<PlayerObject*>(stub))->getLastNpcConvMessStr();
}

String PlayerObjectAdapter::getLastNpcConvOption(int idx) {
	return (static_cast<PlayerObject*>(stub))->getLastNpcConvOption(idx);
}

void PlayerObjectAdapter::addLastNpcConvOptions(const String& option) {
	(static_cast<PlayerObject*>(stub))->addLastNpcConvOptions(option);
}

int PlayerObjectAdapter::countLastNpcConvOptions() {
	return (static_cast<PlayerObject*>(stub))->countLastNpcConvOptions();
}

void PlayerObjectAdapter::clearLastNpcConvOptions() {
	(static_cast<PlayerObject*>(stub))->clearLastNpcConvOptions();
}

void PlayerObjectAdapter::setConversatingCreature(CreatureObject* creature) {
	(static_cast<PlayerObject*>(stub))->setConversatingCreature(creature);
}

CreatureObject* PlayerObjectAdapter::getConversatingCreature() {
	return (static_cast<PlayerObject*>(stub))->getConversatingCreature();
}

void PlayerObjectAdapter::addPersistentMessage(unsigned long long id) {
	(static_cast<PlayerObject*>(stub))->addPersistentMessage(id);
}

void PlayerObjectAdapter::dropPersistentMessage(unsigned long long id) {
	(static_cast<PlayerObject*>(stub))->dropPersistentMessage(id);
}

void PlayerObjectAdapter::unloadSpawnedChildren() {
	(static_cast<PlayerObject*>(stub))->unloadSpawnedChildren();
}

void PlayerObjectAdapter::addToConsentList(const String& name) {
	(static_cast<PlayerObject*>(stub))->addToConsentList(name);
}

bool PlayerObjectAdapter::hasInConsentList(const String& name) {
	return (static_cast<PlayerObject*>(stub))->hasInConsentList(name);
}

void PlayerObjectAdapter::removeFromConsentList(const String& name) {
	(static_cast<PlayerObject*>(stub))->removeFromConsentList(name);
}

String PlayerObjectAdapter::getConsentName(int i) {
	return (static_cast<PlayerObject*>(stub))->getConsentName(i);
}

int PlayerObjectAdapter::getConsentListSize() {
	return (static_cast<PlayerObject*>(stub))->getConsentListSize();
}

void PlayerObjectAdapter::setCommandMessageString(unsigned int actionCRC, String& message) {
	(static_cast<PlayerObject*>(stub))->setCommandMessageString(actionCRC, message);
}

void PlayerObjectAdapter::removeCommandMessageString(unsigned int actionCRC) {
	(static_cast<PlayerObject*>(stub))->removeCommandMessageString(actionCRC);
}

BuildingObject* PlayerObjectAdapter::getDeclaredResidence() {
	return (static_cast<PlayerObject*>(stub))->getDeclaredResidence();
}

void PlayerObjectAdapter::setDeclaredResidence(BuildingObject* residence) {
	(static_cast<PlayerObject*>(stub))->setDeclaredResidence(residence);
}

void PlayerObjectAdapter::setCloningFacility(BuildingObject* cloningfac) {
	(static_cast<PlayerObject*>(stub))->setCloningFacility(cloningfac);
}

BuildingObject* PlayerObjectAdapter::getCloningFacility() {
	return (static_cast<PlayerObject*>(stub))->getCloningFacility();
}

void PlayerObjectAdapter::notifyOnline() {
	(static_cast<PlayerObject*>(stub))->notifyOnline();
}

void PlayerObjectAdapter::doDigest() {
	(static_cast<PlayerObject*>(stub))->doDigest();
}

bool PlayerObjectAdapter::isDigesting() {
	return (static_cast<PlayerObject*>(stub))->isDigesting();
}

String PlayerObjectAdapter::getSavedTerrainName() {
	return (static_cast<PlayerObject*>(stub))->getSavedTerrainName();
}

void PlayerObjectAdapter::setSavedParentID(unsigned long long id) {
	(static_cast<PlayerObject*>(stub))->setSavedParentID(id);
}

void PlayerObjectAdapter::setSavedTerrainName(const String& name) {
	(static_cast<PlayerObject*>(stub))->setSavedTerrainName(name);
}

void PlayerObjectAdapter::setForcePower(int fp, bool notifyClient) {
	(static_cast<PlayerObject*>(stub))->setForcePower(fp, notifyClient);
}

void PlayerObjectAdapter::setForcePowerMax(int fpm, bool notifyClient) {
	(static_cast<PlayerObject*>(stub))->setForcePowerMax(fpm, notifyClient);
}

void PlayerObjectAdapter::activateForceRegen() {
	(static_cast<PlayerObject*>(stub))->activateForceRegen();
}

unsigned long long PlayerObjectAdapter::getSavedParentID() {
	return (static_cast<PlayerObject*>(stub))->getSavedParentID();
}

unsigned int PlayerObjectAdapter::getNewSuiBoxID(unsigned int type) {
	return (static_cast<PlayerObject*>(stub))->getNewSuiBoxID(type);
}

bool PlayerObjectAdapter::hasSuiBox(unsigned int boxID) {
	return (static_cast<PlayerObject*>(stub))->hasSuiBox(boxID);
}

SuiBox* PlayerObjectAdapter::getSuiBox(unsigned int boxID) {
	return (static_cast<PlayerObject*>(stub))->getSuiBox(boxID);
}

void PlayerObjectAdapter::removeSuiBox(unsigned int boxID, bool closeWindowToClient) {
	(static_cast<PlayerObject*>(stub))->removeSuiBox(boxID, closeWindowToClient);
}

void PlayerObjectAdapter::removeSuiBoxType(unsigned int windowType) {
	(static_cast<PlayerObject*>(stub))->removeSuiBoxType(windowType);
}

bool PlayerObjectAdapter::hasSuiBoxWindowType(unsigned int windowType) {
	return (static_cast<PlayerObject*>(stub))->hasSuiBoxWindowType(windowType);
}

void PlayerObjectAdapter::closeSuiWindowType(unsigned int windowType) {
	(static_cast<PlayerObject*>(stub))->closeSuiWindowType(windowType);
}

SuiBox* PlayerObjectAdapter::getSuiBoxFromWindowType(unsigned int windowType) {
	return (static_cast<PlayerObject*>(stub))->getSuiBoxFromWindowType(windowType);
}

void PlayerObjectAdapter::addSuiBox(SuiBox* sui) {
	(static_cast<PlayerObject*>(stub))->addSuiBox(sui);
}

bool PlayerObjectAdapter::isFirstIncapacitationExpired() {
	return (static_cast<PlayerObject*>(stub))->isFirstIncapacitationExpired();
}

void PlayerObjectAdapter::resetIncapacitationCounter() {
	(static_cast<PlayerObject*>(stub))->resetIncapacitationCounter();
}

void PlayerObjectAdapter::resetFirstIncapacitationTime() {
	(static_cast<PlayerObject*>(stub))->resetFirstIncapacitationTime();
}

void PlayerObjectAdapter::updateIncapacitationCounter() {
	(static_cast<PlayerObject*>(stub))->updateIncapacitationCounter();
}

bool PlayerObjectAdapter::isFirstIncapacitation() {
	return (static_cast<PlayerObject*>(stub))->isFirstIncapacitation();
}

byte PlayerObjectAdapter::getIncapacitationCounter() {
	return (static_cast<PlayerObject*>(stub))->getIncapacitationCounter();
}

void PlayerObjectAdapter::addToDuelList(CreatureObject* targetPlayer) {
	(static_cast<PlayerObject*>(stub))->addToDuelList(targetPlayer);
}

void PlayerObjectAdapter::removeFromDuelList(CreatureObject* targetPlayer) {
	(static_cast<PlayerObject*>(stub))->removeFromDuelList(targetPlayer);
}

CreatureObject* PlayerObjectAdapter::getDuelListObject(int index) {
	return (static_cast<PlayerObject*>(stub))->getDuelListObject(index);
}

bool PlayerObjectAdapter::requestedDuelTo(CreatureObject* targetPlayer) {
	return (static_cast<PlayerObject*>(stub))->requestedDuelTo(targetPlayer);
}

bool PlayerObjectAdapter::isDuelListEmpty() {
	return (static_cast<PlayerObject*>(stub))->isDuelListEmpty();
}

int PlayerObjectAdapter::getDuelListSize() {
	return (static_cast<PlayerObject*>(stub))->getDuelListSize();
}

UnicodeString PlayerObjectAdapter::getBiography() {
	return (static_cast<PlayerObject*>(stub))->getBiography();
}

void PlayerObjectAdapter::notifyOffline() {
	(static_cast<PlayerObject*>(stub))->notifyOffline();
}

void PlayerObjectAdapter::setBadge(unsigned int badge) {
	(static_cast<PlayerObject*>(stub))->setBadge(badge);
}

void PlayerObjectAdapter::awardBadge(unsigned int badge) {
	(static_cast<PlayerObject*>(stub))->awardBadge(badge);
}

void PlayerObjectAdapter::setSurveyTool(SurveyTool* tool) {
	(static_cast<PlayerObject*>(stub))->setSurveyTool(tool);
}

SurveyTool* PlayerObjectAdapter::getSurveyTool() {
	return (static_cast<PlayerObject*>(stub))->getSurveyTool();
}

CraftingTool* PlayerObjectAdapter::getLastCraftingToolUsed() {
	return (static_cast<PlayerObject*>(stub))->getLastCraftingToolUsed();
}

void PlayerObjectAdapter::setLastCraftingToolUsed(CraftingTool* tool) {
	(static_cast<PlayerObject*>(stub))->setLastCraftingToolUsed(tool);
}

void PlayerObjectAdapter::setTeleporting(bool val) {
	(static_cast<PlayerObject*>(stub))->setTeleporting(val);
}

int PlayerObjectAdapter::getNumBadges() {
	return (static_cast<PlayerObject*>(stub))->getNumBadges();
}

int PlayerObjectAdapter::getBadgeTypeCount(byte type) {
	return (static_cast<PlayerObject*>(stub))->getBadgeTypeCount(type);
}

bool PlayerObjectAdapter::hasFriend(const String& name) {
	return (static_cast<PlayerObject*>(stub))->hasFriend(name);
}

bool PlayerObjectAdapter::isIgnoring(const String& name) {
	return (static_cast<PlayerObject*>(stub))->isIgnoring(name);
}

void PlayerObjectAdapter::addReverseFriend(const String& name) {
	(static_cast<PlayerObject*>(stub))->addReverseFriend(name);
}

void PlayerObjectAdapter::removeReverseFriend(const String& name) {
	(static_cast<PlayerObject*>(stub))->removeReverseFriend(name);
}

void PlayerObjectAdapter::sendFriendLists() {
	(static_cast<PlayerObject*>(stub))->sendFriendLists();
}

bool PlayerObjectAdapter::hasWaypoint(unsigned long long objectID) {
	return (static_cast<PlayerObject*>(stub))->hasWaypoint(objectID);
}

bool PlayerObjectAdapter::hasCommandMessageString(unsigned int actionCRC) {
	return (static_cast<PlayerObject*>(stub))->hasCommandMessageString(actionCRC);
}

unsigned int PlayerObjectAdapter::getCharacterBitmask() {
	return (static_cast<PlayerObject*>(stub))->getCharacterBitmask();
}

String PlayerObjectAdapter::getTitle() {
	return (static_cast<PlayerObject*>(stub))->getTitle();
}

unsigned int PlayerObjectAdapter::getAdminLevel() {
	return (static_cast<PlayerObject*>(stub))->getAdminLevel();
}

void PlayerObjectAdapter::setAdminLevel(unsigned int adminlvl) {
	(static_cast<PlayerObject*>(stub))->setAdminLevel(adminlvl);
}

void PlayerObjectAdapter::setBiography(const UnicodeString& bio) {
	(static_cast<PlayerObject*>(stub))->setBiography(bio);
}

bool PlayerObjectAdapter::isDeveloper() {
	return (static_cast<PlayerObject*>(stub))->isDeveloper();
}

bool PlayerObjectAdapter::isCSR() {
	return (static_cast<PlayerObject*>(stub))->isCSR();
}

bool PlayerObjectAdapter::isPrivileged() {
	return (static_cast<PlayerObject*>(stub))->isPrivileged();
}

void PlayerObjectAdapter::setCharacterBitmask(unsigned int bitmask) {
	(static_cast<PlayerObject*>(stub))->setCharacterBitmask(bitmask);
}

bool PlayerObjectAdapter::setCharacterBit(unsigned int bit, bool notifyClient) {
	return (static_cast<PlayerObject*>(stub))->setCharacterBit(bit, notifyClient);
}

bool PlayerObjectAdapter::clearCharacterBit(unsigned int bit, bool notifyClient) {
	return (static_cast<PlayerObject*>(stub))->clearCharacterBit(bit, notifyClient);
}

void PlayerObjectAdapter::toggleCharacterBit(unsigned int bit) {
	(static_cast<PlayerObject*>(stub))->toggleCharacterBit(bit);
}

int PlayerObjectAdapter::getForcePower() {
	return (static_cast<PlayerObject*>(stub))->getForcePower();
}

int PlayerObjectAdapter::getForcePowerMax() {
	return (static_cast<PlayerObject*>(stub))->getForcePowerMax();
}

DraftSchematic* PlayerObjectAdapter::getSchematic(int i) {
	return (static_cast<PlayerObject*>(stub))->getSchematic(i);
}

int PlayerObjectAdapter::getFoodFilling() {
	return (static_cast<PlayerObject*>(stub))->getFoodFilling();
}

int PlayerObjectAdapter::getFoodFillingMax() {
	return (static_cast<PlayerObject*>(stub))->getFoodFillingMax();
}

int PlayerObjectAdapter::getDrinkFilling() {
	return (static_cast<PlayerObject*>(stub))->getDrinkFilling();
}

int PlayerObjectAdapter::getDrinkFillingMax() {
	return (static_cast<PlayerObject*>(stub))->getDrinkFillingMax();
}

int PlayerObjectAdapter::getJediState() {
	return (static_cast<PlayerObject*>(stub))->getJediState();
}

byte PlayerObjectAdapter::getLanguageID() {
	return (static_cast<PlayerObject*>(stub))->getLanguageID();
}

bool PlayerObjectAdapter::isTeleporting() {
	return (static_cast<PlayerObject*>(stub))->isTeleporting();
}

void PlayerObjectAdapter::addChatRoom(ChatRoom* room) {
	(static_cast<PlayerObject*>(stub))->addChatRoom(room);
}

void PlayerObjectAdapter::removeChatRoom(ChatRoom* room) {
	(static_cast<PlayerObject*>(stub))->removeChatRoom(room);
}

int PlayerObjectAdapter::getExperience(const String& xp) {
	return (static_cast<PlayerObject*>(stub))->getExperience(xp);
}

void PlayerObjectAdapter::maximizeExperience() {
	(static_cast<PlayerObject*>(stub))->maximizeExperience();
}

String PlayerObjectAdapter::getCommandMessageString(unsigned int actionCRC) {
	return (static_cast<PlayerObject*>(stub))->getCommandMessageString(actionCRC);
}

bool PlayerObjectAdapter::hasBadge(unsigned int badge) {
	return (static_cast<PlayerObject*>(stub))->hasBadge(badge);
}

void PlayerObjectAdapter::clearDisconnectEvent() {
	(static_cast<PlayerObject*>(stub))->clearDisconnectEvent();
}

void PlayerObjectAdapter::clearRecoveryEvent() {
	(static_cast<PlayerObject*>(stub))->clearRecoveryEvent();
}

bool PlayerObjectAdapter::isOnline() {
	return (static_cast<PlayerObject*>(stub))->isOnline();
}

bool PlayerObjectAdapter::isOffline() {
	return (static_cast<PlayerObject*>(stub))->isOffline();
}

bool PlayerObjectAdapter::isLoading() {
	return (static_cast<PlayerObject*>(stub))->isLoading();
}

bool PlayerObjectAdapter::isLinkDead() {
	return (static_cast<PlayerObject*>(stub))->isLinkDead();
}

bool PlayerObjectAdapter::isLoggingIn() {
	return (static_cast<PlayerObject*>(stub))->isLoggingIn();
}

bool PlayerObjectAdapter::isLoggingOut() {
	return (static_cast<PlayerObject*>(stub))->isLoggingOut();
}

void PlayerObjectAdapter::setSkillPoints(int points) {
	(static_cast<PlayerObject*>(stub))->setSkillPoints(points);
}

void PlayerObjectAdapter::addSkillPoints(int points) {
	(static_cast<PlayerObject*>(stub))->addSkillPoints(points);
}

int PlayerObjectAdapter::getSkillPoints() {
	return (static_cast<PlayerObject*>(stub))->getSkillPoints();
}

void PlayerObjectAdapter::updateLastValidatedPosition() {
	(static_cast<PlayerObject*>(stub))->updateLastValidatedPosition();
}

void PlayerObjectAdapter::setSpawnedBlueFrog() {
	(static_cast<PlayerObject*>(stub))->setSpawnedBlueFrog();
}

bool PlayerObjectAdapter::hasSpawnedBlueFrog() {
	return (static_cast<PlayerObject*>(stub))->hasSpawnedBlueFrog();
}

unsigned int PlayerObjectAdapter::getAccountID() {
	return (static_cast<PlayerObject*>(stub))->getAccountID();
}

unsigned long long PlayerObjectAdapter::getServerMovementTimeDelta() {
	return (static_cast<PlayerObject*>(stub))->getServerMovementTimeDelta();
}

void PlayerObjectAdapter::setClientLastMovementStamp(unsigned int stamp) {
	(static_cast<PlayerObject*>(stub))->setClientLastMovementStamp(stamp);
}

void PlayerObjectAdapter::updateServerLastMovementStamp() {
	(static_cast<PlayerObject*>(stub))->updateServerLastMovementStamp();
}

void PlayerObjectAdapter::setAccountID(unsigned int id) {
	(static_cast<PlayerObject*>(stub))->setAccountID(id);
}

int PlayerObjectAdapter::getFactionStatus() {
	return (static_cast<PlayerObject*>(stub))->getFactionStatus();
}

unsigned int PlayerObjectAdapter::getClientLastMovementStamp() {
	return (static_cast<PlayerObject*>(stub))->getClientLastMovementStamp();
}

int PlayerObjectAdapter::getCenteredBonus() {
	return (static_cast<PlayerObject*>(stub))->getCenteredBonus();
}

void PlayerObjectAdapter::setCenteredBonus(int bonus) {
	(static_cast<PlayerObject*>(stub))->setCenteredBonus(bonus);
}

bool PlayerObjectAdapter::isInvisible() {
	return (static_cast<PlayerObject*>(stub))->isInvisible();
}

void PlayerObjectAdapter::setInvisible(bool invis) {
	(static_cast<PlayerObject*>(stub))->setInvisible(invis);
}

void PlayerObjectAdapter::setHologrindMask(unsigned int mask) {
	(static_cast<PlayerObject*>(stub))->setHologrindMask(mask);
}

unsigned int PlayerObjectAdapter::getHologrindMask() {
	return (static_cast<PlayerObject*>(stub))->getHologrindMask();
}

byte PlayerObjectAdapter::getRaceID() {
	return (static_cast<PlayerObject*>(stub))->getRaceID();
}

void PlayerObjectAdapter::setRaceID(byte race) {
	(static_cast<PlayerObject*>(stub))->setRaceID(race);
}

void PlayerObjectAdapter::setMaximumLots(byte lots) {
	(static_cast<PlayerObject*>(stub))->setMaximumLots(lots);
}

byte PlayerObjectAdapter::getMaximumLots() {
	return (static_cast<PlayerObject*>(stub))->getMaximumLots();
}

/*
 *	PlayerObjectHelper
 */

PlayerObjectHelper* PlayerObjectHelper::staticInitializer = PlayerObjectHelper::instance();

PlayerObjectHelper::PlayerObjectHelper() {
	className = "PlayerObject";

	Core::getObjectBroker()->registerClass(className, this);
}

void PlayerObjectHelper::finalizeHelper() {
	PlayerObjectHelper::finalize();
}

DistributedObject* PlayerObjectHelper::instantiateObject() {
	return new PlayerObject(DummyConstructorParameter::instance());
}

DistributedObjectServant* PlayerObjectHelper::instantiateServant() {
	return new PlayerObjectImplementation(DummyConstructorParameter::instance());
}

DistributedObjectAdapter* PlayerObjectHelper::createAdapter(DistributedObjectStub* obj) {
	DistributedObjectAdapter* adapter = new PlayerObjectAdapter(static_cast<PlayerObject*>(obj));

	obj->_setClassName(className);
	obj->_setClassHelper(this);

	adapter->setStub(obj);

	return adapter;
}

